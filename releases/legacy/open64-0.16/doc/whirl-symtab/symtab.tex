%\documentclass{book}
%\usepackage{longtable}
%\usepackage{makeidx}
%\LTcapwidth=\textwidth
%\makeindex
%\oddsidemargin 0in
%\evensidemargin 0in
%\textheight 9in
%\textwidth 6.5in
%\topmargin 0in
%\textfraction .01
%\floatfraction .99

%\begin{document}
\chapter{Whirl Symbol Table}
\label{chap:symtab}


\section{Introduction and Overview}

This document describes the symbol table portion of the WHIRL file
produced and used by the Open64 compiler. A separate document
describes the WHIRL intermediate program representation. The WHIRL
symbol table is made up of a series of tables. They are designed for
compilation, optimization and storage efficiency. The way the tables
are organized closely corresponds to the compiler's view of the symbol
table. The model also enhances locality in references to the
tables. The WHIRL symbol table is divided into the global part and the
local part. The local part is organized by program units
(PUs). Figure~\ref{fig:symtabs}
gives a pictorial overview of the WHIRL symbol table as produced by
the front-ends. There are different kinds of tables. The 
tables that can appear in both the 
global and local part of the symbol table are:

\begin{enumerate}
\item
\index{ST\_TAB}%
ST\_TAB -- This is the fundamental building block of the symbol
  table. In general, any symbol with a name occupies an entry in this
  table.  Any constant value that reside in memory (floating point
  and string constants) also occupies an entry in this table.

\item
\index{INITO\_TAB}%
INITO\_TAB -- Each entry specifies the initial value(s) of an
  initialized data object. It in turn refers to one or more entries in
the
\index{INITV\_TAB}%
INITV\_TAB for initial values of each individual component of
  the data object.

\item
\index{ST\_ATTR\_TAB}%
ST\_ATTR\_TAB -- Each entry associates some miscellaneous
  attributes with an entry in the ST\_TAB.
\end{enumerate}

\noindent The tables that can only appear in the global part of the symbol table are:

\begin{enumerate}
\item
\index{PU\_TAB}%
PU\_TAB -- Each entry represents a procedure that appears in the
  source file as either function prototype or definition.

\item
\index{TY\_TAB}%
TY\_TAB -- Each entry represents a distinct type in the
  program. It in turn refers to the FLD\_TAB, TYLIST\_TAB, ARB\_TAB,
or
\index{PU\_TAB}%
PU\_TAB to specify the full structure of each type.

\item
\index{FLD\_TAB}%
FLD\_TAB -- Each entry specifies a field in a struct type.

\item
\index{TYLIST\_TAB}%
TYLIST\_TAB -- Each entry specifies a parameter type in a
  function prototype declaration.

\item
\index{ARB\_TAB}%
ARB\_TAB -- Each entry gives information about a dimension of an
  array type.

\item
\index{TCON\_TAB}%
TCON\_TAB -- The values of any non-integer constants are
  stored here. For string constants, it in turn refers to the
  TCON\_STR\_TAB.

\item
\index{BLK\_TAB}%
BLK\_TAB -- Each entry specifies layout information of a block
  of data.

\item
\index{INITV\_TAB}%
INITV\_TAB -- Each entry describes the initial value of a scalar
  component of an initialized data object.


\begin{figure}
\centering
\caption{Whirl symbol table produced by the front ends.}
\label{fig:symtabs}
\vbox to 4in{
\fbox{
\vbox to 1.1in{
\vfil
\hbox{Global SYMTAB}
\vfil
\hbox to .9\textwidth{
\hfil
\fbox{ST\_TAB} 
\hfil
\fbox{PU\_TAB} 
\hfil
\fbox{TY\_TAB} 
\hfil
\fbox{TYLIST\_TAB} 
\hfil
\fbox{TCON\_TAB} 
\hfil
\fbox{BLK\_TAB} 
\hfil
\fbox{INITV\_TAB} 
\hfil
}
\vfil
\hbox to .9\textwidth{
\hfil
\fbox{INITO\_TAB}
\hfil
\fbox{FLD\_TAB} 
\hfil
\fbox{ARB\_TAB}
\hfil
\fbox{TCON\_STR\_TAB}
\hfil
\fbox{STR\_TAB} 
\hfil
\fbox{ST\_ATTR\_TAB} 
\hfil
}
\vfil
}
}
\vfil
\vfil
\fbox{
\vbox to .9in{
\vfil
\hbox{PU$_1$ SYMTAB}
\vfil
\hbox to .9\textwidth{
\hfil
\fbox{ST\_TAB} 
\hfil
\fbox{INITO\_TAB} 
\hfil
\fbox{LABEL\_TAB} 
\hfil
\fbox{PREG\_TAB} 
\hfil
\fbox{ST\_ATTR\_TAB}
\hfil
}
\vfil
}
}
\vfil
\vbox{$\bf\vdots$}
\vfil
\fbox{
\vbox to .9in{
\vfil
\hbox{PU$_n$ SYMTAB}
\vfil
\hbox to .9\textwidth{
\hfil
\fbox{ST\_TAB} 
\hfil
\fbox{INITO\_TAB} 
\hfil
\fbox{LABEL\_TAB} 
\hfil
\fbox{PREG\_TAB} 
\hfil
\fbox{ST\_ATTR\_TAB}
\hfil
}
\vfil
}
}
}

\end{figure}



\item
\index{STR\_TAB}%
STR\_TAB -- All strings are stored here. They include names of
variable, types, labels, etc. 

\item
\index{TCON\_STR\_TAB}%
TCON\_STR\_TAB -- All string literals defined in the user
  program are stored in this table.
\end{enumerate}

\noindent The tables that can only appear in the local part of the
symbol table are:

\begin{enumerate}
\item
\index{LABEL\_TAB}%
LABEL\_TAB --Information associated with each WHIRL label used
in the
\index{PU}%
PU is stored here.

\item
\index{PREG\_TAB}%
PREG\_TAB --Information associated with each pseudo-register
used in the
\index{PU}%
PU is stored here.
\end{enumerate}

Apart from the above tables, each compiler component is free to
allocate additional tables for its own internal use in storing extra
information. The additional tables are to have the same number of
entries and be referred to by the same type of index as one of the
above tables. As a general rule, the first entry of each table has
index 1; index 0 is reserved to stand for uninitialized index
value. The design also assumes that any table will never grow to more
than 16 million entries, so that only 24 bits are needed to contain a
table index. An exception is STR\_TAB, in which the index is really a
byte offset.

The tables listed so far mainly serves the purpose of communicating
information gathered by the front-ends to the back-end phases during
compilation. The back-end optimization phases may create more
information, and the new information can reside in additional tables
created for the purpose of passing information to the other back-end
components. These tables will be prefixed by the name of the component
that creates the information in the table, e.g. IPA\_ST\_TAB,
WOPT\_ST\_TAB, etc. In particular,
\index{BE\_ST\_TAB}%
BE\_ST\_TAB
(Section~\ref{be-st-tab}) serves to communicate information among the
back-end components, including IPA.

The remaining sections of this chapter describe the symbol table  
structures in more details and the interfaces to them.

\section{SCOPE}
Depending on the context, a different set of symbol tables might
become visible. For example, in a nested procedure, three ST\_TABs are
visible --its own local ST\_TAB, the parent PU's ST\_TAB, and the
global ST\_TAB. Associated with each PU, a
\index{SCOPE}%
SCOPE array is defined for
specifying the list of visible tables. The index to this array is the
lexical scope. Index 0 is reserved.  Index 1 refers to the global
symbol tables, and index 2 refers to the local symbol tables. A nested
procedure will have an index starting at 3, depending on the level of
nesting. The type of the
\index{SCOPE}%
SCOPE array index is SYMTAB\_IDX, which is an
unsigned 8-bit integer.

Strictly speaking,
\index{SCOPE}%
SCOPE arrays are not part of the symbol table, and
they are never written out to a WHIRL file. Tables that can only appear
in the global part of the symbol table are always visible. So they are
not explicitly described by the
\index{SCOPE}%
SCOPE array. Each element of a
\index{SCOPE}%
SCOPE
array has the following structure, size 24 bytes:

\begin{table}[h]
\centering
\caption{Layout of a
\index{SCOPE}%
SCOPE Array Element.}
{\small
\begin{tabular}{|l|l|l|l|l|}\hline
Offset & Field & Type & Description & Field size \\\hline\hline
byte 0 & pool &
\index{MEM\_POOL}%
MEM\_POOL * & pointer to the memory pool for local
tables & 1 word \\\hline
byte 4 & st &
\index{ST}%
ST * & pointer to the
\index{ST}%
ST for this
\index{PU}%
PU & 1 word \\\hline
byte 8 & st\_tab &
\index{ST\_TAB}%
ST\_TAB * & pointer to the table of
\index{ST}%
ST entries & 1
word \\\hline
byte 12 & label\_tab &
\index{LABEL\_TAB}%
LABEL\_TAB * & pointer to the table of labels &
1 word \\\hline
byte 16 & preg\_tab &
\index{PREG\_TAB}%
PREG\_TAB * & pointer to the table of pseudo
registers & 1 word \\\hline
byte 20 & inito\_tab &
\index{INITO\_TAB}%
INITO\_TAB * & pointer to the table of
\index{INITO}%
INITO
entries. & 1 word \\\hline
byte 24 & st\_attr\_tab &
\index{ST\_ATTR\_TAB}%
ST\_ATTR\_TAB * & pointer to the table of
\index{ST\_ATTR}%
ST\_ATTR entries &  1 word\\\hline
\end{tabular}
}
\end{table}

For the global scope (i.e., index 1of the
\index{SCOPE}%
SCOPE array), the fields
pool, st, label\_tab, and preg\_tab are not used, and contain the NULL
pointer.

\section{ST\_TAB}

Each entry of this table is an ST. A symbol in the program is uniquely
identified by a value of type ST\_IDX.

\section{ST\_IDX}

\index{ST\_IDX}%
ST\_IDX is of size 32 bits, and is composed of two parts:

\begin{table}[h]
\centering
\caption{Layout of ST\_IDX} 
\begin{tabular}{|l|l|l|}\hline
Field & Description & Field position and size\\\hline \hline
level & lexical level & least significant 8 bits \\\hline
index & index to
\index{ST\_TAB}%
ST\_TAB & most significant 24 bits\\\hline
\end{tabular}
\end{table}


The low order 8 bits are used to index into the
\index{SCOPE}%
SCOPE array in order
to get to the ST\_TAB.

\subsection{ST Entry}

The
\index{ST}%
ST entry has the following structure, size 32 bytes:

\begin{table}[h]
\centering
\caption{Layout of ST} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size\\\hline \hline
byte 0 & name\_idx &
\index{STR\_IDX}%
STR\_IDX to the name string & 1 word\\
byte 0 & tcon &
\index{TCON\_IDX}%
TCON\_IDX of the constant value & 1 word\\\hline
byte 4 & flags & misc. attributes of this entry & 1 word \\\hline
byte 8 & flags\_ext & more flags for future extension & 1 byte \\\hline
byte 9 & sym\_class & class of symbol & 1 byte \\\hline 
byte 10 & storage\_class & storage class of symbol & 1 byte \\\hline
byte 11 & export & export class of the symbol & 1 byte \\\hline
byte 12 & type &
\index{TY\_IDX}%
TY\_IDX of the high-level type & 1 word \\\hline
byte 12 & pu &
\index{PU\_IDX}%
PU\_IDX if program unit & 1 word \\\hline
byte 12 & blk &
\index{BLK\_IDX}%
BLK\_IDX if
\index{CLASS\_BLOCK}%
CLASS\_BLOCK & 1 word \\\hline
byte 16 & offset & offset from base & 2 words \\\hline
byte 24 & base\_idx &
\index{ST\_IDX}%
ST\_IDX of the base of the allocated block & 1
word \\\hline
byte 28 & st\_idx &
\index{ST\_IDX}%
ST\_IDX for this entry & 1 word\\\hline
\end{tabular}
\end{table}


\begin{description}
\item[name\_idx/tcon]: If sym\_class is CLASS\_CONST, the tcon field
  holds the index to the TCON\_TAB. For all other sym\_class values,
  the name\_idx field holds the index to the STR\_TAB. If the export
class is
\index{EXPORT\_LOCAL}%
EXPORT\_LOCAL or EXPORT\_LOCAL\_INTERNAL, the name is
  optional. And when there is no name, name\_idx should be zero.

\item[flags/flags\_ext]: Miscellaneous attributes, See Section
  2.3.5. 
\item[sym\_class]: The class of symbol, see
  Table~\ref{sym-class}. 
\item[storage\_class]: The storage class of symbol,
  see Table~\ref{stor-class}. 
\item[export]: The export class of symbol, see Section
  2.3.4. 
\item[type/pu/blk]: If sym\_class is CLASS\_FUNC, then the pu field
  holds the index to the PU\_TAB. If sym\_class is CLASS\_BLOCK, this
  field holds the BLK\_IDX. If sym\_class is CLASS\_NAME, this field
  must be zero. Forall other valid sym\_class values, the type field
holds the
\index{TY\_IDX}%
TY\_IDX that describes the type of this symbol.

One exception is a
\index{CLASS\_NAME}%
CLASS\_NAME symbol that has the
\index{ST\_ASM\_FUNCTION\_ST}%
ST\_ASM\_FUNCTION\_ST bit set, in which case the pufield holds the index to the
PU\_TAB.

\item[offset]: The byte offset from base\_idx. If base\_idx is equal to
st\_idx, then offset must be zero.

\item[base\_idx]: This is the
\index{ST\_IDX}%
ST\_IDX for the
\index{ST}%
ST that describes the
  base address (i.e., this symbol is an alias of the specified
  symbol).  If it is equal to it's own st\_idx, then the address of
this symbol is independently assigned. If
\index{ST\_IS\_WEAK\_ALIAS}%
ST\_IS\_WEAK\_ALIAS is
  set, base\_idx is overloaded to specify the corresponding strong
  definition (see Table~\ref{table9} and Section 2.3.7). If
\index{ST\_IS\_SPLIT\_COMMON}%
  ST\_IS\_SPLIT\_COMMON is set, base\_idx is overloaded to be the full
common definition. It is illegal to set both
\index{ST\_IS\_WEAK\_ALIAS}%
ST\_IS\_WEAK\_ALIAS
  and ST\_IS\_SPLIT\_COMMON.

The following rules apply when setting the base address of a symbol. If a symbol
A is based on symbol B (i.e. base\_idx of A is equal to st\_idx of B), then:

\begin{enumerate}
\item storage\_class of A must be the same as
storage\_class of B, except when the sym\_class of B is
\index{CLASS\_BLOCK}%
CLASS\_BLOCK and storage\_class of B is SCLASS\_UNKNOWN.


\item if sym\_class of A is CLASS\_BLOCK, sym\_class of B must be CLASS\_BLOCK.

\item offset of A plus the size of A must not be larger than the size of
B.
\end{enumerate}

\item[st\_idx]:
\index{ST\_IDX}%
ST\_IDX of this symbol.
This is used mainly for fast conversion from a pointer to a given
\index{ST}%
ST to the corresponding ST\_IDX.
\end{description}

\subsection{Symbol Class and Storage Class}

There is a symbol class and a storage class associated with each
\index{ST}%
ST
entry, both of which are enumeration types:

\begin{center}
\begin{longtable}{|p{1in}|p{.5in}|p{2.75in}|}
\caption{Symbol Class\label{sym-class}}\\
\hline
Name & Value & Description \endhead\hline\hline
\index{CLASS\_UNK}%
CLASS\_UNK & 0 & uninitialized \\\hline
\index{CLASS\_VAR}%
CLASS\_VAR & 1 & data variable \\\hline
\index{CLASS\_FUNC}%
CLASS\_FUNC & 2 & function \\\hline
\index{CLASS\_CONST}%
CLASS\_CONST & 3 & constant, a
\index{TCON}%
TCON holds the real value \\\hline
\index{CLASS\_PREG}%
CLASS\_PREG & 4 & pseudo register \\\hline
\index{CLASS\_BLOCK}%
CLASS\_BLOCK & 5 & base address for a block of data \\\hline
\index{CLASS\_NAME}%
CLASS\_NAME & 6 & placeholder for a named
\index{ST}%
ST entry\\\hline
\end{longtable}
\end{center}

{\small
\begin{center}
\begin{longtable}{|p{1.5in}|p{.5in}|p{3in}|}
\caption{Storage Class\label{stor-class}}\\
\hline Name & Value & Description \endhead\hline\hline
\index{SCLASS\_UNKNOWN}%
SCLASS\_UNKNOWN & 0 & no specific storage class (e.g., a block of data of mixed storage classes)\\\hline
\index{SCLASS\_AUTO}%
SCLASS\_AUTO & 1 & local stack variable\\\hline 
\index{SCLASS\_FORMAL}%
SCLASS\_FORMAL & 2 & formal parameter \\\hline
\index{SCLASS\_FORMAL\_REF}%
SCLASS\_FORMAL\_REF & 3 & reference parameter\\\hline 
\index{SCLASS\_PSTATIC}%
SCLASS\_PSTATIC & 4 &
\index{PU}%
PU scope static data \\\hline
\index{SCLASS\_FSTATIC}%
SCLASS\_FSTATIC & 5 & file scope static data \\\hline
\index{SCLASS\_COMMON}%
SCLASS\_COMMON & 6 & common block (linker allocated) \\\hline
\index{SCLASS\_EXTERN}%
SCLASS\_EXTERN & 7 & unallocated external data or text \\\hline
\index{SCLASS\_UGLOBAL}%
SCLASS\_UGLOBAL & 8 & uninitialized global data\\\hline
\index{SCLASS\_DGLOBAL}%
SCLASS\_DGLOBAL & 9 & initialized global data \\\hline
\index{SCLASS\_TEXT}%
SCLASS\_TEXT & 10 & executable code \\\hline
SCLASS\_REG & 11 & register variable\\\hline 
\index{SCLASS\_CPLINIT}%
SCLASS\_CPLINIT & 12 & special data object describing initialization of static/global C++ classes.\\\hline
\index{SCLASS\_EH\_REGION}%
SCLASS\_EH\_REGION & 13 & special table describing C++ exception handling (See Section 2.3.6) \\\hline
\index{SCLASS\_EH\_REGION\_SUPP}%
SCLASS\_EH\_REGION\_SUPP & 14 & supplemental data structure for C++ exception handling (See Section 2.3.6)\\\hline
\index{SCLASS\_DISTR\_ARRAY}%
SCLASS\_DISTR\_ARRAY & 15 & data object that is placed in the special Elf section \_MIPS\_distr\_array\\\hline
\index{SCLASS\_COMMENT}%
SCLASS\_COMMENT & 16 & names of such symbols are to be placed in the special Elf section comment.\\\hline
\index{SCLASS\_THREAD\_PRIVATE\_FUNCS}%
SCLASS\_THREAD\_PRIVATE\_FUNCS & 17 & data object that is placed in the special Elf section \_MIPS\_thread\_private\_funcs\\\hline
\end{longtable}
\end{center}
}


Not all combinations of symbol class and storage class are valid. Only
those listed in Table~\ref{classcombos}  are allowed: 

{\small
\begin{center}
\begin{longtable}{|p{1in}|p{2.5in}|p{2.5in}|}
% Table 6 Valid Symbol Class and Storage Class Combinations 
\caption{Valid Symbol Class and Storage Class
  Combinations\label{classcombos}}\\
\hline
Symbol class & Storage class & Description\endhead\hline\hline
\index{CLASS\_UNK}%
CLASS\_UNK &
\index{SCLASS\_UNKNOWN}%
SCLASS\_UNKNOWN &uninitialized \\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_AUTO}%
SCLASS\_AUTO &stack variable \\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_FORMAL}%
SCLASS\_FORMAL &formal parameter\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_FORMAL\_REF}%
SCLASS\_FORMAL\_REF &reference parameter\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_PSTATIC}%
SCLASS\_PSTATIC
\index{PU}%
PU &scope static variable\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_FSTATIC}%
SCLASS\_FSTATIC &file scope variable\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_COMMON}%
SCLASS\_COMMON &common block\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_EXTERN}%
SCLASS\_EXTERN &unallocated external variable\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_UGLOBAL}%
SCLASS\_UGLOBAL &uninitialized global variable\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_DGLOBAL}%
SCLASS\_DGLOBAL &initialized global variable\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_CPLINIT}%
SCLASS\_CPLINIT &special data object describing initialization of static/global C++ classes. \\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_EH\_REGION}%
SCLASS\_EH\_REGION &special table describing C++exception handling\\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_EH\_REGION\_SUPP}%
SCLASS\_EH\_REGION\_SUPP &supplemental data structure for C++ exception handling \\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_DISTR\_ARRAY}%
SCLASS\_DISTR\_ARRAY &data object that is placed in the special Elf section \_MIPS\_distr\_array \\\hline
\index{CLASS\_VAR}%
CLASS\_VAR &
\index{SCLASS\_THREAD\_PRIVATE\_FUNCS}%
SCLASS\_THREAD\_PRIVATE\_FUNCS &data object that is
placed in the special Elf section
 \_MIPS\_thread\_private\_funcs \\\hline
\index{CLASS\_FUNC}%
CLASS\_FUNC &
\index{SCLASS\_EXTERN}%
SCLASS\_EXTERN &undefined function\\\hline
\index{CLASS\_FUNC}%
CLASS\_FUNC &
\index{SCLASS\_TEXT}%
SCLASS\_TEXT &defined function\\\hline
\index{CLASS\_CONST}%
CLASS\_CONST &
\index{SCLASS\_FSTATIC}%
SCLASS\_FSTATIC &constant\\\hline
\index{CLASS\_CONST}%
CLASS\_CONST &
\index{SCLASS\_EXTERN}%
SCLASS\_EXTERN &constant symbol defined in another file (e.g. in
IPA-generated symbol table)\\\hline
\index{CLASS\_PREG}%
CLASS\_PREG & SCLASS\_REG &pseudo register
\index{CLASS\_BLOCK}%
CLASS\_BLOCK all storage
classes except
\index{SCLASS\_UNKNOWN}%
SCLASS\_UNKNOWN and SCLASS\_REG\\\hline
\index{CLASS\_BLOCK}%
CLASS\_BLOCK &
\index{SCLASS\_UNKNOWN}%
SCLASS\_UNKNOWN & a block of data or text of
unspecified storage class (e.g., a block of mixed storage
classes)\\\hline
\index{CLASS\_NAME}%
CLASS\_NAME &
\index{SCLASS\_UNKNOWN}%
SCLASS\_UNKNOWN & an
\index{ST}%
ST entry that only has a name and
nothing else, usually used as a placeholder for special symbols that
are passed to the linker\\\hline
\index{CLASS\_NAME}%
CLASS\_NAME &
\index{SCLASS\_COMMENT}%
SCLASS\_COMMENT &
an
\index{ST}%
ST entry whose name is to be placed in the Elf section .comment
\\\hline
\end{longtable}
\end{center}
}

\subsection{Export Scopes}

This enumeration describes the possible scopes that symbols
exported from a file may map into, i.e., linker globals for
\index{DSO}%
DSO
(dynamically shared object)-related components.

Only an
\index{EXPORT\_LOCAL}%
EXPORT\_LOCAL or
\index{EXPORT\_LOCAL\_INTERNAL}%
EXPORT\_LOCAL\_INTERNAL symbol must be defined
in the file being compiled. All others can be either defined or
undefined. All symbols except
\index{EXPORT\_PREEMTIBLE}%
EXPORT\_PREEMTIBLE must be defined in the
current
\index{DSO}%
DSO or executable.

Only
\index{EXPORT\_LOCAL}%
EXPORT\_LOCAL and
\index{EXPORT\_LOCAL\_INTERNAL}%
EXPORT\_LOCAL\_INTERNAL symbols are allowed in
a local ST\_TAB. Symbols with all other export scopes must be placed in
the global ST\_TAB. Furthermore, the
\index{ST}%
ST entries of all
functions, regardless of export scope, must be placed in the global
ST\_TAB.

%\begin{center}
\begin{longtable}{|p{2in}|p{5ex}|p{3in}|}
%Table 7 Export Scopes 
\caption{Export Scopes\label{export-scopes}}\\
\hline
Export Scope & Value & Description\endhead\hline\hline

\index{EXPORT\_LOCAL}%
EXPORT\_LOCAL & 0 & not exported, must be defined in current file
(e.g. C static data), address can be exported from
\index{DSO}%
DSO using a pointer
\\\hline

\index{EXPORT\_LOCAL\_INTERNAL}%
EXPORT\_LOCAL\_INTERNAL & 1 & not exported, must be defined in
current file, only visible within current file, only used within the
\index{DSO}%
DSO or executable \\\hline

\index{EXPORT\_INTERNAL}%
EXPORT\_INTERNAL & 2 & exported, only visible and used within the
\index{DSO}%
DSO
or executable, must be defined in current
\index{DSO}%
DSO or executable\\\hline

\index{EXPORT\_HIDDEN}%
EXPORT\_HIDDEN & 3 & exported, name is hidden within
\index{DSO}%
DSO or
executable, address can be exported from
\index{DSO}%
DSO using a pointer, must be
defined in current
\index{DSO}%
DSO or executable\\\hline

\index{EXPORT\_PROTECTED}%
EXPORT\_PROTECTED & 4 & exported, non-preemptible, must be defined in
current
\index{DSO}%
DSO or executable\\\hline

\index{EXPORT\_PREEMPTIBLE}%
EXPORT\_PREEMPTIBLE & 5 & exported, preemptible \\\hline

\index{EXPORT\_OPTIONAL}%
EXPORT\_OPTIONAL & 6 & correspond to
\index{STO\_OPTIONAL}%
STO\_OPTIONAL in Elfsymbol table
(see \verb|<sys/elf.h>|)\\\hline

\end{longtable}
%\end{center}


Valid combinations of export scopes and storage classes are listed in
the following table:. 

\begin{table}[h]
\centering
\caption{Valid Combinations of Storage Class and Export Scopes}
{\small
% Table 8 Valid Combinations of Storage Class and Export Scopes 
\begin{tabular}{|p{2in}|p{2in}|p{2in}|}\hline
Storage class & Export scopes & Description \\\hline\hline
\begin{minipage}{2in}
\flushleft
~\\
SCLASS\_UNKNOWN\\ 
SCLASS\_AUTO\\
SCLASS\_FORMAL\\ 
SCLASS\_FORMAL\_REF\\ 
SCLASS\_PSTATIC\\
SCLASS\_FSTATIC\\ 
SCLASS\_CPLINIT\\
\index{SCLASS\_EH\_REGION\\}%
SCLASS\_EH\_REGION\\ 
SCLASS\_EH\_REGION\_SUPP\\
\index{SCLASS\_DISTR\_ARRAY}%
SCLASS\_DISTR\_ARRAY \\
SCLASS\_THREAD\_PRIVATE\_FUNCS\\
SCLASS\_COMMENT\\~
\end{minipage}
&
\begin{minipage}{2in}
\flushleft
EXPORT\_LOCAL\\
\index{EXPORT\_LOCAL\_INTERNAL}%
EXPORT\_LOCAL\_INTERNAL \\
EXPORT\_INTERNAL\\
\index{EXPORT\_HIDDEN}%
EXPORT\_HIDDEN \\
EXPORT\_PROTECTED\\
\index{EXPORT\_PREEMPTIBLE}%
EXPORT\_PREEMPTIBLE
\end{minipage}
&
\index{DSO}%
DSO scope data or text symbols\\\hline

\index{SCLASS\_COMMON}%
SCLASS\_COMMON 
\index{SCLASS\_DGLOBAL}%
SCLASS\_DGLOBAL 
&
\begin{minipage}{2in}
\flushleft
~\\
EXPORT\_LOCAL\\
EXPORT\_LOCAL\_INTERNAL\\~
\end{minipage}
&
member of a common or data block; these symbols
must have base\_idx pointing to an
\index{ST}%
ST entry with the same storage class\\\hline

\index{SCLASS\_EXTERN}%
SCLASS\_EXTERN 
&
\begin{minipage}{2in}
\flushleft
~\\
EXPORT\_LOCAL\\
EXPORT\_LOCAL\_INTERNAL\\~ 
\end{minipage}
&
local symbols that are not defined in the current file;
use in IPA-generated file
where a
\index{CLASS\_CONST}%
CLASS\_CONST symbol is defined in a
separate file. \\\hline

\index{SCLASS\_TEXT}%
SCLASS\_TEXT 
&
\begin{minipage}{2in}
\flushleft
~\\
EXPORT\_LOCAL\\
\index{EXPORT\_LOCAL\_INTERNAL}%
EXPORT\_LOCAL\_INTERNAL \\~
\end{minipage}
&
static functions
\\\hline

\index{SCLASS\_TEXT}%
SCLASS\_TEXT 
&
\begin{minipage}{2in}
\flushleft
~\\
EXPORT\_INTERNAL\\
EXPORT\_HIDDEN\\
EXPORT\_PROTECTED\\ 
EXPORT\_PREEMPTIBLE\\~
\end{minipage}
&
global functions 
\\\hline
SCLASS\_REG 
&
\begin{minipage}{2in}
\flushleft
~\\
EXPORT\_LOCAL\\
EXPORT\_LOCAL\_INTERNAL\\~
\end{minipage}
&
registers\\\hline
\end{tabular}
}
\end{table}

\clearpage
\subsection{ST Flags}

Associated with each
\index{ST}%
ST entry are one or more attributes that
describe specific property of it. Some of them are mutually exclusive
and some of them are related. They are described in the following
table:

\begin{longtable}{|p{2in}|p{4in}|}
\caption{Miscellaneous Attributes of an
\index{ST}%
ST Entry Flag/Value
  Description\label{table9}}\\
\multicolumn{2}{c}{}\\\hline
Symbol & Description\endhead\hline\hline
\index{ST\_IS\_WEAK\_SYMBOL}%
ST\_IS\_WEAK\_SYMBOL 0x00000001  & 
\begin{minipage}{4in}
\flushleft
weak name
\begin{itemize}
\item not valid for
\index{EXPORT\_LOCAL}%
EXPORT\_LOCAL or
\index{EXPORT\_LOCAL\_INTERNAL}%
EXPORT\_LOCAL\_INTERNAL
\item see Section 2.3.7 for semantics of weak symbols
\end{itemize}
~
\end{minipage}\\\hline
\index{ST\_IS\_SPLIT\_COMMON}%
ST\_IS\_SPLIT\_COMMON 0x00000002 &
\begin{minipage}{4in}
\flushleft
part of a split common
\begin{itemize}
\item base\_idx gives the
\index{ST\_IDX}%
ST\_IDX of the corresponding complete common definition

\item
\index{ST\_IS\_WEAK\_SYMBOL}%
ST\_IS\_WEAK\_SYMBOL must not be set ST\_IS\_NOT\_USED0x00000004 symbol is not referenced
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_INITIALIZED}%
ST\_IS\_INITIALIZED 0x00000008 & 
\begin{minipage}{4in}
\flushleft
initialized static or global variable
\begin{itemize}
\item only valid for CLASS\_VAR, CLASS\_CONST, and
\index{CLASS\_BLOCK}%
CLASS\_BLOCK
\item only valid for SCLASS\_PSTATIC, SCLASS\_FSTATIC, SCLASS\_EXTERN,
  SCLASS\_DGLOBAL, SCLASS\_UGLOBAL, SCLASS\_CPLINIT,
  SCLASS\_EH\_REGION, SCLASS\_EH\_RGION\_SUPP, SCLASS\_DIST\_ARRAY,
  and SCLASS\_THREAD\_PRIVATE\_FUNCS.
\item also valid for
\index{SCLASS\_UNKNOWN}%
SCLASS\_UNKNOWN if symbol class is
\index{CLASS\_BLOCK}%
CLASS\_BLOCK
\item for SCLASS\_UGLOBAL,
\index{ST\_INIT\_VALUE\_ZERO}%
ST\_INIT\_VALUE\_ZERO must be
  set(uninitialized globals and globals explicitly initialized to zero
  are equivalent)
\item must be set for
\index{SCLASS\_DGLOBAL}%
SCLASS\_DGLOBAL
\item for CLASS\_VAR, if
\index{ST\_INIT\_VALUE\_ZERO}%
ST\_INIT\_VALUE\_ZERO is not set, there must
be a corresponding
\index{INITO}%
INITO entry
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_RETURN\_VAR}%
ST\_IS\_RETURN\_VAR 0x00000010 & 
\begin{minipage}{4in}
\flushleft
return value for Fortran function
\begin{itemize}
\item only valid for
\index{SCLASS\_AUTO}%
SCLASS\_AUTO
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_VALUE\_PARM}%
ST\_IS\_VALUE\_PARM 0x00000020 & 
\begin{minipage}{4in}
\flushleft
parameter is passed by value
\begin{itemize}
\item only valid for
\index{SCLASS\_FORMAL}%
SCLASS\_FORMAL
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_PROMOTE\_PARM}%
ST\_PROMOTE\_PARM 0x00000040 &
\begin{minipage}{4in}
\flushleft
parameter has been promoted from chars/short to int or from
float to double
\begin{itemize}
\item only valid for C/C++
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_KEEP\_NAME\_W2F}%
ST\_KEEP\_NAME\_W2F 0x00000080 &
\begin{minipage}{4in}
\flushleft
whirl2f should neither declare nor rename this symbol
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_DATAPOOL}%
ST\_IS\_DATAPOOL 0x00000100 & Fortran data pools \\\hline

\index{ST\_IS\_RESHAPED}%
ST\_IS\_RESHAPED 0x00000200 & 
symbol has a distribute\_reshape pragma supplied for it; only valid for
CLASS\_VAR\\\hline

\index{ST\_EMIT\_SYMBOL}%
ST\_EMIT\_SYMBOL 0x00000400 &
\begin{minipage}{4in}
\flushleft
must appear in the symbol table of the Elf object file
\begin{itemize}
\item only valid for CLASS\_VAR, CLASS\_NAME, and CLASS\_FUNC,
\item used by C++ to force certain local symbols to be written 
out to the Elf object file 
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_HAS\_NESTED\_REF}%
ST\_HAS\_NESTED\_REF 0x00000800 & 
\begin{minipage}{4in}
\flushleft
symbol is referenced by a
\index{PU}%
PU nested in the current
\index{PU}%
PU
\begin{itemize}
\item  only valid for SCLASS\_AUTO, SCLASS\_PSTATIC, SCLASS\_FORMAL, and SCLASS\_FORMAL\_REF.
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_INIT\_VALUE\_ZERO}%
ST\_INIT\_VALUE\_ZERO 0x00001000 &
\begin{minipage}{4in}
\flushleft
uninitialized global or static symbol
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\item  only valid for
SCLASS\_EXTERN, SCLASS\_UGLOBAL, SCLASS\_FSTATIC, and
\index{SCLASS\_PSTATIC}%
SCLASS\_PSTATIC
\item
\index{ST\_IS\_INITIALIZED}%
ST\_IS\_INITIALIZED must be set
\item also valid for symbol explicitly initialized to zero
\end{itemize}
~
\end{minipage}\\\hline


\index{ST\_GPREL}%
ST\_GPREL 0x00002000 & 
\begin{minipage}{4in}
\flushleft
can be accessed via an offset from the global pointer
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR and
\index{CLASS\_CONST}%
CLASS\_CONST
\item not valid for SCLASS\_AUTO, SCLASS\_FORMAL, and
\index{SCLASS\_FORMAL\_REF}%
SCLASS\_FORMAL\_REF
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_NOT\_GPREL}%
ST\_NOT\_GPREL 0x00004000 & 
\begin{minipage}{4in}
\flushleft
can not be accessed via an offset from the global pointer
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR and
\index{CLASS\_CONST}%
CLASS\_CONST
\item not valid for SCLASS\_AUTO, SCLASS\_FORMAL, and
\index{SCLASS\_FORMAL\_REF}%
SCLASS\_FORMAL\_REF
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_NAMELIST}%
ST\_IS\_NAMELIST 0x00008000 & 
\begin{minipage}{4in}
\flushleft
special symbol for namelists 
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\item used by whirl2f to identify namelist symbols
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_F90\_TARGET}%
ST\_IS\_F90\_TARGET 0x00010000 & 
\begin{minipage}{4in}
\flushleft
symbol may be accessed by dereferencing an F90 pointer 
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\item if not set, no direct load or store to this symbol can alias
  with any load or store through an F90 pointer
\item if not set, no indirect load or store through an F90 pointer can
  access this item
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_DECLARED\_STATIC}%
ST\_DECLARED\_STATIC  0x00020000 &
\begin{minipage}{4in}
\flushleft
VMS formals declared static
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_EQUIVALENCED}%
ST\_IS\_EQUIVALENCED  0x00040000 & 
\begin{minipage}{4in}
\flushleft
part of an Fortran equivalence
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_FILL\_ALIGN}%
ST\_IS\_FILL\_ALIGN  0x00080000 & 
\begin{minipage}{4in}
\flushleft
symbol has a fill\_symbol or align\_symbol pragma supplied
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_OPTIONAL\_ARGUMENT}%
ST\_IS\_OPTIONAL\_ARGUMENT  0x00100000 & 
\begin{minipage}{4in}
\flushleft
formal parameter is optional
\begin{itemize}
\item only valid for
\index{SCLASS\_FORMAL}%
SCLASS\_FORMAL and
\index{SCLASS\_FORMAL\_REF}%
SCLASS\_FORMAL\_REF
\item it is illegal to speculate loads/stores of this symbol
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_PT\_TO\_UNIQUE\_MEM}%
ST\_PT\_TO\_UNIQUE\_MEM  0x00200000 &
\begin{minipage}{4in}
\flushleft
memory location pointed to by this symbol cannot be accessed via any other way
\begin{itemize}
\item only valid for
\index{SCLASS\_VAR}%
SCLASS\_VAR
\item only valid for pointer, or non-scalar type that contains pointers
\item only valid for compiler-generated symbols 
\item for non-scalar type, such as a struct that contains a pointer or
  an array of pointers, this flag applies to all pointers within the
  structure
\item a pointer with this bit set refers to a memory location that is
  never accessed indirectly via any other pointer or directly via any
  local or global variable in the entire program
\item the compiler phase that sets this bit must guarantee that
  the above property holds even through inlining or other code motion
\item copying such pointers to another pointers is allowed, as long as
\item these other pointers are never dereferenced 
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_TEMP\_VAR}%
ST\_IS\_TEMP\_VAR 0x00400000 &
\begin{minipage}{4in}
\flushleft
compiler generated temporary variable or formal parameters
\begin{itemize}
\item only valid for SCLASS\_AUTO, SCLASS\_FORMAL, and
\index{SCLASS\_FORMAL\_REF}%
SCLASS\_FORMAL\_REF
\end{itemize}
~
\end{minipage}\\\hline
\index{ST\_IS\_CONST\_VAR}%
ST\_IS\_CONST\_VAR  0x00800000 & 
\begin{minipage}{4in}
\flushleft
read-only static or global variable 
\begin{itemize}
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\item  not valid for SCLASS\_AUTO, SCLASS\_FORMAL, and
\index{SCLASS\_FORMAL\_REF}%
 SCLASS\_FORMAL\_REF
\item  compiler can allocate this symbol in read-only data segment
\end{itemize}
~
\end{minipage}\\\hline
\index{ST\_ADDR\_SAVED}%
ST\_ADDR\_SAVED 0x01000000 & 
\begin{minipage}{3.5in}
the address of this symbol is saved to
another variable
\begin{itemize}
\item not valid for SCLASS\_REG
\end{itemize}
~
\end{minipage}\\\hline
\index{ST\_ADDR\_PASSED}%
ST\_ADDR\_PASSED 0x02000000 & 
\begin{minipage}{3.5in}
the address of this symbol is passed to
another
\index{PU}%
PU as actual parameter
\begin{itemize}

\item not valid for SCLASS\_REG
\item this flag is now re-computed by the compiler backend and
is not set by the frontend 
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_THREAD\_PRIVATE}%
ST\_IS\_THREAD\_PRIVATE 0x04000000 & 
\begin{minipage}{3.5in}
symbol is a private data object
of an MP program
\begin{itemize}

\item storage of this symbol is not shared by the threads of an MP program
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_PT\_TO\_COMPILER\_GENERATED\_MEM}%
ST\_PT\_TO\_COMPILER\_GENERATED\_MEM 0x08000000 & 
\begin{minipage}{3.5in}
symbol is a pointer
to compiler-allocated memory space
\begin{itemize}
\item only valid for pointer type

\item only valid for compiler-generated symbols
\item pragmas or other data object attributes specified by users do
not apply to this memory location because it is not visible to them
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_IS\_SHARED\_AUTO}%
ST\_IS\_SHARED\_AUTO 0x10000000 & 
\begin{minipage}{3.5in}
an automatic variable that is accessed within a parallel region and has
shared scope
\begin{itemize}

\item only valid for
\index{SCLASS\_AUTO}%
SCLASS\_AUTO
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_ASSIGNED\_TO\_DEDICATED\_PREG}%
ST\_ASSIGNED\_TO\_DEDICATED\_PREG 0x20000000 &
\begin{minipage}{3.5in}
symbol is associated to a
dedicated (hardware) register
\begin{itemize}
\item compiler should always keep this symbol's value in the specified register
\item only valid for
\index{CLASS\_VAR}%
CLASS\_VAR
\item must be volatile type
\end{itemize}
~
\end{minipage}\\\hline

\index{ST\_ASM\_FUNCTION\_ST}%
ST\_ASM\_FUNCTION\_ST 0x40000000 & 
\begin{minipage}{3.5in}
\flushleft
name of this symbol is an assembly language code corresponding to a
program unit
\begin{itemize}
\item only valid for symbols in the global symbol table
\item only valid for CLASS\_NAME,
\index{SCLASS\_UNKNOWN}%
SCLASS\_UNKNOWN
\item only valid for
\index{EXPORT\_LOCAL}%
EXPORT\_LOCAL
\item not valid for nested
\index{PU}%
PU
\item must have valid PU\_IDX, and the corresponding
\index{PU}%
PU entry must have
\index{PU\_NO\_DELETE}%
PU\_NO\_DELETE and
\index{PU\_NO\_INLINE}%
PU\_NO\_INLINE bits set, with a 0 TY\_IDX.
\end{itemize}
~
\end{minipage}\\\hline
\end{longtable}

\subsection{Exception Handling Region}



Symbols of storage class
\index{SCLASS\_EH\_REGION}%
SCLASS\_EH\_REGION are allocated by the code
generator for the tables that control exception-handling. These tables
are allocated in a special section created by the linker; they never
correspond directly to program entities. They have no existence before
code generation, so they are never referred to in the WHIRL. Symbols
of storage class
\index{SCLASS\_EH\_REGION\_SUPP}%
SCLASS\_EH\_REGION\_SUPP represent initialized
variables created by the frontend to provide supplementary information
about exception-handling actions to be taken by the exception-handling
runtimes when an exception is thrown. They are allocated in a second
special section created by the linker. They appear in the
ereg\_suppfield of the WHIRL, but only the exception-handling part of
the code generator should ever look at them.

The data in the sections corresponding to the storage class
\index{SCLASS\_EH\_REGION}%
SCLASS\_EH\_REGION and the storage class
\index{SCLASS\_EH\_REGION\_SUPP}%
SCLASS\_EH\_REGION\_SUPP
should be readonly by the exception-handling runtimes and should never
be modified once it is generated. Symbols of storage class
\index{SCLASS\_EH\_REGION}%
SCLASS\_EH\_REGION or
\index{SCLASS\_EH\_REGION\_SUPP}%
SCLASS\_EH\_REGION\_SUPP have a very unique
semantic with respect to storage and scope. They are local to the
\index{PU}%
PU in
terms of scope, meaning that they can only be referenced from within
the defining PU. Their storage is not allocated form the stack, but
from the global storage area.

Hence, multiple instances of the same
\index{PU}%
PU (e.g., recursive calls) share
the same memory locations and values of these symbols. However, they
differ from
\index{SCLASS\_PSTATIC}%
SCLASS\_PSTATIC symbols in that when the defining
\index{PU}%
PU
is cloned or inlined, new copies of these symbols need to be created.

\subsection{Semantics of Weak Symbols}

The semantics of a weak symbol depends on its storage\_class and
base\_idx, which is summarized in the following table:

\begin{table}[h]
\centering
\caption{Semantics of Weak Symbols}
\label{table10} 
\begin{tabular}{|l|p{2in}|p{2in}|}\hline
storage\_class & base\_idx != st\_idx & base\_idx == st\_idx\\\hline\hline
\vbox to 1in{
\vbox to 1in{
\vfil
\hbox{SCLASS\_TEXT}
\vfil
\hbox{SCLASS\_UGLOBAL}
\vfil
\hbox{SCLASS\_DGLOBAL}
\vfil
}
}
&
weak symbol that has storage allocated (See note 1)  &
weak definition before data layout (See note 2) \\\hline

\index{SCLASS\_EXTERN}%
SCLASS\_EXTERN & weak symbol with an alias to a strong definition (See
note 3) &  undefined weak symbol (See note 4) \\\hline
\end{tabular}
\end{table}

\begin{enumerate}
\item This refers to defined variables or functions that are marked
weak. After layout, they can be based on other symbols. The weak flag
means that they can be preempted by a strong definition. When they are
preempted, their associated storage is either wasted or can be deleted.

\item Similar to (1), with the exception that storage of this symbol
has not been laid out. Basically, treat (1) and (2) as regular variable
or function definitions, with the exception that they might be
preempted by a strong definition. Once preempted, they corresponding
storage cannot be referenced via this symbol name.

\item This is a weak alias to a strong definition. The name of this
symbol is bound with the storage owned by the corresponding strong
definition (specified by base\_idx). The weak attribute makes this
binding preemptible.

\item This symbol has no storage of its own and is not associated with
any other symbol. The linker should not complain when no definition can
be found, and should assign 0 as its address.
\end{enumerate}

\section{PU\_TAB}

Each entry of this table gives information about each
\index{PU}%
PU that appears
in the source file either as procedure declaration or function
prototype. The index to this table, PU\_IDX, can be used as a
\index{PU}%
PU
identifier. The
\index{PU}%
PU entry has the following structure, size 24 bytes:


\begin{table}[h]
\centering
\caption{Layout of PU} 
\label{table11} 
\begin{tabular}{|l|l|l|l|}\hline
Offset &Field &Description &Field size\\\hline\hline
byte 0 &target\_idx &TARGET\_INFO\_IDX to the target-specific info. &1
word \\\hline

byte 4 &prototype &TY\_IDX to give the prototype type information &1 word \\\hline
byte 8 & lexical\_level &lexical level (scope) of symbols in this
\index{PU}%
PU &1
byte \\\hline
byte 9 &gp\_group &gp-group number of this
\index{PU}%
PU &1 byte \\\hline
byte 10 &src\_lang &source language of this
\index{PU}%
PU &1 byte\\\hline
byte 11 &unused& unused, must be filled with zeros. &5 bytes \\\hline
byte 16 &flags &flags associated with this function prototype &2 words\\\hline
\end{tabular}
\end{table}

\begin{description}

\item[target\_idx]: Index to TARGET\_INFO\_TAB, which contains the
target-specific information about this
\index{PU}%
PU such as register usage
information, etc. The
\index{TARGET\_INFO\_TAB}%
TARGET\_INFO\_TAB is current undefined and is
  reserved for future expansion. In the current release, target\_idx
  must be zero.

\item[prototype:] The
\index{TY\_IDX}%
TY\_IDX for the type of the function.
\item[lexical\_level:] Lexical level of symbols defined in this
\index{PU}%
PU
(i.e. index to the
\index{SCOPE}%
SCOPE array, see Section 2.2). It is always
  greater than 1.

\item[gp\_group]: Gp-group id for this PU; used in multi-got program.
Single
\index{GOT}%
GOT programs have gp\_group zero.

\item[src\_lang]: Source language of this PU, see Table~\ref{table13}. 
\item[unused:] For alignment of flags, must be filled with zeros. 
\item[flags:] Miscellaneous attributes, see Table~\ref{table12}. 
\end{description}


\begin{longtable}{|p{2in}|p{1in}|p{3in}|}
%\multicolumn{3}{c}{Table~\ref{table12}: 
\caption{Miscellaneous Attributes of a PU\label{table12}}\\
\hline
Entry & Flag/Value & Description\endhead\hline\hline
\index{PU\_IS\_PURE}%
PU\_IS\_PURE & 0x00000001 & 
\begin{minipage}{3in}
pure function
\begin{itemize}
 \item does not modify the global state

\item does not make reference to the global state 
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_NO\_SIDE\_EFFECTS}%
PU\_NO\_SIDE\_EFFECTS & 0x00000002 & does not modify the global
state\\\hline

\index{PU\_IS\_INLINE\_FUNCTION}%
PU\_IS\_INLINE\_FUNCTION & 0x00000004 & 
\begin{minipage}{3in}
inline keyword specified
\begin{itemize}
\item function may be inlined
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_NO\_INLINE}%
PU\_NO\_INLINE & 0x00000008 & 
\begin{minipage}{3in}
function must not be inlined
\begin{itemize}
\item mutually exclusive with
\index{PU\_MUST\_INLINE}%
PU\_MUST\_INLINE
\end{itemize}
~
\end{minipage}\\\hline

\index{PU\_MUST\_INLINE}%
PU\_MUST\_INLINE & 0x00000010 & 
\begin{minipage}{3in}
function must be inlined
\begin{itemize}
\item mutually exclusive with
\index{PU\_NO\_INLINE}%
PU\_NO\_INLINE
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_NO\_DELETE}%
PU\_NO\_DELETE & 0x00000020 & function must never be deleted\\\hline

\index{PU\_HAS\_EXC\_SCOPES}%
PU\_HAS\_EXC\_SCOPES & 0x00000040 & 
\begin{minipage}{3in}
has C++ exception handling region,
or would have if exceptions were enabled.
\begin{itemize}
\item
\index{PU\_CXX\_LANG}%
PU\_CXX\_LANG must be set
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_IS\_NESTED\_FUNC}%
PU\_IS\_NESTED\_FUNC & 0x00000080 &
\begin{minipage}{3in}
a nested function
\begin{itemize}
\item lexical\_level must be larger than 2
\end{itemize}
~
\end{minipage}\\\hline

\index{PU\_HAS\_NON\_MANGLED\_CALL}%
PU\_HAS\_NON\_MANGLED\_CALL & 0x00000100 & 
\begin{minipage}{3in}
function is called with
non-reshaped array as actual parameter
\begin{itemize}

\item must keep a copy of the function with non-mangled name
\end{itemize}
~
\end{minipage}\\\hline

\index{PU\_ARGS\_ALIASED}%
PU\_ARGS\_ALIASED & 0x00000200 & 
\begin{minipage}{3in}
parameters might point to same or overlapping memory location
\begin{itemize}

\item
\index{PU\_F77\_LANG}%
PU\_F77\_LANG or
\index{PU\_F90\_LANG}%
PU\_F90\_LANG must be set
\index{PU\_NEEDS\_FILL\_ALIGN\_LOWERING}%
PU\_NEEDS\_FILL\_ALIGN\_LOWERING 0x00000400 contains symbols that have the fill\_symbol or
align\_symbol pragma specified
\end{itemize}
~
\end{minipage}\\\hline

\index{PU\_NEEDS\_T9}%
PU\_NEEDS\_T9  & 0x00000800 & register \$t9 must contain the lowest
address of the PU\\\hline
\index{PU\_HAS\_VERY\_HIGH\_WHIRL}%
PU\_HAS\_VERY\_HIGH\_WHIRL & 0x00001000 &
\index{PU}%
PU has very high WHIRL\\\hline
\index{PU\_HAS\_ALTENTRY}%
PU\_HAS\_ALTENTRY  & 0x00002000 & 
\begin{minipage}{3in}
\index{PU}%
PU contains alternate entry points
\begin{itemize}
\item
\index{PU\_F77\_LANG}%
PU\_F77\_LANG or
\index{PU\_F90\_LANG}%
PU\_F90\_LANG must be set
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_RECURSIVE}%
PU\_RECURSIVE & 0x00004000 &
\index{PU}%
PU is self-recursive, or is part of a
multi-function recursion\\\hline
\index{PU\_IS\_MAINPU}%
PU\_IS\_MAINPU & 0x00008000 & main entry point of a program\\\hline 
\index{PU\_UPLEVEL}%
PU\_UPLEVEL & 0x00010000 & other
\index{PU}%
PU nested in this one \\\hline
\index{PU\_MP\_NEEDS\_LNO}%
PU\_MP\_NEEDS\_LNO & 0x00020000 & must invoke
\index{LNO}%
LNO on this PU, regardless
of compilation options\\\hline
\index{PU\_HAS\_ALLOCA}%
PU\_HAS\_ALLOCA & 0x00040000 & contains calls to alloca \\\hline
\index{PU\_IN\_ELF\_SECTION}%
PU\_IN\_ELF\_SECTION & 0x00080000 & the code generator must put this
\index{PU}%
PU
in its own Elfsection\\\hline
\index{PU\_HAS\_MP}%
PU\_HAS\_MP & 0x00100000 & contains a MP construct \\\hline
\index{PU\_MP}%
PU\_MP & 0x00200000 & a
\index{PU}%
PU created by the MP lowerer \\\hline
\index{PU\_HAS\_NAMELIST}%
PU\_HAS\_NAMELIST & 0x00400000 &
\begin{minipage}{3in}
has namelist declaration
\begin{itemize}
\item
\index{PU\_F77\_LANG}%
PU\_F77\_LANG or
\index{PU\_F90\_LANG}%
PU\_F90\_LANG must be set
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_HAS\_RETURN\_ADDRESS}%
PU\_HAS\_RETURN\_ADDRESS & 0x00800000 & contain references to the special symbol
\_\_return\_address\\\hline
\index{PU\_HAS\_REGION}%
PU\_HAS\_REGION & 0x01000000 &
\index{PU}%
PU has regions in it \\\hline
\index{PU\_HAS\_INLINES}%
PU\_HAS\_INLINES & 0x02000000 &
\index{PU}%
PU has inlined code in it\\\hline
\index{PU\_CALLS\_SETJMP}%
PU\_CALLS\_SETJMP & 0x04000000 &
\index{PU}%
PU contains calls to setjmp.\\\hline
\index{PU\_CALLS\_LONGJMP}%
PU\_CALLS\_LONGJMP & 0x08000000 &
\index{PU}%
PU contains calls to longjmp.\\\hline
\index{PU\_IPA\_ADDR\_ANALYSIS}%
PU\_IPA\_ADDR\_ANALYSIS & 0x10000000 & 
\begin{minipage}{3in}
the
\index{ST\_ADDR\_SAVED}%
ST\_ADDR\_SAVED bits for all symbols referenced in this
\index{PU}%
 PU are set by IPA's address analysis
\begin{itemize}
\item the compiler backend should trust the (more
accurate) results of
\index{IPA}%
IPA and need not recompute the
\index{ST\_ADDR\_SAVED}%
ST\_ADDR\_SAVED bits for this
\index{PU}%
PU
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_SMART\_ADDR\_ANALYSIS}%
PU\_SMART\_ADDR\_ANALYSIS & 0x20000000 & 
\begin{minipage}{3in}
suppress the conservative address-taken validation
\begin{itemize}

\item do not perform conservative address-taken verification, which
might set the
\index{ST\_ADDR\_SAVED}%
ST\_ADDR\_SAVED bit unnecessarily

\item set when more accurately address analysis has been performed.
\end{itemize}
~
\end{minipage}\\\hline

& 0x40000000 & obsolete \\
\index{PU\_HAS\_GLOBAL\_PRAGMAS}%
PU\_HAS\_GLOBAL\_PRAGMAS & 0x80000000 & 
\begin{minipage}{3in}
a dummy
\index{PU}%
PU that contains global pragmas
\begin{itemize}

\item a place holder for all global scope pragmas
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_HAS\_USER\_ALLOCA}%
PU\_HAS\_USER\_ALLOCA & 0x100000000 & 
\begin{minipage}{3in}
\index{PU}%
PU contains user-specified call to alloca()
\begin{itemize}
\item if this pu is inlined, an explicitly deallocation
needs to be generated 
\end{itemize}
~
\end{minipage}\\\hline
{\footnotesize PU\_HAS\_UNKNOWN\_CONTROL\_FLOW} & 0x200000000 & 
\begin{minipage}{3in}
\index{PU}%
PU has control flow going in or out of the puscope that do not
following calling convention
\begin{itemize}
\item tail-call optimization should be disabled
\end{itemize}
~
\end{minipage}\\\hline
\end{longtable}
Each entry of this table is a TY. Any high level type in the program
is uniquely identified by a value of type TY\_IDX.


\begin{table}[h]
\centering
\caption{Source Language of a PU}
\label{table13} 
\begin{tabular}{|p{2in}|l|p{3in}|}\hline
Flag & Value & Description\\\hline\hline
\index{PU\_UNKNOWN\_LANG}%
PU\_UNKNOWN\_LANG & 0x00 & Source language unknown \\\hline
\index{PU\_MIXED\_LANG}%
PU\_MIXED\_LANG & 0x01 &
\begin{minipage}{4in}
\index{PU}%
PU contains code from multiple source languages
\begin{itemize}
\item resulted from cross-file inlining 
\end{itemize}
~
\end{minipage}\\\hline
\index{PU\_C\_LANG}%
PU\_C\_LANG & 0x02 & Source language is C \\\hline
\index{PU\_CXX\_LANG}%
PU\_CXX\_LANG & 0x04 & Source language is C++ \\\hline
\index{PU\_F77\_LANG}%
PU\_F77\_LANG & 0x08 & Source language is Fortran 77 \\\hline
\index{PU\_F90\_LANG}%
PU\_F90\_LANG & 0x10 & Source language is Fortran 90 \\\hline
\index{PU\_JAVA\_LANG}%
PU\_JAVA\_LANG & 0x20 & Source language is Java \\\hline
\end{tabular}
\end{table}

\subsection{TY\_IDX}

\index{TY\_IDX}%
TY\_IDX is of size 32 bits, and is composed of two parts. 
The high order 24 bits is the index to TY\_TAB. The low order 8 bits contains
information that qualifies the type. Among the low order 8 bits is the
alignment information. The actual alignment is given by
$2^{align}$. 

\begin{table}[h]
\centering
\caption{Layout of TY\_IDX.\protect\footnotemark}
\label{Table_14} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description &Field size\\\hline 
bit 0 & align & alignment & 5 bits\\\hline 
bit 5 & const & const type qualifier & 1 bit \\\hline
bit 6 & volatile & volatile type qualifier & 1 bit\\\hline
bit 7 & restrict & restrict type qualifier & 1 bit \\\hline
bit 8 & index & index to
\index{TY\_TAB}%
TY\_TAB & 24 bits\\\hline
\end{tabular}
\end{table}

\footnotetext{Bit offsets assume big Endian bit ordering. For example,
  the index field is always the most significant 24 bits, regardless
  of the Endianess of the machine.}

\section{TY\_TAB}


\index{TY\_IDX}%
TY\_IDX appears appear in many different places:

\begin{enumerate}

\item in WHIRL nodes that access data objects. 
\item in
\index{ST}%
ST entries.
\item in components for type specification: TY, FLD, TYLIST.
\end{enumerate}

Each
\index{TY}%
TY has a natural (and maximum) alignment, which can be determined
by analysis of the details of the type. Thus, we omit the natural
alignment information from the TY. The alignment of a
\index{TY}%
TY directly
affects the alignment in the
\index{TY\_IDX}%
TY\_IDX of an object that encloses or
refers to it, unless the object's own alignment is modified by pragmas
or type casts. An
optimization phase may also improve the alignment of an object by
forcing better placement during data layout, in which case it only
needs to fix up the alignment of the ST's TY\_IDX. Whenever the
alignment in the
\index{TY\_IDX}%
TY\_IDX of the WHIRL node and the
\index{TY\_IDX}%
TY\_IDX of the
\index{ST}%
ST
being accessed by the
WHIRL node do not agree, code generation picks the more
efficient(better) alignment of the two. Thus, if a phase worsens the
alignment of an object, it has to fix the
\index{TY\_IDX}%
TY\_IDX in all the WHIRL
references to it, which is normally impossible.

The above rule dealing with alignment also applies to the other type
qualifying bits: whenever a type qualifying bit is different between
the
\index{TY\_IDX}%
TY\_IDX of the WHIRL node and the
\index{TY\_IDX}%
TY\_IDX of the
\index{ST}%
ST being accessed
by the WHIRL node, code generation picks the more efficient of the two.

\subsection{TY entry}

The
\index{TY}%
TY entry has the following structure, size 24 bytes:


\begin{table}[h]
\centering
\caption{Layout of TY} 
\label{Table_15} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size\\\hline\hline 
byte 0 & size & size of the type in bytes & 2 words \\\hline
byte 8 & kind & kind of type & 1 byte \\\hline
byte 9 & mtype & corresponding WHIRL data type & 1 byte \\\hline
byte 10 & flags &
\index{TY}%
TY flags & 2 bytes \\\hline
byte 12 & fld &
\index{FLD\_IDX}%
FLD\_IDX for struct/class field information & 1 word \\\hline
byte 12 & tylist &
\index{TYLIST\_IDX}%
TYLIST\_IDX for function prototype & 1 word \\\hline
byte 12 & arb &
\index{ARB\_IDX}%
ARB\_IDX for array bound description & 1 word \\\hline
byte 16 & name\_idx &
\index{STR\_IDX}%
STR\_IDX to the name string & 1 word \\\hline
byte 20 & etype &
\index{TY\_IDX}%
TY\_IDX of array element (array only) & 1 word \\\hline
byte 20 & pointed &
\index{TY\_IDX}%
TY\_IDX of the pointed-to type (pointers only) & 1 word \\\hline
byte 20 & pu\_flags & function-specific attributes & 1 word\\\hline
\end{tabular}
\end{table}

\begin{description}
\item[size]: The size of the type in bytes. For
\index{KIND\_FUNCTION}%
KIND\_FUNCTION and
KIND\_VOID, the size is zero. For KIND\_ARRAY, this is the size of the
entire array, except when for variable length arrays, the size is
zero. 

\item[kind]: Field describing if the type is a scalar, structure,
  etc. See Table~\ref{table16}.

\begin{table}[h]
\centering
\caption{Kinds of TY} 
\label{table16} 
\begin{tabular}{|l|l|p{3in}|}\hline
Name & Value & Description\\\hline\hline
\index{KIND\_INVALID}%
KIND\_INVALID & 0 & invalid or uninitialized\\\hline
\index{KIND\_SCALAR}%
KIND\_SCALAR & 1 & integer or floating point, no kids \\\hline
\index{KIND\_ARRAY}%
KIND\_ARRAY & 2 & array, arb\_idx points to array bound description,
etype gives the type of the array element\\\hline
\index{KIND\_STRUCT}%
KIND\_STRUCT & 3 & structure or union, fld\_idx points to the field
description\\\hline 
\index{KIND\_POINTER}%
KIND\_POINTER & 4 & pointers, pointed gives the type that
it points to \\\hline
\index{KIND\_FUNCTION}%
KIND\_FUNCTION & 5 & function or procedure, tylist\_idx points to the list of
\index{TY\_IDX}%
TY\_IDX for the return type and parameter types.\\\hline
\index{KIND\_VOID}%
KIND\_VOID & 6 & C void type, no kids\\\hline
\end{tabular}
\end{table}

\item[mtype]: WHIRL data type, see Table~\ref{table17}. See
  Table~\ref{table20} for valid combinations of mtype and kind.


\begin{table}[h]
\centering
\caption{WHIRL Basic Data Type} 
\label{table17}
\begin{tabular}{|l|l|l|}\hline
Flag & Value & Description\\\hline\hline
\index{MTYPE\_FQ}%
MTYPE\_FQ & 15 & SGI long double\\\hline
\index{MTYPE\_M}%
MTYPE\_M & 16 & memory chunk, for structures \\\hline
\index{MTYPE\_C4}%
MTYPE\_C4 & 17 & 32-bit complex \\\hline
\index{MTYPE\_C8}%
MTYPE\_C8 & 18 & 64-bit complex \\\hline
\index{MTYPE\_CQ}%
MTYPE\_CQ & 19 & 128-bit complex\\\hline 
\index{MTYPE\_V}%
MTYPE\_V & 20 & void type \\\hline
\index{MTYPE\_BS}%
MTYPE\_BS & 21 & bits \\\hline
\index{MTYPE\_A4}%
MTYPE\_A4 & 22 & 32-bit address \\\hline
\index{MTYPE\_A8}%
MTYPE\_A8 & 23 & 64-bit address \\\hline
\index{MTYPE\_C10}%
MTYPE\_C10 & 24 & 80-bit IEEE complex \\\hline
\index{MTYPE\_C16}%
MTYPE\_C16 & 25 & 128-bit IEEE complex\\\hline 
\index{MTYPE\_I16}%
MTYPE\_I16 & 26 & 128-bit signed integer \\\hline
\index{MTYPE\_U16}%
MTYPE\_U16 & 27 & 128-bit unsigned integer\\\hline
\end{tabular}
\end{table} 

\item[flags]: Miscellaneous attributes, see Table~\ref{table18}. 


\begin{table}[h]
\centering
\caption{Miscellaneous Attributes of a TY} 
\label{table18}
\begin{tabular}{|l|l|l|}\hline
Entry & Flag/Value & Description \\\hline\hline
\index{TY\_IS\_CHARACTER}%
TY\_IS\_CHARACTER & 0x0001 & Fortran character type\\\hline
\index{TY\_IS\_LOGICAL}%
TY\_IS\_LOGICAL & 0x0002 & Fortran logical type\\\hline
\index{TY\_IS\_UNION}%
TY\_IS\_UNION & 0x0004 & type is a union; only valid for KIND\_STRUCT\\\hline
\index{TY\_IS\_PACKED}%
TY\_IS\_PACKED & 0x0008 & struct or class is packed\\\hline
\index{TY\_PTR\_AS\_ARRAY}%
TY\_PTR\_AS\_ARRAY & 0x0010 & treat pointer as array 
(used by whirl2c/whirl2f)\\\hline 
\index{TY\_ANONYMOUS}%
 TY\_ANONYMOUS & 0x0020 & anonymous struct/class/union; only valid for
 KIND\_STRUCT\\\hline

\index{TY\_SPLIT}%
TY\_SPLIT & 0x0040 & split from a larger common block\\\hline
\index{TY\_IS\_F90\_POINTER}%
TY\_IS\_F90\_POINTER & 0x0080 & pointer is subject to F90 alias rules \\\hline
\index{TY\_NOT\_IN\_UNION}%
TY\_NOT\_IN\_UNION & 0x0100 & type cannot be part of a union\\\hline
\end{tabular}
\end{table}

\item[fld/tylist/arb]: Index to one of the tables that provide
  additional type information, depending on the value of kind (see
Tabler~\ref{table16}). For KIND\_SCALAR,
\index{KIND\_POINTER}%
KIND\_POINTER and KIND\_VOID, this
  field is zero.

\item[name\_idx]: The name of the type. For anonymous types, this
  field should be zero.

\item[etype/pointed/pu\_flags]: For KIND\_ARRAY, etype gives the type
  of the array element. For KIND\_POINTER, pointed gives the type that
  it points to. For KIND\_FUNCTION, pu\_flags contains attributes of
  the function. For all other values of kind, this field is zero.
\end{description}


Types that are structurally identical can share common
\index{TY}%
TY entries in
order to minimize the size of TY\_TAB.

\begin{table}[h]
\centering
\caption{Attributes of a Function}
\label{table19}
\begin{tabular}{|l|l|l|}\hline
Flag& Value & Description\\\hline\hline
\index{TY\_NO\_ANSI\_ALIAS}%
TY\_NO\_ANSI\_ALIAS & 0x0200 & ANSI alias rules do not apply \\\hline
\index{TY\_IS\_NON\_POD}%
TY\_IS\_NON\_POD & 0x0400 & 
\begin{minipage}{3in}
a C++ non-pod structure
\begin{itemize}
\item constructor/destructor calls must be generated when creating a
  temp. variable of this type (usually done by the frontend)
\end{itemize}
~
\end{minipage}\\ \hline

\index{TY\_RETURN\_TO\_PARAM}%
TY\_RETURN\_TO\_PARAM & 0x00000001 & 
\begin{minipage}{3in}
a function returning a struct that is larger than twice the size of the largest integer type
\begin{itemize}

\item an additional argument (first) is passed which contains the address where the return value is to be placed 
\end{itemize}
~
\end{minipage}\\\hline
\index{TY\_IS\_VARARGS}%
TY\_IS\_VARARGS & 0x00000002 & 
\begin{minipage}{3in}
allows variable number of arguments
\begin{itemize}
\item the last formal parameter is a descriptor of the
variable part of the parameter list 
\end{itemize}
~
\end{minipage}\\\hline
\index{TY\_HAS\_PROTOTYPE}%
TY\_HAS\_PROTOTYPE & 0x00000004 & function has ANSI-style prototype
defined.\\\hline
\end{tabular}
\end{table}


\begin{table}
\centering
\caption{Valid Combinations of
\index{TY}%
TY Kinds and WHIRL Data Types}
\label{table20}
\begin{tabular}{|l|p{4in}|}\hline
Kind & Valid  WHIRL data type\\\hline\hline
\index{KIND\_SCALAR}%
KIND\_SCALAR & all mtypes except
\index{MTYPE\_UNKNOWN}%
MTYPE\_UNKNOWN and MTYPE\_V\\\hline
\index{KIND\_ARRAY}%
KIND\_ARRAY &
\index{MTYPE\_UNKNOWN}%
MTYPE\_UNKNOWN and
\index{MTYPE\_M}%
MTYPE\_M \\\hline
\index{KIND\_STRUCT}%
KIND\_STRUCT &
\index{MTYPE\_M}%
MTYPE\_M \\\hline
\index{KIND\_POINTER}%
KIND\_POINTER &
\index{MTYPE\_U4}%
MTYPE\_U4 or
\index{MTYPE\_U8}%
MTYPE\_U8 (for MIPS)
\index{MTYPE\_A4}%
MTYPE\_A4 or
\index{MTYPE\_A8}%
MTYPE\_A8 (for Merced) \\\hline
\index{KIND\_FUNCTION}%
KIND\_FUNCTION &
\index{MTYPE\_UNKNOWN}%
MTYPE\_UNKNOWN \\\hline
\index{KIND\_VOID}%
KIND\_VOID
\index{MTYPE\_V}%
MTYPE\_V & \\\hline
\end{tabular}
\end{table}


\section{FLD\_TAB}

Each entry of this table gives information about a field in a struct
or union. The
\index{TY}%
TY of the struct type points to the
\index{FLD}%
FLD entry for the
first field.
The remaining fields follow in consecutive
\index{FLD\_TAB}%
FLD\_TAB entries until a
flag indicates it is the last field. The
\index{FLD}%
FLD entry has the following
structure, size 24 bytes:

\begin{description}
\item[name\_idx]:
\index{STR\_IDX}%
STR\_IDX to the name string, 0 if anonymous.

\item[type:]
The
\index{TY\_IDX}%
TY\_IDX of this field. If ofst is equal to the total sizeof the
  struct, the size of the type pointed to by type must be zero.

\begin{table}
\centering
\caption{Layout of FLD} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size \\\hline\hline
byte 0 & name\_idx &
\index{STR\_IDX}%
STR\_IDX to the name string & 1 word \\\hline
byte 4 & type &
\index{TY\_IDX}%
TY\_IDX of field & 1 word \\\hline
byte 8 & ofst & offset within struct in bytes & 2 words \\\hline
byte 16 & bsize & bit field size in bits & 1 byte \\\hline
byte 17 & bofst & bit field offset starting at byte specified by & 1 byte \\\hline
byte 18 & flags &
\index{FLD}%
FLD flags & 2 bytes \\\hline
byte 20 & st &
\index{ST\_IDX}%
ST\_IDX to the
\index{ST}%
ST entry, if any. & 4 bytes\\\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\caption{Miscellaneous Attributes of an
\index{FLD}%
FLD Entry}
\label{table22} 
\begin{tabular}{|l|l|p{3in}|}\hline
Flag & Value & Description \\\hline\hline
\index{FLD\_LAST\_FIELD}%
FLD\_LAST\_FIELD & 0x0001 & indicate the last field in a
struct\\\hline

\index{FLD\_EQUIVALENCE}%
FLD\_EQUIVALENCE & 0x0002 & this field belongs to an equivalence of a
common block (i.e., overlaps in memory with other common block
element(s))\\\hline

\index{FLD\_BEGIN\_UNION}%
FLD\_BEGIN\_UNION & 0x0004 & beginning of a union in a Fortran record\\\hline

\index{FLD\_END\_UNION}%
FLD\_END\_UNION & 0x0008 & end of a union in a Fortran record \\\hline

\index{FLD\_BEGIN\_MAP}%
FLD\_BEGIN\_MAP & 0x0010 & beginning of a map in a Fortran record \\\hline

\index{FLD\_END\_MAP}%
FLD\_END\_MAP & 0x0020 & end of a map in a Fortran record \\\hline

\index{FLD\_IS\_BIT\_FIELD}%
FLD\_IS\_BIT\_FIELD & 0x0040 & 
\begin{minipage}{3in}
indicate a bit field
\begin{itemize}
\item bsize and bofst are valid only if this flag is set
\end{itemize}
~
\end{minipage}\\\hline
\end{tabular}
\end{table}


\item[ofst]: The byte offset of this field within the struct. This must
  be less than or equal to the total size of the struct.

When the offset is equal to the size of the struct, type must be an
\index{TY\_IDX}%
TY\_IDX of a type with zero size.

\item[bsize]: The size of the bit field in number of bits. Valid only if
\index{FLD\_IS\_BIT\_FIELD}%
FLD\_IS\_BIT\_FIELD is set; must be zero otherwise.

\item[bofst]: The bit field offset starting at the byte specified by
ofst. Valid only if
\index{FLD\_IS\_BIT\_FIELD}%
FLD\_IS\_BIT\_FIELD is set; must be zero otherwise.

\item[flags]: Miscellaneous attributes, see Table~\ref{table22}. 

\item[st]:
\index{ST\_IDX}%
ST\_IDX to the (optional)
\index{ST}%
ST entry corresponding to this field.

\begin{itemize}
\item
typically used for common block elements where each element
has a separate
\index{ST}%
ST entry.

\item the
\index{ST}%
ST entry must be one in the global symbol
table. 
\item  when not set, must be zero.
\end{itemize}
\end{description}

\section{TYLIST\_TAB}

Each entry of this table gives the type of each parameter in a
function prototype. The
\index{TY}%
TY of the function prototype points to the
\index{TYLIST}%
TYLIST entry that gives the return type. The ensuing entries give the
types of the parameters. A
\index{TY\_IDX}%
TY\_IDX value of 0 specifies the end of the
parameter list. The
\index{TYLIST}%
TYLIST entry has the following structure:

\begin{table}[h]
\centering
\caption{Layout of TYLIST}
\label{Table_23} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size\\\hline\hline 
byte 0 & type &
\index{TY\_IDX}%
TY\_IDX to the type & 1 word\\\hline
\end{tabular}
\end{table}


\section{ARB\_TAB}

Each entry of this table gives information about a dimension of an
array. The
\index{TY}%
TY of the array type points to the
\index{ARB}%
ARB entry for the first
dimension, indicated by ARB\_FIRST\_DIMEN. For C/C++ arrays, this
corresponds to the leftmost dimension. For Fortran arrays, this
corresponds to the right-most dimension. The remaining dimensions
follow in consecutive
\index{ARB\_TAB}%
ARB\_TAB entries until an entry with
\index{ARB\_LAST\_DIMEN}%
ARB\_LAST\_DIMEN set. The dimension of the array must be specified in
dimension of every entry.

The
\index{ARB}%
ARB entry has the following structure, size 32 bytes:

\begin{table}[h]
\centering
\caption{Layout of ARB} 
\label{table24} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size \\\hline\hline
byte 0 & flags & misc. attributes & 2 bytes\\\hline 
byte 2 & dimension & dimension of the array & 2 bytes\\\hline 
byte 4 & unused & unused, must be filled with zeros & 1 word \\\hline
byte 8 & lbnd\_val & constant lower bound value & 2 words \\\hline
byte 8 & lbnd\_var &
\index{ST\_IDX}%
ST\_IDX of variable that stores the non-constant lower bound & 1 word \\\hline
byte 12&  lbnd\_unused & filler for lbnd\_var, must be zero & 1 word \\\hline
byte 16 & ubnd\_val & constant upper bound value & 2 words \\\hline
byte 16 & ubnd\_var &
\index{ST\_IDX}%
ST\_IDX of variable that stores the non-constant upper bound & 1 word\\\hline
byte 20 & ubnd\_unused & filler for ubnd\_var, must be zero & 1 word \\\hline
byte 24 & stride\_val & constant stride & 2 words \\\hline
byte 24 & stride\_var &
\index{ST\_IDX}%
ST\_IDX of variable that stores the non-constant stride & 1 word\\\hline
byte 28 & stride\_unused & filler for stride\_var, must be zero & 1 word\\\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Miscellaneous Attributes of an
\index{ARB}%
ARB Entry}
\label{table25}
\begin{tabular}{|l|l|l|}\hline
Flag  & Value & Description\\\hline\hline
\index{ARB\_CONST\_LBND}%
ARB\_CONST\_LBND & 0x0001 &lower bound is constant\\\hline
\index{ARB\_CONST\_UBND}%
ARB\_CONST\_UBND & 0x0002 &upper bound is constant\\\hline 
\index{ARB\_CONST\_STRIDE}%
ARB\_CONST\_STRIDE & 0x0004 &stride is constant \\\hline
\index{ARB\_FIRST\_DIMEN}%
ARB\_FIRST\_DIMEN & 0x0008 &current dimension is first \\\hline
\index{ARB\_LAST\_DIMEN}%
ARB\_LAST\_DIMEN & 0x0010 &current dimension is last\\\hline
\end{tabular}
\end{table}

\section{TCON\_TAB}

Each entry of this table is the
\index{TCON}%
TCON for storing integer, floating
point or string constant values. The first three entries of this table
are reserved. The first entry (index 0) is reserved for uninitialized
index value. The second entry (index 1) always contains 4-byte
floating point value 0.0. the third entry (index 2) always contains
8-byte floating point value 0.0. These entries are shared. All other
values are entered independently without checking for duplicates. The
\index{TCON}%
TCON entry has the following structure, size 40 bytes:

\begin{table}[h]
\centering
\caption{Layout of TCON} 
\label{table26} 
\begin{tabular}{|l|l|p{3in}|l|}\hline
Offset & Field & Description & Field size\\\hline\hline
byte 0 & ty & WHIRL data type, see Table~\ref{table17} & 1 word \\\hline
byte 4 & flags & misc. attributes & 1 word \\\hline
byte 8 & ival & signed integer (MTYPE\_I1, MTYPE\_I2, and MTYPE\_I4) & 1 word\\\hline
byte 8 & uval & unsigned integer (MTYPE\_U1, MTYPE\_U2, and MTYPE\_U4) & 1 word\\\hline
byte 8 & i0 & 64-bit signed integer (MTYPE\_I8) & 2 words \\\hline
byte 8 & k0 & 64-bit unsigned integer (MTYPE\_U8) & 2 words \\\hline
byte 8 & fval & 32-bit floating point (MTYPE\_F4)real part for 32-bit complex (MTYPE\_C4) & 1 word\\\hline
byte 8 & dval & 64-bit floating point (MTYPE\_F8)real part for 64-bit complex (MTYPE\_C8) & 2 words\\\hline
byte 8 & qval & 128-bit floating point (MTYPE\_FQ)real part for 128-bit
 complex (MTYPE\_CQ) & 4 words\\\hline
byte 8 & sval & 
\begin{minipage}{3in}
string literal (MTYPE\_STR/MTYPE\_STRING)
\begin{itemize}
\item byte 8  holds a character pointer  (1 word)
\item byte 12  holds the number of bytes of the string  (1 word)
\end{itemize}
~
\end{minipage} & 3 words \\\hline
byte 24 & fival & imaginary part for 32-bit complex(MTYPE\_C4) & 1 word\\\hline
byte 24 & dival & imaginary part for 64-bit complex(MTYPE\_C8) & 2 words\\\hline

byte 24 & qival & imaginary part for 128-bit complex(MTYPE\_CQ)&  4 words\\\hline
\end{tabular}
\end{table}

\section{INITO\_TAB}

Each entry of this table connects an initialized global or static data
object with an
\index{INITV}%
INITV entry (see Section 2.11), which describes the
initial values. Each entry of this table is an INITO, which is
identified by a value of type INITO\_IDX.

\subsection{INITO\_IDX}

\index{INITO\_IDX}%
INITO\_IDX has an identical structure as a ST\_IDX. It is of size 32
bits, and is composed of two parts:

\begin{table}[h]
\centering
\caption{Layout of INITO\_IDX}
\label{table27} 
\begin{tabular}{|l|l|p{3in}|}\hline
Field & Description & Field position and size\\\hline\hline
level & lexical level & least significant 8 bits \\\hline
index & index to
\index{INITO\_TAB}%
INITO\_TAB & most significant 24 bits\\\hline
\end{tabular}
\end{table}

The low order 8 bits are used to index into the
\index{SCOPE}%
SCOPE array in order
to get to the INITO\_TAB.

\subsection{INITO Entry}

The
\index{INITO}%
INITO entry has the following structure, size 8 bytes:

\begin{table}[h]
\centering
\caption{Layout of INITO} 
\label{table28}
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size \\\hline\hline
byte 0 & st\_idx &
\index{ST\_IDX}%
ST\_IDX of the variable to be initialized & 1 word \\\hline
byte 4 & val &
\index{INITV\_IDX}%
INITV\_IDX of the initial values description & 1 word\\\hline
\end{tabular}
\end{table}

\section{INITV\_TAB}

Each entry of this table specifies the initial value of a scalar
component of a data object. Initial values of complex data objects are
described by a tree of
\index{INITV}%
INITV entries, the root of which specified by
the
\index{INITV\_IDX}%
INITV\_IDX of an INITO.

The
\index{INITV}%
INITV entry has the following structure, size 16 bytes:

\begin{center}
\begin{longtable}{|p{.5in}|p{.5in}|p{3in}|p{.75in}|}
\caption{Layout of INITV\label{table29}}\\
\hline
Offset & Field & Description & Field size\\\hline\hline
byte 0 &next &
\index{INITV\_IDX}%
INITV\_IDX for the value of the next array element or the
field in a struct & 1 word\\\hline
byte 4 & kind & kind of the INITV, see Table~\ref{table30}. & 2 bytes \\\hline
byte 6 & repeat1 & repeat factor except for
\index{INITVKIND\_VAL}%
INITVKIND\_VAL & 2 bytes \\\hline
byte 8 & st &
\index{ST\_IDX}%
ST\_IDX of symbol for
\index{INITVKIND\_SYMOFF}%
INITVKIND\_SYMOFF & 1 word \\\hline
byte 8 & lab &
\index{LABEL\_IDX}%
LABEL\_IDX of symbol for
\index{INITVKIND\_LABEL}%
INITVKIND\_LABEL & 1 word \\\hline
byte 8 & lab1 &
\index{LABEL\_IDX}%
LABEL\_IDX of label for INITVKIND\_SYMDIFF(16) & 1 word \\\hline
byte 8 & mtype & WHIRL data type for
\index{INITVKIND\_ZERO}%
INITVKIND\_ZERO and
\index{INITVKIND\_ONE}%
INITVKIND\_ONE & 1 word \\\hline
byte 8 & tc &
\index{TCON\_IDX}%
TCON\_IDX for
\index{INITVKIND\_VAL}%
INITVKIND\_VAL & 1 word \\\hline
byte 8 & blk &
\index{INITV\_IDX}%
INITV\_IDX for
\index{INITVKIND\_BLOCK}%
INITVKIND\_BLOCK & 1 word \\\hline
byte 8 & pad & padding in bytes & 1 word \\\hline
byte 12 & ofst & byte offset from st for
\index{INITVKIND\_SYMOFF}%
INITVKIND\_SYMOFF & 1 word \\\hline
byte 12 & st2 &
\index{ST\_IDX}%
ST\_IDX of symbol for INITVKIND\_SYMDIFF(16) & 1 word \\\hline
byte 12 & repeat2 & repeat factor for INITVKIND\_ZERO, INITVKIND\_ONE,
and
\index{INITVKIND\_VAL}%
INITVKIND\_VAL & 1 word \\\hline
byte 12 & unused & filler for INITVKIND\_BLOCK, INITVKIND\_PAD, and
INITVKIND\_LABEL, must be zero & 1 word \\\hline
\end{longtable}
\end{center}



\begin{description}

\item[next/blk]: The values of a data object are specified by a tree
  of INITVs, with the root of the tree pointed to by the INITO. INITVs
  specifying scalars are linked up by the next field, each of which
  contains an INITV\_IDX. The end of a link is specified by a zero
  INITV\_IDX. Aggregate values are grouped into a separate links
  headed by the blkfield, which must not be the zero INITV\_IDX.

\item[kind]: Kind of this
\index{INITV}%
INITV entry, see Table~\ref{table30}.

\begin{center}
\begin{longtable}{|p{2in}|p{.5in}|p{3in}|}
\caption{INITVKIND\label{table30}}\\
\hline
Name & Value & Description \endhead\hline\hline
\index{INITVKIND\_SYMOFF}%
INITVKIND\_SYMOFF &1 &value is the address of the symbol (st)
plus offset (ofst) \\\hline
\index{INITVKIND\_ZERO}%
INITVKIND\_ZERO &2 &integer value zero \\\hline
\index{INITVKIND\_ONE}%
INITVKIND\_ONE &3 &integer value one \\\hline
\index{INITVKIND\_VAL}%
INITVKIND\_VAL &4 &an integer, floating point, or string, specified by a
\index{TCON}%
TCON (tc)\\\hline
\index{INITVKIND\_BLOCK}%
INITVKIND\_BLOCK & 5 & specifies another list or tree of INITVs \\\hline
\index{INITVKIND\_PAD}%
INITVKIND\_PAD & 6 & amount of padding in bytes \\\hline
\index{INITVKIND\_SYMDIFF}%
INITVKIND\_SYMDIFF & 7 & value is the difference of the addresses of a
label and a symbol (lab1 - st2)\\\hline
INITVKIND\_SYMDIFF16 & 8 & same as INITVKIND\_SYMDIFF, except the value is 2 bytes in size \\\hline
\index{INITVKIND\_LABEL}%
INITVKIND\_LABEL & 9 & value is the address of the label (lab)\\\hline
\end{longtable} 
\end{center}

\item[repeat1]: Specifies the repeat factor of the value in this
\index{INITV}%
INITV
  entry. This cuts down the number of unnecessary duplicates. A repeat
  factor of one means only one instance of the value is needed. The
  repeat factor is never zero, except for INITVKIND\_ZERO,
  INITVKIND\_ONE, and INITVKIND\_VAL, which use repeat2 instead.

\item[st/ofst]: For INITVKIND\_SYMOFF, the value of this entry is equal
  to the address of the symbol specified by st, plus the byte offset
  specified by ofst.

\item[label]: For INITVKIND\_LABEL, the value of this entry is equal to
  the address of the label specified by lab.

\item[lab1/st2]: For
\index{INITVKIND\_SYMDIFF}%
INITVKIND\_SYMDIFF or INITVKIND\_SYMDIFF16, the
  value of this entry is equal to the difference between the addresses
  of the label specified by lab1  and of the symbol specified by st2. It
  is a signed value equal to (lab1 - st2). For INITVKIND\_SYMDIFF16,
  thesize of the value is 2 bytes.

\item[mtype/repeat2]: For
\index{INITVKIND\_ZERO}%
INITVKIND\_ZERO and INITVKIND\_ONE, this
  entry specifies an integral value of zero and one respectively. The
  WHIRL data type (signed/unsigned, size, etc.)is specified by
  mtype. It uses repeat2 as its repeat factor instead of repeat1.

\item[tc/repeat2]: For INITVKIND\_VAL, this specifies a
\index{TCON}%
TCON for the
  scalar constant value. It uses repeat2 as its repeat factor instead
  of repeat1.

\item[pad]: For INITKIND\_PAD, this specifies the padding in bytes. The
  padded value is undefined.
\end{description}

\section{BLK\_TAB}

Each entry of this table gives information about the layout of a
data block, which corresponds to a contiguous chunk of memory in the
user program. Program variables are laid out with respect to data
blocks. This table is created by the back end and is usually local to
the back end, but can be written out to the file. The
\index{BLK}%
BLK entry has
the following structure, size 16 bytes:

\begin{center}
\begin{longtable}{|p{1in}|p{1in}|p{3in}|p{.75in}|}
\caption{Layout of BLK\label{table31}}\\
\hline
Offset & Field & Description & Field size\endhead\hline \hline
byte 0 & size & size of the block & 2 words\\\hline 
byte 8 & align & alignment of the blocks: 1, 2, 4, 8 & 2 bytes \\\hline
byte 10 & flags & flags for this field, see Table~\ref{table32} & 2 bytes\\\hline 
byte 12 & section\_idx &
\begin{minipage}{3in}
section index (0 if not a section)
\begin{itemize}
\item refers to the section info in data\_layout.cxx 
\end{itemize}
~
\end{minipage}& 2 bytes\\\hline
byte 14 & scninfo\_idx & 
\begin{minipage}{3in}
Elf scninfo\_idx (0 if not a section)
\begin{itemize}
\item refers to the Elf section info in cgemit.cxx 
\end{itemize}
~
\end{minipage} & 
2 bytes\\\hline
\end{longtable}
\end{center}

\begin{center}
\begin{longtable}{|p{2in}|p{1in}|p{3in}|}
\caption{Miscellaneous Attributes of a
\index{BLK}%
BLK Entry\label{table32}}\\
\hline
Flag &Value &Description\endhead\hline\hline 
\index{BLK\_SECTION}%
BLK\_SECTION &0x0001 &represents an Elf section\\\hline
\index{BLK\_ROOT\_BASE}%
BLK\_ROOT\_BASE &0x0002 &block should not be merged\\\hline
\index{BLK\_IS\_BASEREG}%
BLK\_IS\_BASEREG &0x004 &block that maps into a register \\\hline
\index{BLK\_DECREMENT}%
BLK\_DECREMENT &0x0008 &grow block by decrementing \\\hline
\index{BLK\_EXEC}%
BLK\_EXEC &0x0010 &executable instructions (SHF\_EXEC)\\\hline
\index{BLK\_NOBITS}%
BLK\_NOBITS &0x0020& occupies no space in file (SHT\_NOBITS) \\\hline
\index{BLK\_MERGE}%
BLK\_MERGE &0x0040 &merge duplicates in linker (SHF\_MERGE) \\\hline
\index{BLK\_COMPILER\_LAYOUT}%
BLK\_COMPILER\_LAYOUT &0x0080 & 
\begin{minipage}{3in}
layout of all symbols within this block is done by the compiler
\begin{itemize}
\item this implies that user's code cannot
legally use address arithmetic to move from one of the symbols to another
\end{itemize}
~
\end{minipage}\\\hline
\end{longtable}
\end{center}

\section{STR\_TAB}

This table holds all character strings for names of symbols, types,
labels, etc. This table can be viewed as a block of storage area for
character strings.
\index{STR\_IDX}%
STR\_IDX is the index to this table, and is
actually an offset in this block of storage; it gives the byte offset
of the starting character of a literal string. All strings are
null-terminated, and the first character of the block is always
null. Thus, a zero
\index{STR\_IDX}%
STR\_IDX represents a null string. Wide characters
or unicode for names are not yet supported.

\section{TCON\_STR\_TAB}

This table holds all character strings defined in the user program. It
is very similar to STR\_TAB, with the exception that the strings need not
be null-terminated, and null characters are allowed anywhere within the
string. The exact length of each string is explicitly specified.

\section{LABEL\_TAB}

Each entry of this table is a LABEL, which gives the information associated with a WHIRL label. The index to this table is the WHIRL label number.

The
\index{LABEL}%
LABEL entry has the following structure:

\begin{table}[h]
\centering
\caption{Layout of LABEL}
\label{table33} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size \\\hline\hline
byte 0 & name\_idx &
\index{STR\_IDX}%
STR\_IDX to the name string, must be zero if no
name & 1 word\\\hline
byte 4 & flags &
\index{LABEL}%
LABEL flags & 3 bytes \\\hline
byte 7 & kind & kind of label & 1 byte\\\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{LABEL} 
\label{table34} 
\begin{tabular}{|l|l|l|}\hline
Kind Name & Value & Description \\\hline\hline
\index{LKIND\_DEFAULT}%
LKIND\_DEFAULT & 0 & ordinary label \\\hline
\index{LKIND\_ASSIGNED}%
LKIND\_ASSIGNED & 1 &\\\hline
\index{LKIND\_BEGIN\_EH\_RANGE}%
LKIND\_BEGIN\_EH\_RANGE & 2 &\\\hline
\index{LKIND\_END\_EH\_RANGE}%
LKIND\_END\_EH\_RANGE &3 &\\\hline
\index{LKIND\_BEGIN\_HANDLER}%
LKIND\_BEGIN\_HANDLER &4 &\\\hline
\index{LKIND\_END\_HANDLER}%
LKIND\_END\_HANDLER &5&\\\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Miscellaneous Attributes of an
\index{LABEL}%
LABEL Entry}
\label{table35} 
\begin{tabular}{|l|l|p{2in}|}\hline
Flag & Value & Description \\\hline\hline
\index{LABEL\_TARGET\_OF\_GOTO\_OUTER\_BLOCK}%
LABEL\_TARGET\_OF\_GOTO\_OUTER\_BLOCK & 0x000001 & control might be
passed from outside of the current block to this label.\\\hline

\index{LABEL\_ADDR\_SAVED}%
LABEL\_ADDR\_SAVED & 0x000002 & address of this label is saved to a variable\\\hline

\index{LABEL\_ADDR\_PASSED}%
LABEL\_ADDR\_PASSED & 0x000040 & address of this label is passed to another
\index{PU}%
PU as actual parameter
\index{PREG\_TAB}%
PREG\_TAB \\\hline
\end{tabular}
\end{table}

\section{PREG\_TAB}

Each entry of this table is a PREG, which gives the information
associated with a pseudo-register in WHIRL. Pseudo-register numbers
0--71 are reserved for dedicated hardware pseudo-registers. All
compiler-generated pseudo-registers start with number 72. As a result,
the index to this table is the pseudo-register number, minus 71
(Note: by definition, index 0 to the
\index{PREG\_TAB}%
PREG\_TAB is reserved for
undefined value). The
\index{PREG}%
PREG entry has the following structure:


\begin{table}[h]
\centering
\caption{Layout of PREG} 
\label{Table_36} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size \\\hline\hline
byte 0 & name\_idx &
\index{STR\_IDX}%
STR\_IDX to the name string, must be zero if no name & 1 word\\\hline
\end{tabular}
\end{table}

\clearpage
\section{ST\_ATTR\_TAB}

Each entry of this table associates certain attribute with an
\index{ST}%
ST
entry. Symbol attributes specified here usually cannot be represented
by a single bit, and are possessed by a very small subset of the
\index{ST}%
ST
entries, and thus are too expensive to be included as part of the
\index{ST}%
ST entry proper. For most PU, this table is expected to be empty.

The
\index{ST\_ATTR}%
ST\_ATTR entry has the following structure, size 12 bytes:
\begin{table}[h]
\centering
\caption{Layout of ST\_ATTR} 
\label{Table_37} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size \\\hline\hline 
byte 0 & st\_idx &
\index{ST\_IDX}%
ST\_IDX of the corresponding symbol & 1 word \\\hline
byte 4 & kind & kind of the ST\_ATTR, see Table~\ref{table38} & 1 word \\\hline
byte 8 & reg\_id & 
\begin{minipage}{3in}
\flushleft
dedicated (physical) register associated with this symbol
\begin{itemize}
\item symbol must have
\index{ST\_ASSIGNED\_TO\_DEDICATED\_PREG}%
ST\_ASSIGNED\_TO\_DEDICATED\_PREG bit set
\end{itemize}
~
\end{minipage}
& 1 word\\\hline
byte 8 & section\_name & 
\begin{minipage}{3in}
\index{STR\_IDX}%
STR\_IDX of the name of the Elf section where
this symbol is defined
\begin{itemize}
\item symbol must be in global scope
\end{itemize}
~
\end{minipage} & 1 word\\\hline
\end{tabular}
\end{table}


\begin{table}[h]
\centering
\caption{Kinds of ST\_ATTR} 
\label{table38} 
\begin{tabular}{|l|l|l|}\hline
Name & Value & Description \\\hline\hline
\index{ST\_ATTR\_DEDICATED\_REGISTER}%
ST\_ATTR\_DEDICATED\_REGISTER & 0 & dedicated register\\\hline 
\index{ST\_ATTR\_SECTION\_NAME}%
ST\_ATTR\_SECTION\_NAME & 1 & section name\\\hline
\end{tabular}
\end{table}

\section{FILE\_INFO}

This structure is not really part of the symbol table, it holds
miscellaneous information that is derived from the symbol table but
does not fit well in any global symbol table. Typically, this
information is needed by the compiler backend to set up proper mode of
operation before any
\index{PU}%
PU is processed.

A
\index{FILE\_INFO}%
FILE\_INFO has the following structure, size 8 bytes:

\begin{table}[h]
\centering
\caption{Layout of FILE\_INFO}
\label{Table_39} 
\begin{tabular}{|l|l|l|l|}\hline
Offset &Field & Description & Field size \\\hline\hline
byte 0 & flags & misc. attributes, see Table~\ref{table40} & 1 word \\\hline
byte 4 & gp\_group & gp-group id of this file, 0 for single
\index{GOT}%
GOT file & 1 byte\\\hline
byte 5 & unused & unused, must be zero & 3 bytes\\\hline
\end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Miscellaneous Attributes of FILE\_INFO}
\label{table40} 
\begin{tabular}{|l|l|l|}\hline
Flag & Value & Description\\\hline\hline
\index{FI\_IPA}%
FI\_IPA &0x00000001 &IPA generated file\\\hline
\index{FI\_NEEDS\_LNO}%
FI\_NEEDS\_LNO &0x00000002 &some PUs in this file has the flag
\index{PU\_MP\_NEEDS\_LNO}%
PU\_MP\_NEEDS\_LNO set\\\hline
\index{FI\_HAS\_INLINES}%
FI\_HAS\_INLINES &0x00000004 &some PUs in this file has the flag
\index{PU\_HAS\_INLINES}%
PU\_HAS\_INLINES set\\\hline
\index{FI\_HAS\_MP}%
FI\_HAS\_MP &0x00000008 &some PUs in this file has the flag
\index{PU\_HAS\_MP}%
PU\_HAS\_MP set\\\hline
\end{tabular}
\end{table}



\section{Backend-Specific Tables}

This section describes addition symbol tables that are created and
used solely by the compiler backend. Each entry in these tables holds
addition information associated with the corresponding regular symbol
table entries. They are discarded at the end of the backend's
processing and are never written out to a file. Note that these tables
are not part of the WHIRL symbol table specification and are
implementation specific. The following descriptions apply only to the
current implementation of the Open64 compiler.

\subsection{BE\_ST\_TAB}
\label{be-st-tab}

This table is parallel to the ST\_TAB. Each entry of this table is a
BE\_ST, which corresponds to an
\index{ST}%
ST entry. The same
\index{ST\_IDX}%
ST\_IDX is used to
index an
\index{BE\_ST}%
BE\_ST entry in a
\index{BE\_ST\_TAB}%
BE\_ST\_TAB and the corresponding
\index{ST}%
ST entry
in the ST\_TAB.

The
\index{BE\_ST}%
BE\_ST entry has the following structure, size 8 bytes:

\begin{table}[h]
\centering
\caption{Layout of BE\_ST}
\label{Table_41} 
\begin{tabular}{|l|l|l|l|}\hline
Offset & Field & Description & Field size \\\hline\hline
byte 0 & flags &
\index{BE\_ST}%
BE\_ST flags & 1 word \\\hline
byte 4 & io\_auxst & pointer to an internal data structure used by the
Fortran I/O routines. & 1 word\\\hline
\end{tabular}
\end{table}

{\small
\begin{center}
\begin{longtable}{|p{2.6in}|p{.65in}|p{3in}|}
\caption{Miscellaneous Attributes of an
\index{BE\_ST}%
BE\_ST entry\label{Table_42}}\\
\hline
Flag & Value & Description\endhead\hline\hline
\index{BE\_ST\_ADDR\_USED\_LOCALLY}%
BE\_ST\_ADDR\_USED\_LOCALLY & 0x00000001 & 
\begin{minipage}{3in}
\flushleft
address of this symbol is taken somewhere within the current
\index{PU}%
PU
\begin{itemize}
\item this flag is computed based on the backend's
analysis 
\end{itemize}
~
\end{minipage}\\\hline
\index{BE\_ST\_ADDR\_PASSED}%
BE\_ST\_ADDR\_PASSED & 0x00000002 & 
\begin{minipage}{3in}
\flushleft
address if this symbol is passed by reference
\begin{itemize}
\item this flag is computed based on the backend's analysis
\item this flag is different from ST\_ADDR\_PASSED, which is set by
  the frontend based on the source language's semantics
\end{itemize}
~
\end{minipage}\\\hline
\index{BE\_ST\_W2FC\_REFERENCED}%
BE\_ST\_W2FC\_REFERENCED &0x00000004 &whirl2c or whirl2f sees a
reference to this symbol \\\hline
\index{BE\_ST\_UNKNOWN\_CONST}%
BE\_ST\_UNKNOWN\_CONST & 0x00000008 & 
\begin{minipage}{3in}
symbol is a constant but with unknown value
\begin{itemize}
\item generated by
\index{LNO}%
LNO
\end{itemize}
~
\end{minipage}\\\hline
\index{BE\_ST\_PU\_HAS\_VALID\_ADDR\_FLAGS}%
BE\_ST\_PU\_HAS\_VALID\_ADDR\_FLAGS & 0x00000010 &
\begin{minipage}{3in}
\flushleft
indicate that the
\index{BE\_ST\_ADDR\_USED\_LOCALLY}%
BE\_ST\_ADDR\_USED\_LOCALLY
and
\index{BE\_ST\_ADDR\_PASSED}%
BE\_ST\_ADDR\_PASSED bits are valid for the
\index{PU}%
PU specified by corresponding
\index{ST}%
ST entry.
\begin{itemize}
\item valid only for
\index{CLASS\_FUNC}%
CLASS\_FUNC
\item depending on the optimization level, the above
two
\index{BE\_ST\_ADDR}%
BE\_ST\_ADDR flags might not be valid
\item tail-call optimization can be performed only when
\index{BE\_ST\_PU\_HAS\_VALID\_ADDR\_FLAGS}%
 BE\_ST\_PU\_HAS\_VALID\_ADDR\_FLAGS is set
\end{itemize}
~
\end{minipage}\\\hline
\index{BE\_ST\_PU\_NEEDS\_ADDR\_FLAG\_ADJUST}%
BE\_ST\_PU\_NEEDS\_ADDR\_FLAG\_ADJUST & 0x00000020 & 
\begin{minipage}{3in}
\flushleft
indicate that the 
\index{ST\_ADDR\_SAVED}%
ST\_ADDR\_SAVED and
\index{ST\_ADDR\_PASSED}%
ST\_ADDR\_PASSED bits are no longer valid
\begin{itemize}
\item typically set by the MP-lowerer
\item needs to recompute the above two bits before
moving on the next phase in the backend
\end{itemize}
~
\end{minipage}\\\hline
\end{longtable}
\end{center}
}

\section{Symbol Table Interfaces}

The symbol table interfaces are described in a separate document. An
online version can be found in
http://sahara.mti.sgi.com/Projects/Symtab/porting.html/.



%\clearpage
%\addcontentsline{toc}{section}{Index}
%\printindex
%\end{document}
