# ====================================================================
#
# Copyright (C) 2011, Hewlett-Packard Development Company, L.P.
# All Rights Reserved.
#
# Open64 is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# Open64 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301, USA.
#
# ====================================================================
package emitScriptUtils;

use strict;

use Exporter ();
use vars qw( @ISA @EXPORT $VERSION );
@ISA = qw( Exporter );
@EXPORT = qw(&emitScriptPreamble &emitEnvSaveFile &getDataModeFlag);
$VERSION = "1.00";

use Cwd;
use FindBin;
use File::Basename;
use lib "$FindBin::Bin/lib";
use getEnvVar;
use chopSrcExtension;
use readTestLevelCustomizableOptions;
use savedOptions;
use cti_error;

# Subroutine: getDataModeFlag
#
# Usage: getDataModeFlag()
#
# Return value of DATA_MODE_FLAG based on the environment flags DATA_MODE
# and DATA_MODE_MAPPING.  If DATA_MODE_MAPPING is unset or empty then
# DATA_MODE_FLAG is set to the value of DATA_MODE.  If DATA_MODE_MAPPING
# is set, it should be a series of substituions that will be made to
# DATA_MODE in order to get a value for DATA_MODE_FLAG.
#
# i.e. DATA_MODE_MAPPING="+DD32/-milp32 +DD64/-mlp64" would map a DATA_MODE
# of +DD32 to -milp32 or +DD64 to -mlp64.
#
sub getDataModeFlag {
  my $dm = getEnvVar("DATA_MODE");
  my $dm_map = getEnvVar("DATA_MODE_MAPPING");
  my $dm_check = getEnvVar("DATA_MODE_CHECK");
  if (($dm_check eq "true") && ($dm ne "+DD32") && ($dm ne "+DD64")) {
    error("DATA_MODE must be set to +DD32 or +DD64");
  }
  foreach my $s (split(/\s+/, $dm_map)) {
      my $old;
      my $new;
      ($old, $new) = split(/\//, $s, 2);
      $dm =~ s/\Q$old\E/$new/;
  }
  return $dm
}

# Subroutine: emitEnvSaveFile
#
# Usage: emitEnvSaveFile($file, unit, [e1, e2, ... ])
#
# Emit code to save the current environment and additional env. vars
# to a file. First parameter is target .env filename, followed by unit
# name and additional(optional) env. var. names.
#
sub emitEnvSaveFile {
  my $file = shift;

  local *SENV;
  open (SENV, "> ${file}") or
      error("can't open ${file} for writing");
  saveEnvironment(\*SENV, @_);
  close(SENV);
}

# Subroutine: emitScriptPreamble
#
# Usage: emitScriptPreamble(\FH, $testname, $tag, $dpath, $esave_file)
#
# Emit the preamble for an auxiliary script generated to perform
# the test. First argument is ref of file handle to write to, second
# argument is test being processed, third argument is a descriptive tag
# for the script (e.g. "compile"), fourth argument is path of
# driver that is emitting the script (ex: regression.pl), and 
# final arg is environment save file to source.
#
sub emitScriptPreamble
{
  my $fh = shift;          # first argument is file handle to write to
  my $test = shift;        # test name
  my $tag = shift;         # description of script
  my $driver_path = shift; # name of invoking driver script 
  my $esave_file = shift;  # env var save file

  my $view = basename(getEnvVar("CLEARCASE_ROOT"));
  my $shell = getRequiredEnvVar("CTI_SHELL");
  my $tooldir = getRequiredEnvVar("CTI_TOOLDIR");
  my $hostinfo = `$tooldir/uname -mnr`;
  chomp $hostinfo;
  my $now = `$tooldir/date`;
  chomp $now;
  my ($package, $filename, $line) = caller;

  print $fh "\#!${shell}\n";
  print $fh "\#\n";
  print $fh "\# $tag script for test: $test\n";
  print $fh "\#\n";
  print $fh "\# generated by: $driver_path\n";
  print $fh "\#       and by: $package:$filename:$line\n";
  print $fh "\# generated at: $now\n";
  print $fh "\# hostinfo: $hostinfo\n";
  if ($view ne "") {
    print $fh "\# view: $view\n";
  }
  if (defined($esave_file) && $esave_file ne "") {
    print $fh "\#\n";
    print $fh "\# import saved environment\n";
    print $fh ". $esave_file 2>/dev/null\n";
  }
  print $fh "\#\n";
}


# Subroutine: saveEnvironment
#
# Usage: saveEnvironment(\*FILEHANDLE, e1, e2, ...);
#
# This routine emits Bourne shell code to the specified file to 
# capture the portions of the environment that need to be saved
# for the specified test. By default, we save all test-level 
# customizable options. Any arguments to the routine
# above and beyond the output file handle will be interpreted
# as additional variables to save.
#
# To cut down on the amount of junk in the *.env file, we strip out
# variable settings that are known to be uninteresting to the test
# itself. This includes things like the CHILDREN setting, the
# UNIT_DRIVER settings, and so on.
#
sub saveEnvironment {
  my $fh = shift;
  my $unit = shift;
  my $twd = getEnvVar("SAVED_TEST_WORK_DIR");

  print $fh "\#\n";
  print $fh "\#. $twd/TMEnv\n";
  print $fh "\# begin saved environment (pruned)\n";

  #
  # This is a list of variables that needs to be saved 
  # even though they are not test-level customizable options.
  #
  my %sv_hash = savedOptions();

  #
  # This is a list of variables that we are supposed to NOT save
  # for disk space/readability reasons. Note that each of these
  # guys has to be a TLCO (this is enforced by the reading routine).
  #
  my %unsv_hash = unsavedOptions();

  #
  # This is our master list of test-level customizable options
  #
  my %tco_hash = readTestLevelCustomizableOptions();

  my %special_vars = ( 'USE_SIMULATORS' => '',
                       'SIMULATOR'      => '', 
                       'SIMULATOR_NAME' => '',
		       'CTI_HOME'       => '',
		       'WRKROOT'        => '',
		       '_DOLLAR'        => '', 
		       '_SPACE'         => '',
                    );

  my @prunedlist = ();
  for my $var (keys %tco_hash, keys %sv_hash) {
    #
    # Prune out variables that we don't want to save
    #
    next if (defined $unsv_hash{ $var });

    #
    # Abstract out special variables
    #
    if (defined $special_vars{ $var }) {
       $special_vars{ $var } = getEnvVar($var);
       next;
    }

    #
    # Non-perf tests don't need REAL_HARDWARE_* and DTM_PERF_* stuff
    # Only record these vars for SPEC, OOB, and Applications.
    #
    my $perfunit = 0;
    if ($unit =~ /^Perf\// || $unit =~ /^OOB\// || $unit =~ /^Applications\//) {
      $perfunit = 1;
    }
    next if ($var =~ /^REAL_HARDWARE_/ && (! $perfunit));
    next if ($var =~ /^DTM_PERF_/ && (! $perfunit));

    push @prunedlist, $var;
  }

  # Save on the top of .env file the WRKROOT and CTI_HOME export variables (unless they are empty)
  # as some other env vars may have a dependency on them
  my $thd = $special_vars{ 'WRKROOT' };
  print $fh "export WRKROOT=\"$thd\"\n" if $thd;
  $thd = $special_vars{ 'CTI_HOME' };
  print $fh "export CTI_HOME=\"$thd\"\n" if $thd;

  #
  # SIMULATOR related special env. vars saved first
  #
  my $uSim = $special_vars{ 'USE_SIMULATORS' };
  my $simu = $special_vars{ 'SIMULATOR' };
  my $simN = $special_vars{ 'SIMULATOR_NAME' };
  my $dlr = $special_vars{ '_DOLLAR' };
  my $spc = $special_vars{ '_SPACE' };
  print $fh "export USE_SIMULATORS=\"$uSim\"\n";
  if ($uSim eq 'yes' || $uSim eq 'YES' || $uSim eq 'true' || $uSim eq 'TRUE') {
    print $fh "export SIMULATOR=\"$simu\"\n";
    print $fh "export SIMULATOR_NAME=\"$simN\"\n";
  }
  else {
    # set SIMULATOR and SIMULATOR_NAME to empty
    print $fh "# export SIMULATOR=\"$simu\"\n";
    print $fh "# export SIMULATOR_NAME=\"$simN\"\n";
    print $fh "export SIMULATOR=\"\"\n";
    print $fh "export SIMULATOR_NAME=\"\"\n";
  }
  if (defined $dlr) {
    print $fh "export _DOLLAR=\"$dlr\"\n";
  }
  if (defined $spc) {
    print $fh "export _SPACE=\"$spc\"\n";
  }

  #
  # Now go ahead and save everything into @prunedlist
  #
  my $record_compiler_absolute_path = envVarIsTrue("CTI_COMPILER_ABSOLUTE_PATH");
  for my $var (sort @prunedlist) {
    my $val = getEnvVar($var);

    # record the real path to the compilers into the .env files; they may use soft links pointing, for example, 
    # to some sort of '/.../LATEST/...' moving targets and there is no good to keep recording that every day
    # (what about some other paths ?!: ASM, SIMULATOR, ... )
    if($record_compiler_absolute_path && ($var eq 'CC' || $var eq 'CXX' || $var eq 'FC')) { 
        # and if it's a path like format (starts with '/') and not compiler wrapper call (doesn't have any spaces
        if($val =~ /^\/\S+$/) {
	    $val = Cwd::abs_path($val) || $val; 
        }
    }

    # To get the randomness of the machines in the test level
    # Intercept CTI_COMPILE_HOSTNAME and CTI_RUN_HOSTNAME  - evaluate them if necessary 
    # e.g, CTI_COMPILE_HOSTNAME=`perl -e '@h=qw(mercury yosqa1); print $h[rand @h]'`.caclab.cac.cpqcorp.net
    if (($val =~ /`/) && (($var eq 'CTI_COMPILE_HOSTNAME') || ($var eq 'CTI_RUN_HOSTNAME'))) {
        $val =  qx(echo $val);
	chomp $val;
    }

    #TODO temporary: Intercept {TEST_HOME_DIR}/GROUPS and replace with {CTI_GROUPS}
    if (($val =~ /({TEST_HOME_DIR}\/GROUPS)/)) {
        $val =~  s/$1/{CTI_GROUPS}/g;
    }

    print $fh "export ${var}=\"$val\"\n" if (defined($ENV{$var}) || $var eq 'OPT_LEVEL');

    if ($var eq 'DATA_MODE') {
      my $dm_flag = getDataModeFlag();
      print $fh "export DATA_MODE_FLAG=\"$dm_flag\"\n";
    }
  }

  #
  # Now any additional command line args: EXTRA_CFLAGS, EXTRA_FFLAGS,
  # EXTRA_CXXFLAGS, EXTRA_FLAGS and EXTRA_LIBSS for Applications.
  # They must be the last part of the .env file because they refer
  # to variables like $CC_OPTTIONS.
  #
  for my $var (@_) {
    my $val = getEnvVar($var);
    print $fh "export ${var}=\"$val\"\n" if (defined($ENV{$var}));
  }

  print $fh "\# end saved environment\n";
  print $fh "\#\n";
}


1;

