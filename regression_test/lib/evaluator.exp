#!/usr/bin/expect -f

# Result:  0 - correct;  1 - incorrect
proc validator_evaluator { execfile resultfile runtime_n } {
    global sim
    set runcmd "exec $sim ./$execfile >& $resultfile";
    set result [catch {eval $runcmd}];
    if { $result || [file size $resultfile] != 0 } {
	return 1;
    } else {
	return 0;
    }
}

proc default_evaluator { execfile resultfile runtime_n } {
    upvar $runtime_n runtime
    global sim
    set result [catch {system "(time ($sim ./$execfile >& $resultfile)) 2> __time_info"}];
    set fd [open "__time_info" r];
    while { ![eof $fd] } {
	set line [gets $fd]
	set words [split $line];
	if { [llength $words] == 2 && [string equal -nocase [lindex $words 0] "real"] } {
	    set val [lindex $words 1];
	    set pos0 [string first "m" $val];
	    set pos1 [string first "." $val];
	    set pos2 [string first "s" $val];
	    set val0 [string range $val 0 [expr $pos0 - 1]];
	    set val1 [string range $val [expr $pos0 + 1] [expr $pos1 - 1]];
	    set val2 [string range $val [expr $pos1 + 1] [expr $pos2 - 1]];
	    set runtime [expr $val0 * 60000 + $val1 * 1000 + $val2];
	    break;
	}
    }
    close $fd;
    exec rm __time_info
    if { $result || [file size $resultfile] != 0 } {
	return 1;
    } else {
	return 0;
    }
}

proc cern_evaluator { execfile resultfile runtime_n } {
    upvar $runtime_n runtime
    global sim

    set runcmd "exec $sim ./test$execfile >& $resultfile";
    set result [catch {eval $runcmd}];
    set right 1;
    set fd [open $resultfile r];
    set runtime -1;
    while { ![eof $fd] } {
	set line [gets $fd];
        set line [string trim $line]
	if { [string first "FAIL" $line] >= 0 } {
	    set right 0;
	} elseif { [string match -nocase "time = *" $line] } {
	    set runtime [expr round(1000 * [string range $line 7 [expr [string length $line] - 1]])];
	} elseif { $runtime < 0 && [string is double $line] } {
	    set runtime $line
	}
	
    }
    close $fd;

    if { $result || !$right } {
	return 1;
    } else {
	return 0;
    }
}
