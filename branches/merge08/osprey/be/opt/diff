init.cxx
init.cxx
opt_alias_analysis.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_alias_analysis.cxx,v $
---
> // $Revision: 1.26 $
> // $Date: 05/11/23 14:14:06-08:00 $
> // $Author: gautam@jacinth.keyresearch $
> // $Source: be/opt/SCCS/s.opt_alias_analysis.cxx $
112d111
< #include "pu_info.h"                    // for PU_Info_proc_sym
117d115
< #include "opt_htable.h"
123d120
< #include "opt_points_to_summary.h"
127,130d123
< #include "opt_alias_analysis.h"
< #if defined(TARG_SL)                    // for INTRN_has_no_sideeffect
< #include "intrn_info.h"
< #endif
242d234
<     ai->Invalidate_ptr_info ();
256d247
<         ai->Invalidate_ptr_info ();
284d274
<       ai->Invalidate_ptr_info ();
304d293
< 	ai->Invalidate_ptr_info ();
308,310c297
< 
< 	  if ((alias0.Ofst_kind() == OFST_IS_FIXED || 
< 	       alias0.Iofst_kind() == OFST_IS_FIXED) && alias1.Int_is_constant()) {
---
> 	  if (alias0.Ofst_kind() == OFST_IS_FIXED && alias1.Int_is_constant())
312d298
<           } 
315c301
< 	  if (!ai->Is_field()) {
---
> 	  if (!ai->Is_field())
318,319d303
< 	    ai->Set_iofst_kind(OFST_IS_UNKNOWN);
< 	  }
327,328c311
< 	  if ((alias1.Ofst_kind() == OFST_IS_FIXED ||
< 	       alias1.Iofst_kind() == OFST_IS_FIXED) && alias0.Int_is_constant()) {
---
> 	  if (alias1.Ofst_kind() == OFST_IS_FIXED && alias0.Int_is_constant())
330d312
< 	  }
333c315
< 	  if (!ai->Is_field()) {
---
> 	  if (!ai->Is_field())
336,337d317
< 	    ai->Set_iofst_kind(OFST_IS_UNKNOWN);
< 	  }
340d319
< 	  ai->Invalidate_ptr_info ();
346d324
< 	ai->Invalidate_ptr_info ();
368d345
< 	ai->Invalidate_ptr_info ();
372,373c349
< 	  if ((alias0.Ofst_kind() == OFST_IS_FIXED ||
< 	       alias0.Iofst_kind() == OFST_IS_FIXED) && alias1.Int_is_constant()) {
---
> 	  if (alias0.Ofst_kind() == OFST_IS_FIXED && alias1.Int_is_constant())
375c351
< 	  } else {
---
> 	  else
377,378d352
< 	    ai->Set_iofst_kind(OFST_IS_UNKNOWN);
< 	  }
387d360
< 	ai->Invalidate_ptr_info ();
392d364
< 	ai->Invalidate_ptr_info ();
441d412
<     ai->Invalidate_ptr_info ();
450d420
<     ai->Invalidate_ptr_info ();
456,497d425
< // Return true iff the PREG if given version is the return
< // value of malloc-like function. This is helper function 
< // of OPT_STAB::Simplify_Pointer_Ver().
< //
< BOOL OPT_STAB::Its_ret_val_of_malloc (VER_ID ver_id) {
< 
<   VER_STAB_ENTRY* ver = Ver_stab_entry (ver_id);
<   if (ver->Type () != CHI_STMT) { return FALSE; }
< 
<   // check to see whether the corresponing variable is dedicated PREG.
<   AUX_STAB_ENTRY* aux = Aux_stab_entry(ver->Aux_id());
<   if (!aux->Is_dedicated_preg ()) { return FALSE; }
<   
<   // check to see whehter the definition is a call
<   WN* call = ver->Chi_wn();
<   if (WN_operator (call) != OPR_CALL) { return FALSE; }
< 
<   // check to see whether it is malloc-like func
<   ST* call_st = WN_st(call);
<   if (!PU_has_attr_malloc(Pu_Table[ST_pu(call_st)])) {
<     return FALSE;
<   }
< 
<   // setup return preg. Later we will need to enter this into chi list
<   if (WHIRL_Return_Info_On) {
<     RETURN_INFO return_info = 
<       Get_Return_Info (MTYPE_To_TY(WN_rtype(call)), 
<                        Allow_sim_type() ? Use_Simulated : 
<                        Complex_Not_Simulated
<                        #ifdef TARG_X8664
<                        ,call_st ? PU_ff2c_abi(Pu_Table[ST_pu(call_st)]) : FALSE 
<                        #endif
<                        );      
< 
<       if (RETURN_INFO_count(return_info) == 1 &&
<           RETURN_INFO_preg (return_info, 0) == aux->St_ofst()) {
<          return TRUE; 
<       }
<     }
<     
<     return FALSE;
< }
504,505d431
<   PT_MEMOP_ANNOT_STIKER mem_annot_stiker(ai);
< 
508,509d433
<   AUX_ID  aux_id = Ver_stab_entry(ver)->Aux_id();
<   ST* st = Aux_stab_entry (aux_id)->St ();
524d447
<       ai->Invalidate_ptr_info ();
534,535c457
< 	ai->Set_base((ST*)(INTPTR)ver);
< 	ai->Invalidate_ptr_info ();
---
> 	ai->Set_base((ST*)ver);
545,554c467
< 	ai->Set_base((ST*)(INTPTR)ver);
< 	if (st) {
<  	  if (ST_class(st) != CLASS_PREG){
< 	    ai->Set_pointer (st);
< 	  } else {
< 	    ai->Set_pointer_as_aux_id (aux_id);
< 	  }
< 	  ai->Set_pointer_ver (ver);
< 	  ai->Set_iofst_kind (OFST_IS_FIXED);
< 	}
---
> 	ai->Set_base((ST*)ver);
644,682d556
< 
<       if (summary_pt.Expr_kind () == EXPR_IS_ADDR && 
<           (summary_pt.Base_kind () == BASE_IS_UNKNOWN ||
<            summary_pt.Ofst_kind () != OFST_IS_FIXED) &&
<            WOPT_Enable_Pt_Keep_Track_Ptr) {
<         if (Get_Trace(TP_GLOBOPT, ALIAS_DUMP_FLAG)) {
<           fprintf (TFile, "phi result ver %d BB %d aux %d: ", ver, bb->Id(), 
<                    Ver_stab_entry(ver)->Aux_id());
<           summary_pt.Print(TFile);
<           fprintf(TFile, "this result is not very useful, and is changed into: ");
<         }
< 	PT_MEM_ANNOT mem_annot_saved = summary_pt.Mem_annot();
<          // The result is virtuall useless. Following setting may provide more info.
<         summary_pt.Init ();
<         summary_pt.Set_expr_kind(EXPR_IS_ADDR);
<         summary_pt.Set_base_kind(BASE_IS_DYNAMIC);
<         summary_pt.Set_ofst_kind(OFST_IS_FIXED);
<         summary_pt.Set_byte_ofst(0);
<         summary_pt.Set_byte_size(0);
<         summary_pt.Set_bit_ofst_size(0, 0);
<         summary_pt.Set_base((ST *)phi);
<         if (st) {
<           if (ST_class(st) != CLASS_PREG){
<             summary_pt.Set_pointer (st);
<           } else {
<             summary_pt.Set_pointer_as_aux_id (aux_id);
<           }
<         }
<         summary_pt.Set_pointer_ver (ver);
<         summary_pt.Set_iofst_kind (OFST_IS_FIXED);
< 	if (mem_annot_saved.Has_annotation ()) {
< 	  PT_MEM_ANNOT& t = summary_pt.Mem_annot();
< 	  t = mem_annot_saved ;
< 	}
<         if (Get_Trace(TP_GLOBOPT, ALIAS_DUMP_FLAG)) {
<           summary_pt.Print (TFile);
<         }
<       }
<          
712,729d585
< 
<       if (WOPT_Enable_Pt_Summary && st && ST_class(st) != CLASS_PREG) {
<         WN* stmt = Ver_stab_entry(ver)->Chi_wn(); 
<         if (WN_operator(stmt) == OPR_CALL) {
< 	   // TODO: check call's side effect here 
< 	} else if (OPERATOR_is_scalar_istore (WN_operator(stmt))) {
< 	  // check to see whether alias indeed happens
<           POINTS_TO* ptr = Aux_stab_entry(aux_id)->Points_to(); 
<           POINTS_TO* istore = Get_occ(stmt)->Points_to();
< 	  
<           if (ptr && istore && !Rule()->Aliased_Memop (ptr, istore)) {
< 	    // ignore this one, go along the U-D chain
<             Simplify_Pointer_Ver(chi->Opnd(), ai);
< 	    break;
< 	  }
< 	}
<       }
< 
737,754d592
<       if (st) {
<         if (ST_class(st) != CLASS_PREG){
<           ai->Set_pointer (st);
<         } else {
<           ai->Set_pointer_as_aux_id (aux_id);
<           if (Its_ret_val_of_malloc (ver)) {
<            VER_STAB_ENTRY* verent = Ver_stab_entry(ver);
<            ai->Set_malloc_id (WN_linenum(verent->Chi_wn()));
<           }
<         }
<         ai->Set_pointer_ver (ver);
<         ai->Set_iofst_kind (OFST_IS_FIXED);
< 
<         pt = CXX_NEW(POINTS_TO, &_ver_pool);
<         pt->Init();
<         pt->Copy_fully(ai);
<         Ver_stab_entry(ver)->Set_points_to(pt);
<       }
774,776d611
< 
<   PT_MEMOP_ANNOT_STIKER t(ai);
< 
782d616
<     ai->Invalidate_ptr_info (); 
800c634
<       } else {
---
>       } else
802d635
<       }
832,833d664
<   
< 
911,915d741
<   TY_IDX hl_ty = 0; 
<   UINT32 fld_id = 0;
<   WN_hl_object_ty (wn, hl_ty, fld_id); 
<   pt->Set_hl_ty (hl_ty);
<   pt->Set_field_id (fld_id);
950d775
<         pt->Copy_pointer_info (&ai);
956,958d780
<       if (ai.Malloc_id()) {
<         pt->Set_malloc_id (ai.Malloc_id());
<       }
977d798
<         pt->Copy_pointer_info (&ai);
983,985d803
<       if (ai.Malloc_id()) {
<         pt->Set_malloc_id (ai.Malloc_id());
<       }
2156d1973
< 	  (pt->Expr_kind() == EXPR_IS_ADDR && pt->Ofst_kind() == OFST_IS_UNKNOWN) ||
2159d1975
< 
2233,2241d2048
<       if (occ->Points_to()->Pointer () != NULL) {
< 	// TODO: We need adjust the offset and access size for MTYPE_BS.
< 	//   give up for the time being.
< 	if (WN_desc (wn) != MTYPE_BS) {
< 	  occ->Points_to()->Set_byte_size (WN_object_size(wn));
< 	} else {
< 	  occ->Points_to()->Invalidate_ptr_info ();
< 	}
<       }
2270,2278d2076
<       if (occ->Points_to()->Pointer () != NULL) {
<         // TODO: We need adjust the offset and access size for MTYPE_BS. 
<         //   give up for the time being.
<         if (WN_desc (wn) != MTYPE_BS) {
<           occ->Points_to()->Set_byte_size (WN_object_size(wn));
<         } else {
<           occ->Points_to()->Invalidate_ptr_info ();
<         }
<       }
2391a2190
> 
3073,3093d2871
< #if defined(TARG_SL)
<       // for intrinsic function which has no side effect and 
<       // is pure function we needn't add chi for it. 
<       else if( opr == OPR_INTRINSIC_CALL && 
< 	 WN_intrinsic(wn) &&
< 	 INTRN_is_pure(WN_intrinsic(wn)) && 
<   	 INTRN_has_no_side_effects(WN_intrinsic(wn)) && 
< 	 (WN_intrinsic(wn) >= INTRN_SL2_BEGIN && WN_intrinsic(wn) <= INTRN_SL2_END))
<       {
< 	 for (INT32 i = 0; i < WN_kid_count(wn); i++) {
<            occ = Get_occ(WN_kid(wn, i));
< 	    if (occ != NULL) {
< 	      vp_idx = occ->Aux_id(); 
< 	      occ->New_mem_mu_node(vp_idx, Occ_pool()); 
< 	      if (aux_stab[vp_idx].Aux_id_list() == NULL) 
< 	        Update_aux_id_list(vp_idx);
< 	   }
<         }
<         break;
<      }
< #endif 
3684c3462
<   if (Default_vsym() != 0) {
---
>   if (Default_vsym() != 0) 
3686,3687d3463
<     Aux_stab_entry(Default_vsym())->Points_to()->Set_hl_ty(0);
<   }
3689c3465
<   if (Return_vsym() != 0) {
---
>   if (Return_vsym() != 0) 
3691,3692d3466
<     Aux_stab_entry(Return_vsym())->Points_to()->Set_hl_ty(0);
<   }
3715d3488
<     Cr_sr_annot_mgr()->Print (TFile); 
4162,4539d3934
< // Bind given individual pointer and its points-to set with symbols 
< // visible from current lexical scope. 
< //
< void
< OPT_PU_POINTS_TO_SUMMARIZER::Bind_callee_points_to_summary 
<   (UNIFORM_NAME* ptr, PT_SET_MGR* pt_mgr, PT_SET_MGR* bound_pt_mgr) {
< 
<   PT_SET* pt_set = pt_mgr->Points_to_set (ptr);
< 
<   Is_True (ptr->Type () == UN_NAMED_GLOBAL, 
<            ("Currently we only handle global named pointer"));
<   Is_True (!pt_set->Has_unknown_pt(), 
<            ("Currently we can handle only points-to pointing to" 
<             "named objects"));
<                     
<   UNAME_SPACE* bound_name_space = bound_pt_mgr->Name_space ();
< 
<   // duplicate the name
<   UNIFORM_NAME* bound_ptr = 
<     bound_name_space->Add_global(ptr->ST_for_named_global());
<         
<   // duplicate and bound the points-to set.
<   PT_SET* bound_pt_set = CXX_NEW(PT_SET(*pt_set, Mem_pool()), Mem_pool());
<   bound_pt_mgr->Associate (bound_ptr, bound_pt_set);
< }
< 
< //
< // OPT_PU_POINTS_TO_SUMMARIZER::Bind_callee_points_to_summary() 
< //   bind callee's points-to summary the symbols visible to current PU. 
< // 
< // NOTE: this should be done before any alias analysis so that that 
< //  information can be used to improve the precision. 
< //
< void
< OPT_PU_POINTS_TO_SUMMARIZER::Bind_callee_points_to_summary (WN* entry_wn) {
< 
<   if (WOPT_Enable_Pt_Summary) {
<     if (Tracing()) {
<       fprintf (TFile, "\nBegin backward points-to binding\n"); 
<     }
< 
<     INT idx = 0;
<     for (WN_ITER* wni = WN_WALK_StmtIter (entry_wn);
<          wni != NULL; wni = WN_WALK_StmtNext (wni)) {
<        WN* call = WN_ITER_wn(wni);
<        if (WN_operator (call) != OPR_CALL) {
<          continue;
<        }
<  
<        if (Tracing()) {
<          fprintf (TFile, "CALL SITE %2d: ", idx++);
<          fdump_wn (TFile, call); 
<        }
< 
<        PU_POINTS_TO_SUMMARY* sum = Get_points_to_summary (WN_st(call));  
<        if (!sum) {
<          if (Tracing()) {
<            fprintf (TFile, "points-to summary is not found\n");
<          }
<          continue;
<        }
< 
<        PT_SET_MGR& pt_mgr = sum->Out_set ();
<        UNAME_SPACE* ptrs = pt_mgr.Name_space();
<        if (ptrs->Cardinality () == 0) {
<          // No points-to are recorded
<          continue;
<        }
<        
<        PU_POINTS_TO_SUMMARY* bound_sum = 
<          CXX_NEW(PU_POINTS_TO_SUMMARY(Mem_pool()), Mem_pool());
<        Set_bound_pt_sum (call, bound_sum); 
< 
<        UNAME_SPACE* bound_name_space = bound_sum->Out_set().Name_space();
< 
<        // looping over all pointers which has points-to relationship 
<        for (UNAME_VECTOR_ITER ptr_iter = ptrs->All_names().begin (); 
<             ptr_iter != ptrs->All_names().end (); ptr_iter ++) {
< 
<          UNIFORM_NAME* ptr = *ptr_iter;
<          Bind_callee_points_to_summary (ptr, &pt_mgr, &bound_sum->Out_set());
<        }
< 
<        if (Tracing()) {
<          bound_sum->Print (TFile);
<        }
< 
<     } // end of for-statement
< 
<     if (Tracing()) {
<       fprintf (TFile, "End of backward points-to binding\n\n"); 
<     }
<   }
< }
< 
< 
< // helper function of Annotate_points_to_summary(void)
< //
< void
< OPT_PU_POINTS_TO_SUMMARIZER::Annotate_points_to_summary 
<   (UNIFORM_NAME* ptr, PT_SET_MGR* pt_set_mgr, CHI_LIST* chi_list) {
< 
<   if (ptr->Type () == UN_NAMED_GLOBAL) {
<     POINTS_TO pt; 
<     pt_set_mgr->Points_to_set (ptr)->Meet (&pt);
< 
<     if (pt.Expr_kind() != EXPR_IS_INVALID) {
<       ST* st = ptr->ST_for_named_global ();  
<       CHI_NODE* cnode;
<       CHI_LIST_ITER chi_iter;
< 
<       FOR_ALL_NODE (cnode, chi_iter, Init(chi_list)) {
<         if (Opt_stab()->St(cnode->Aux_id()) == st) {
<           POINTS_TO* new_pt = CXX_NEW(POINTS_TO, Opt_stab()->Ver_pool());
<           new_pt->Copy_fully (pt);
< 
<           VER_ID ver = cnode->Result();  
<           Opt_stab()->Ver_stab_entry(ver)->Set_points_to(new_pt);
<          
<           if (Tracing()) {
<             const char* indent = " ";
<             fprintf (TFile, "%schi(%s) v%d<=%d\n%s", indent,
<                      ST_name(st), cnode->Result(), cnode->Opnd(), indent);
<             new_pt->Print(TFile);
<           }
<         }
<       }
<     }
<   }
< }
< 
< // Annotate_points_to_summary()
< //   Annotate the points-to relationship to the CHI node associated
< //   with each call-site. 
< //  
< //   This function should be called after MU and CHI are inserted 
< // properly and before flow-sensitive sense pointer-analysis so that
< // pointer-analysis can take advantage of annotated information. 
< // 
< void
< OPT_PU_POINTS_TO_SUMMARIZER::Annotate_points_to_summary (void) {
<   
<   CFG_ITER cfg_iter;
<   BB_NODE* bb;
< 
<   if (Tracing()) {
<     fprintf (TFile, "\nBegin annotating points-to summary\n%s", DBar);
<   }
< 
<   FOR_ALL_ELEM (bb, cfg_iter, Init(Opt_stab()->Cfg())) {
<     WN* stmt; 
<     STMT_ITER stmt_iter;
< 
<     FOR_ALL_ELEM (stmt, stmt_iter, Init(bb->Firststmt(), bb->Laststmt())) {
<       if (WN_operator(stmt) != OPR_CALL) continue;
< 
<       if (Tracing()) {
<         fprintf (TFile, "CALL SITE ");
<         fdump_wn (TFile, stmt);
<       }
< 
<       PU_POINTS_TO_SUMMARY* sum = Get_bound_pt_sum (stmt);
<       if (!sum) continue;
<       UNAME_VECTOR& ptrs = sum->Out_set().Name_space()->All_names();  
< 
<       CHI_LIST* chi_list = Opt_stab()->Get_generic_chi_list (stmt);       
< 
<       // looping over all pointers
<       for (UNAME_VECTOR_ITER pt_iter = ptrs.begin (); 
<            pt_iter != ptrs.end (); pt_iter++) {
<          Annotate_points_to_summary (*pt_iter, &sum->Out_set(), chi_list);
<       }
<     } // end of FOR_ALL_STMT 
<   }
< 
<   if (Tracing()) {
<     fprintf (TFile, "\nEnd annotating points-to summary\n%s", DBar);
<   }
< }
< 
< // OPT_STAB::Summarize_points_to () -- helper function of 
< // void PU_POINTS_TO_SUMMARY::Summarize (void)
< // 
< void
< OPT_PU_POINTS_TO_SUMMARIZER::Summarize_points_to 
<   (VER_ID ver, OPT_PU_POINTS_TO_SUMMARIZER::VER_ID_VISIT_CNT& visited, 
<    PT_SET& pt_set) {
< 
<   POINTS_TO *pt = Opt_stab()->Ver_stab_entry(ver)->Points_to();
<   if (pt && PU_POINTS_TO_SUMMARY::Pt_known_obj (pt)) {
<     pt_set.Add_points_to (pt, PTC_DEFINITE, PT_MUST_POINTS_TO);
<     return;
<   }
< 
<   // go along the U-D chain
<   STMT_TYPE vtype = Opt_stab()->Ver_stab_entry(ver)->Type();
<   AUX_ID  aux_id = Opt_stab()->Ver_stab_entry(ver)->Aux_id();
<   ST* st = Opt_stab()->Aux_stab_entry (aux_id)->St ();
< 
<   // Set this verion is visited 
<   visited.Set_visited(ver);
< 
<   switch (vtype) {
<   case ENTRY_STMT:
<     {
<       // TODO: take into account the points-to hold at the entry points
<       break;
<     }
< 
<   case WHIRL_STMT:
<     {
<       POINTS_TO* pt = Opt_stab()->Ver_stab_entry(ver)->Points_to();
<       if (!pt) {
<         POINTS_TO points_to; 
<         points_to.Init ();
<         Opt_stab()->Simplify_Pointer_Ver (ver, &points_to);
<         pt = Opt_stab()->Ver_stab_entry(ver)->Points_to();
<       }
< 
<       Is_True (pt != NULL, ("points-to for version %d is NULL", ver));
<       if (PU_POINTS_TO_SUMMARY::Pt_known_obj (pt)) {
<         pt_set.Add_points_to (pt, PTC_DEFINITE, PT_MUST_POINTS_TO);
<         return;
<       }
<     }
<     break;
< 
<   case PHI_STMT:
<     {
<       BB_NODE *pred;
<       BB_LIST_ITER bb_iter;
<       BB_NODE *bb = Opt_stab()->Ver_stab_entry(ver)->Bb();
<       PHI_NODE *phi = Opt_stab()->Ver_stab_entry(ver)->Phi();
< 
<       INT i=0;
<       FOR_ALL_ELEM (pred, bb_iter, Init(bb->Pred())) {
<         VER_ID opnd_vid = phi->Opnd(i++);
<         if (visited.Visited(opnd_vid)) {
<           continue;
<         }
<         Summarize_points_to (opnd_vid, visited, pt_set);
<         if (pt_set.Has_unknown_pt ()) {
<           break;
<         }
<       }
<     }
<     return;
< 
<   case CHI_STMT:
< 
<     // Bypass the CHI_STMT if the chi statement is deleted.
<     if (!Opt_stab()->Ver_stab_entry(ver)->Synonym()) {
<       VER_STAB_ENTRY* ver_ent = Opt_stab()->Ver_stab_entry(ver);
<       WN* chi_wn = ver_ent->Chi_wn();
<       if (WN_operator(chi_wn) == OPR_CALL) {
<         ST* call_st = WN_st (chi_wn);
<         if (call_st) {
<           const char* st_name = ST_name(call_st);
<           if (!strcmp (st_name, "exit")) {
<            // TODO: propatage __attribute__((noreturn)) from front-end
<             return; // simply ignore them
<           } else if (!strcmp (st_name, "malloc") || 
<                      !strcmp (st_name, "fprintf") ||
<                      !strcmp (st_name, "printf")) {
<             // omit the chi node, go ahead along the U-D chain  
<             // TODO: - describe side-effect of some libc funtion
<             //       - get rid of this chi as early as Compute_FFA  
<             Summarize_points_to (ver_ent->Chi()->Opnd(), visited, pt_set); 
<             return;
<           }
<         }
<       } else if (OPERATOR_is_scalar_istore (WN_operator(chi_wn))) {
<         // check to see whether the 
<         POINTS_TO* ptr = 
<           Opt_stab()->Aux_stab_entry(ver_ent->Aux_id())->Points_to(); 
<         POINTS_TO* istore = Opt_stab()->Get_occ(chi_wn)->Points_to();
<           
<         if (ptr && istore &&
<             !Opt_stab()->Rule()->Aliased_Memop (ptr, istore)) {
<           // ignore this one, go along the U-D chain
<           Summarize_points_to (ver_ent->Chi()->Opnd(), visited, pt_set); 
<           return;
<         }
<       }
<     } else {
<       VER_ID synonym = Opt_stab()->Ver_stab_entry(ver)->Synonym();
<       if (!visited.Visited (ver)) {
<         Summarize_points_to (synonym, visited, pt_set); 
<         return;
<       }
<     } 
<     break;
<   default:
<     Warn_todo("unknown ver type");
<   }
<   
<   pt_set.Set_has_unkown_pt ();
< }
< 
< void
< OPT_PU_POINTS_TO_SUMMARIZER::Summarize_points_to (void) {
< 
<   MEM_POOL_Popper popper(&MEM_local_pool);
< 
<   BB_NODE* exit_bb = Opt_stab()->Cfg()->Fake_exit_bb() ? 
<                      Opt_stab()->Cfg()->Fake_exit_bb() : 
<                      Opt_stab()->Cfg()->Exit_bb ();
<   
<   WN* wn = exit_bb->Laststmt ();
<   if (wn == NULL || 
<       WN_operator (wn) != OPR_RETURN && WN_operator (wn) != OPR_RETURN_VAL) {
<     return;
<   }
< 
<   MU_LIST_ITER mu_iter;
<   MU_NODE* mnode;
< 
<   // Looping over all global pointers inluding:
<   //    - those that are accessed within current PU, and 
<   //    - those whose points-to relationship are annotated to 
<   //      a call-site in current PU. 
<   //
<   // We begin with the MU-node associated with the RETURN statement, 
<   // and walk along U-D chain all the way down to the entry.
<   // 
<   FOR_ALL_NODE (mnode, mu_iter, Init(Opt_stab()->Get_stmt_mu_list(wn))) {
<     ST* st = Opt_stab()->St(mnode->Aux_id());
< 
<     // For now, we only consider named global pointer
<     if (!st || TY_kind(ST_type(st)) != KIND_POINTER || 
<         ST_sclass (st) == SCLASS_PSTATIC) {
<       continue;
<     }
<     VER_ID ver = mnode->Opnd();
< 
<     PT_SET pt_set(popper.Pool()); 
<     OPT_PU_POINTS_TO_SUMMARIZER::VER_ID_VISIT_CNT visited (popper.Pool());
<     Summarize_points_to (ver, visited, pt_set);
<     
<     if (pt_set.Has_unknown_pt () || pt_set.Certainty() != PTC_DEFINITE) {
<       // give up since it virtually does not help out
<       continue;
<     }
<     
<     PT_SET_MGR& pt_set_mgr = Pu_summary()->Out_set ();
<     UNIFORM_NAME* uname = pt_set_mgr.Add_global(st);
<     PT_SET* old_pt_set = pt_set_mgr.Points_to_set (uname);  
<     if (old_pt_set == NULL) {
<       PT_SET* t = CXX_NEW (PT_SET(pt_set, pt_set_mgr.Mem_pool()), 
<                            pt_set_mgr.Mem_pool());
<       pt_set_mgr.Associate (uname, t);
<     } else {
<       old_pt_set->Copy (pt_set);
<     }
<   }
< }
< 
< void
< OPT_STAB::Summarize_points_to (void) {
< 
<   PU_POINTS_TO_SUMMARY* sum = _pt_sum.Pu_summary ();
<   if (sum == NULL) {
<     sum = Allocate_PU_Points_To_Summary ();
<     FmtAssert (sum != NULL, 
<                ("fail to allocate data structure for points-to summary"));
<     _pt_sum.Set_pu_summary (sum);
<   }
<   
<   _pt_sum.Summarize_points_to ();
<   if (Get_Trace (TP_WOPT2, PT_SUMMARY_FLAG)) {
<     fprintf (TFile, "Points-to summary for PU %s\n%s", 
<              ST_name(PU_Info_proc_sym(Current_PU_Info)), DBar);
<     sum->Print (TFile);
<     fprintf (TFile, DBar); // to mark the end
<   }
< }
< 
< 
4566d3960
< 
opt_alias_analysis.cxx
opt_alias_class.cxx
3a4,7
>  * Copyright (C) 2007 PathScale, LLC.  All Rights Reserved.
>  */
> 
> /*
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_alias_class.cxx,v $
---
> // $Revision: 1.14 $
> // $Date: 05/11/17 13:55:58-08:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_alias_class.cxx $
1212d1215
< 
1222d1224
<     BOOL expr_maybe_point = Expr_may_contain_pointer (expr);
1229,1230d1230
<       if (expr_maybe_point && 
<           Expr_may_contain_pointer (WN_kid(expr, i))) {
1232a1233
> 
1235d1235
<     }
1309,1404d1308
< // return TURE if the <expr> may "encode" a pointer value.
< // TODO: This function is too conservative. It need to be polished. 
< //
< BOOL
< ALIAS_CLASSIFICATION::Expr_may_contain_pointer (WN* const expr) {
<    
<   if (!WOPT_Enable_Aggressive_Alias_Classification || !Alias_Pointer_Types) {
<     return TRUE;
<   }
< 
<   TYPE_ID res = WN_rtype (expr); 
<   if (MTYPE_byte_size (res) == 0) {
<     // The <res> can be TYPE_M which may contain pointer. 
<     // TODO:: A better solution is to take a closer look of what in 
<     //   the MTYPE_M. However, the fix is done at the last minute of 
<     //   2.1 release. OTOH, some functions don't work with MTYPE_M, 
<     //   say WN_object_size() may return 0 when the object of MTYPE_M. 
<     //   We have to be conservative at this moment.
<     return TRUE;
<   }
< 
<   if (MTYPE_byte_size (res) < Pointer_Size ||
<       (MTYPE_is_void (res)    || MTYPE_is_float (res) || 
<        MTYPE_is_complex (res) || MTYPE_is_vector (res) || 
<        MTYPE_is_boolean (res))) {
<      return FALSE;
<   }
<    
<   switch (WN_operator (expr)) {
<   case OPR_MPY:
<     return FALSE;
< 
<   case OPR_LDBITS:
<   case OPR_ILDBITS:
<     return WN_bit_size (expr) < Pointer_Size * 8;
< 
<   case OPR_LDID:
<     {
<     ST* sym = ST_of_wn (expr);
<     return ST_class(sym) != CLASS_PREG && 
<            TY_kind(WN_object_ty (expr)) == KIND_POINTER ||
<            WN_object_size (expr) >= Pointer_Size;
<     }
<   case OPR_ILOAD:
<     return TY_kind(WN_object_ty (expr)) == KIND_POINTER ||
<            WN_object_size (expr) >= Pointer_Size;
< 
<   case OPR_NEG: case OPR_ABS:
<     return Expr_may_contain_pointer (WN_kid0(expr));
< 
<   case OPR_RND: 
<   case OPR_TRUNC:
<   case OPR_CEIL:
<   case OPR_FLOOR:
<   case OPR_BNOT:
<   case OPR_LNOT:
<     return FALSE;
<   }
< 
<   return TRUE;
< }
< 
< BOOL
< ALIAS_CLASSIFICATION::Assignment_may_xfer_pointer (WN* const stmt) {
< 
<   if (!WOPT_Enable_Aggressive_Alias_Classification || !Alias_Pointer_Types) {
<     return TRUE;
<   }
< 
<   if (!Expr_may_contain_pointer (WN_kid0(stmt))) {
<     return FALSE;
<   }
< 
<   TY_IDX obj_ty = WN_object_ty (stmt);
<   switch (TY_kind(obj_ty)) {
<   case KIND_SCALAR:
<     return WN_object_size(stmt) >= Pointer_Size; 
< 
<   case KIND_STRUCT:
<     // TODO: this should be refined.
< 
<   case KIND_POINTER:
<     return TRUE;
< 
<   case KIND_ARRAY:
<     return TRUE;
< 
<   case KIND_VOID:
<     return WN_object_size (stmt) && (WN_object_size (stmt) >= Pointer_Size);
< 
<   default:
<     Is_True (FALSE, ("Unexected results returned from WN_object_ty ()"));
<   }
< 
<   return TRUE;
< }
1420,1422c1324
<   TY_IDX rhs_obj_ty = WN_object_ty (rhs);
<   AC_PTR_OBJ_PAIR rhs_class = Classify_deref_of_expr(rhs, 
<                                  TY_kind(rhs_obj_ty) == KIND_POINTER);
---
>   AC_PTR_OBJ_PAIR rhs_class = Classify_deref_of_expr(rhs, FALSE);
1438,1439c1340
<   if (rhs_class.Ref_class() != NULL && 
<       Assignment_may_xfer_pointer (stmt)) {
---
>   if (rhs_class.Ref_class() != NULL) {
1503c1404
< #if 1
---
> #if 0
1570,1571c1471
< 	(strcmp("_F90_ALLOCATE", ST_name(st)) == 0) ||
<         WOPT_Enable_Disambiguate_Heap_Obj && PU_has_attr_malloc (Pu_Table[ST_pu(st)])) {
---
> 	(strcmp("_F90_ALLOCATE", ST_name(st)) == 0)) {
1907c1807
<                                  TY_kind (WN_ty(parm_wn)) == KIND_POINTER);
---
> 						       FALSE);
opt_alias_class.cxx
opt_base.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_base.cxx,v $
---
> // $Revision: 1.8 $
> // $Date: 05/04/15 19:24:10-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_base.cxx $
opt_base.cxx
opt_bb.cxx
3a4,7
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
> /*
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_bb.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:16-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_bb.cxx $
69c73
< static char *rcs_id = 	opt_bb_CXX"$Revision: 1.1.1.1 $";
---
> static char *rcs_id = 	opt_bb_CXX"$Revision: 1.5 $";
1256,1281d1259
< BB_NODE::PrintVis (void) const
< {
<   BB_LIST_ITER bb_succ_iter(Succ());
<   BB_NODE *succ;
<   WN * wn;
< 
< #ifdef TARG_NVISA
<   // mark the blocks with __synchthreads as red
<   STMT_ITER stmt_iter;
<   FOR_ALL_ELEM(wn, stmt_iter, Init(Firststmt(), Laststmt())) {
<     INTRINSIC id;
<     if (WN_operator(wn) == OPR_INTRINSIC_CALL) {
<       id = WN_intrinsic(wn);
<       if (id == INTRN_SYNCHRONIZE) {
< 	fprintf(stdout, "BB%d[color=red]\n", Id());
< 	break;
<       }
<     }
<   }
< #endif
<   FOR_ALL_ELEM(succ, bb_succ_iter, Init()) {
<     fprintf(stdout, "  BB%d -> BB%d\n", Id(), succ->Id());
<   }
< }
< 
< void
1308d1285
< 
opt_bb.cxx
opt_bdce.cxx
0a1,7
> /*
>  * Copyright 2008 PathScale, LLC.  All Rights Reserved.
>  */
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
11,14c18,21
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_bdce.cxx,v $
---
> // $Revision: 1.40 $
> // $Date: 05/10/27 14:00:53-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_bdce.cxx $
182c189
< BITWISE_DCE::Bitmask_of_size(UINT64 vsize)
---
> BITWISE_DCE::Bitmask_of_size(INT32 vsize)
1057,1062c1064
<     if (aux->Is_dedicated_preg()) {
< #ifdef TARG_SL 
<        if ((sign_xtd == opnd->Is_sign_extd()) && (from_bit >=  MTYPE_size_min(opnd->Dsctyp()))) {
<           return TRUE; 
<        }
< #endif
---
>     if (aux->Is_dedicated_preg())
1064d1065
<     }
1068d1068
<               // begin - fix for OSP_209
1070d1069
<               // end   -
1082,1089c1081
<       // bug fix for OSP_140
<       else if (opnd->Defstmt() && 
<                // begin - fix for OSP_209
< 	           opnd->Defstmt()->Rhs())
<                // end   -
<         return Redundant_cvtl(sign_xtd, to_bit, from_bit, opnd->Defstmt()->Rhs());
<       else
< 	return FALSE;
---
>       else return Redundant_cvtl(sign_xtd, to_bit, from_bit, opnd->Defstmt()->Rhs());
1182,1191d1173
< #ifdef TARG_SL
<     case OPR_INTRINSIC_OP:
<       if (from_bit == 16 && to_bit == 32) {
<         return TRUE;
<       }
<     case OPR_ASHR:
<       if (from_bit >= MTYPE_size_min(opnd->Dsctyp())) {
<         return TRUE;
<       }
< #endif
1233d1214
< #ifndef TARG_NVISA
1240d1220
< #endif
1349,1351c1329
< // NVISA: leave converts as they are represented by different size registers.
< // Revisit this if ever allow I1 or I2 CVT which would use same register.
< #if !defined(TARG_IA32) && !defined(TARG_NVISA)
---
> #ifndef TARG_IA32
1372,1373c1350
< #if !defined(TARG_MIPS) && !defined(TARG_X8664)  && !defined(TARG_NVISA)
<         // undeletable since garbage in high bits untolerable
---
> #if !defined(TARG_MIPS) && !defined(TARG_X8664) // undeletable since garbage in high bits untolerable
1497,1522d1473
< #if defined(TARG_SL)
< void 
< BITWISE_DCE::Repair_Injured_AuxIntrnOP(void) {
<   CFG_ITER cfg_iter(Cfg());
<   BB_NODE *bb;
<   FOR_ALL_NODE( bb, cfg_iter, Init() ) {
<     STMTREP_ITER stmt_iter(bb->Stmtlist());
<     STMTREP *stmt;
<     FOR_ALL_NODE(stmt, stmt_iter, Init()) {
<       if (stmt->Live_stmt())
<         continue;	
<       if (stmt->Opr() == OPR_STID) {
<         if (CR_Intrinsic_Op_Slave(stmt->Rhs())) {
<           CODEREP *parm2cr = stmt->Rhs()->Opnd(0);	// first parameter
<           Is_True(parm2cr->Kind() == CK_IVAR, ("kid of intrinsic op is parm"));
<           CODEREP *op2cr = parm2cr->Ilod_base();
<           if (op2cr && (Livebits(op2cr) > 0))
<             Mark_entire_var_live(stmt->Lhs(), FALSE);
<         }
<       }	
<     }
<   }
<   return;
< }
< #endif
< 
1549,1554c1500
< #if defined(TARG_SL)
<   Repair_Injured_AuxIntrnOP();
< #endif
< 
< // NVISA:  not sure what problem is, but it breaks cgemm so ifdef for now
< #if !defined(KEY) || defined(TARG_NVISA)  // bug 8499
---
> #ifndef KEY // bug 8499
opt_bdce.cxx
opt_bool.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_bool.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_bool.cxx
opt_canon.cxx
3a4,7
>  * Copyright (C) 2007 PathScale, LLC.  All Rights Reserved.
>  */
> 
> /*
10,13c14,17
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_canon.cxx,v $
---
> // $Revision: 1.8 $
> // $Date: 05/01/22 01:02:59-08:00 $
> // $Author: fchow@fluorspar.keyresearch $
> // $Source: be/opt/SCCS/s.opt_canon.cxx $
108,110d111
< #if defined(TARG_SL) || defined(TARG_NVISA)
<        Tree(), htable->Add_const(typ, Scale()));
< #else
112d112
< #endif
118,123d117
<   // PathScale forced a I8 type here,
<   // but we want smaller type when don't have native I8,
<   // and this is what original code had.
< #if defined(TARG_SL) || defined(TARG_NVISA)
<   CODEREP *cr =  htable->Add_const(typ, Scale());
< #else
125d118
< #endif
opt_canon.cxx
opt_cfg.cxx
1,3c1
< /*
<  * Copyright 2005-2008 Simplight NanoElectronics Ltd.  All rights reserved.
<  */
---
> //-*-c++-*-
6c4
<  * Copyright 2005-2007 NVIDIA Corporation.  All rights reserved.
---
>  * Copyright (C) 2007 PathScale, LLC.  All Rights Reserved.
8,10d5
< 
< //-*-c++-*-
< 
23,26c18,21
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_cfg.cxx,v $
---
> // $Revision: 1.30 $
> // $Date: 05/09/27 18:47:04-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_cfg.cxx $
264c259
< 
---
> #ifdef KEY
409c404
< 
---
> #endif
874,891d868
< // There will be lot of troubles if the preheader is not "dedicated",
< // meaning the preheader is intermingled with the statements of the 
< // loop and other statements.
< //
< // This is especially true for loop multiversioning which duplicate 
< // not only loop body but also the preheader. The purpose of dup 
< // preheader is simply to make emiter happy: it will give up converting 
< // a while-loop into do-loop if the the init statement of the IV is not 
< // the last one of the preheader.
< // 
< void
< CFG::Create_empty_preheader (WN* loop) {
<   if (_current_bb->Firststmt() != NULL) {
<     BB_NODE* blk = New_bb (TRUE/*connect*/);
<     blk->Set_linenum (WN_Get_Linenum(loop));
<   }
< }
< 
1191c1168
<   // bug 11542
---
> #ifdef KEY	// bug 11542
1193a1171
> #endif
1197,1207d1174
< #elif defined(TARG_SL) 
<   if (! MTYPE_is_integral(WN_rtype(wn)))
<     return 0;
<   if (opr == OPR_SELECT)
<     return 1;
<   if (opr == OPR_MIN || opr == OPR_MAX || opr == OPR_ILOAD) 
<     return Is_simple_expr(WN_kid0(wn));
<   if (opr == OPR_NEG || opr == OPR_MIN || opr == OPR_MAX || opr == OPR_SELECT ||
<       opr == OPR_CVTL || opr == OPR_ILOAD || opr == OPR_ABS) 
<     return Is_simple_expr(WN_kid0(wn));
< #endif
1253,1259d1219
< #if defined(TARG_NVISA)
<       // mpy is usually fast on nvisa
<   if (opr == OPR_ADD || opr == OPR_SUB || opr == OPR_NEG ||
<       opr == OPR_SHL || opr == OPR_ASHR || opr == OPR_LSHR ||
<       opr == OPR_BAND || opr == OPR_BIOR || opr == OPR_BNOR || opr == OPR_BXOR ||
<       opr == OPR_MPY)
< #else
1263d1222
< #endif
1273,1285d1231
< #ifdef TARG_NVISA
<   if (opr == OPR_CVT || opr == OPR_RECIP) {
<       INT kidans = Is_simple_expr(WN_kid0(wn));
<       return kidans;
<   }
<   if (opr == OPR_MADD || opr == OPR_NMADD) {
<       INT kid0ans = Is_simple_expr(WN_kid0(wn));
<       INT kid1ans = Is_simple_expr(WN_kid1(wn));
<       INT kid2ans = Is_simple_expr(WN_kid2(wn));
<       if (kid0ans == 0 || kid1ans == 0 || kid2ans == 0)
< 	return 0;
<       return kid0ans + kid1ans + kid2ans;
<   }
1435,1778d1380
< BOOL CFG::Screen_cand(WN* wn, WN* else_wn, WN* then_wn, BOOL empty_else, BOOL empty_then)
< {
<   WN *if_test = WN_if_test(wn);
<   WN *stmt = WN_first(empty_then ? else_wn : then_wn);
<   
<   if (WN_operator(stmt) == OPR_MSTORE)
<     return TRUE;
<   
<   // Get the desc type
<   MTYPE dsctyp = WN_desc(stmt);
<   
<   if (dsctyp == MTYPE_M) {
<     // don't generate select for MTYPE_M because there is no register for
<     // MTYPE_M
<     return TRUE;
<   }
<   
<   if (! WOPT_Enable_If_Conv_For_Istore &&
<       (WN_operator(stmt) == OPR_ISTORE || WN_operator(stmt) == OPR_ISTBITS))
<     return TRUE;
<   
<   if (WN_operator(stmt) == OPR_STID || WN_operator(stmt) == OPR_STBITS) {
<     if (_opt_stab->Is_volatile(WN_aux(stmt)))
<       return TRUE;	
< #ifdef TARG_NVISA
<       // shared memory is semi-volatile, in that we can't write multiple
<       // different values at the same time.
<       if (ST_in_shared_mem(_opt_stab->St(WN_aux(stmt)))) {
<         DevWarn("skip if-conversion of shared store");
<         return TRUE;
<       }
< #endif
<   }
<   else {
<     if (TY_is_volatile(WN_ty(stmt)))
<       return TRUE;
<   }
<   
<   if ((WN_operator(stmt) == OPR_STBITS || WN_operator(stmt) == OPR_ISTBITS) &&
<       (empty_then || empty_else)) 
<     return TRUE;
<   
<   if (!OPCODE_Can_Be_Speculative(OPC_I4I4ILOAD)) {
<     if (WN_operator(stmt) == OPR_STID || WN_operator(stmt) == OPR_STBITS) {
<       if (!empty_then) {
< 	ST *st = _opt_stab->St(WN_aux(WN_first(then_wn)));
< 	if (ST_sclass(st) == SCLASS_FORMAL_REF)
< 	  return TRUE; // may be storing into read-only data (bug 12
<       }
<       if (!empty_else) {
< 	ST *st = _opt_stab->St(WN_aux(WN_first(else_wn)));
< 	if (ST_sclass(st) == SCLASS_FORMAL_REF)
< 	  return TRUE; // may be storing into read-only data (bug 12
<       }
<     }
<     else if (empty_then || empty_else) {
<       WN *addr_expr = WN_kid1(stmt);
<       // because need to generate an extra ILOAD, if the if_test involves
<       // the addr_expr, it is probably means speculation is unsafe, so give up
<       // bug 7845
<       if (OPERATOR_is_compare(WN_operator(if_test)) &&
< 	  (Same_addr_expr(WN_kid0(if_test), addr_expr) ||
< 	   Same_addr_expr(WN_kid1(if_test), addr_expr)))
< 	return TRUE;
<       
<       // because need to generate an extra ILOAD, see that a similar ILOAD has
<       // occurred unconditionally; check currently limited to conditional expr
<       // plus previous 2 statements
<       if (! Has_iload_with_same_addr_expr(addr_expr, if_test)) {
< 	// check previous statement
< 	if (_current_bb->Laststmt() == NULL) 
< 	  return TRUE;
< 	if (! Has_iload_with_same_addr_expr(addr_expr, _current_bb->Laststmt()))
< 	  {
< 	    if (WN_prev(_current_bb->Laststmt()) == NULL) 
< 	      return TRUE;
< 	    if (!Has_iload_with_same_addr_expr(addr_expr, WN_prev(_current_bb->Laststmt())))
< 	      return TRUE;
< 	  }
<       }
<     }
<   }
< #if defined(TARG_X8664) || defined(TARG_SL)
<   if (MTYPE_is_float(dsctyp))
<     return TRUE;
<   
< #if defined(TARG_SL2)
<   if((WN_operator(if_test) == OPR_EQ || 
<       WN_operator(if_test) == OPR_NE)  
<      && WN_operator(WN_kid0(if_test)) == OPR_INTRINSIC_OP 
<      && (WN_intrinsic(WN_kid0(if_test)) == INTRN_OP_C2_SCOND_BR ||
< 	 WN_intrinsic(WN_kid0(if_test)) == INTRN_OP_C2_SCOND_BR_R))
<     return TRUE;
<   
< #ifndef fork_joint // mark if-else implementation for fork-joint
<   if((WN_operator(if_test) == OPR_EQ || 
<       WN_operator(if_test) == OPR_NE)  
<      && WN_operator(WN_kid0(if_test)) == OPR_INTRINSIC_OP 
<      &&  (WN_intrinsic(WN_kid0(if_test)) == INTRN_C2_THREAD_MAJOR ||
< 	  WN_intrinsic(WN_kid0(if_test))  == INTRN_C2_THREAD_MINOR))
<     return TRUE;
< #endif 
< #endif //TARG_SL
<  
< #endif /* TARG_X8664 */
<   return FALSE;
< }
< 
< 
< BOOL CFG::If_convertible_cond(WN *wn)
< {
<   // given an if stmt, is this if-convertible
<   FmtAssert((OPCODE_operator(WN_opcode(wn)) == OPR_IF), ("Not an if stmt"));
<   WN    *then_wn    = WN_then(wn);
<   BOOL   empty_then = FALSE;
<   WN *if_test = WN_if_test(wn);
< 
<   if ( then_wn == NULL )
<     empty_then = TRUE;
<   else if ( WN_opcode(then_wn) == OPC_BLOCK && 
< 	    WN_first(then_wn) == NULL )
<     empty_then = TRUE;
< 
<   WN   *else_wn    = WN_else(wn);
<   BOOL  empty_else = FALSE;
< 
<   if ( else_wn == NULL )
<     empty_else = TRUE;
<   else if ( WN_opcode(else_wn) == OPC_BLOCK && 
< 	    WN_first(else_wn) == NULL )
<     empty_else = TRUE;
< 
<   if (If_conv_criteria_met(wn, else_wn, then_wn, empty_else, empty_then)) {
<     if (Screen_cand(wn, else_wn, then_wn, empty_else, empty_then)) {
<       return FALSE;
<     }
<     return TRUE;
<   }
<   return FALSE;
< }
< 
< 
< BOOL CFG::If_conv_criteria_met(WN* wn, WN* else_wn, WN* then_wn, BOOL empty_else, BOOL empty_then)
< {
<   // Perform if-conversion for <simple if-then-else> statements.
<   //
<   //   <simple if-then-else> :: if (cond) then <block> else <block> ;;
<   //   <block> :: <empty_block> | block stid <var> <simple_expr>  end_block ;;
<   //   <empty_block> :: block end_block ;;
<   //   <simple_expr> :: <var> | <const> | <f8const> ;;
<   //  
<   //   where <var> can be speculated and is non-volatile.  At
<   //   least one of then or else block is non-empty.  If both the 
<   //   then and else block are non-empty, they stores to
<   //   the same variable.
<   //
< 
< #ifdef TARG_MIPS
<   if (!(WOPT_Enable_Simple_If_Conv &&
< 	// bug 5684: deleting branches interferes with branch profiling
<       ! Instrumentation_Enabled 
<       // is beneficial for ISA supporting cmov
< 	&& Is_Target_ISA_M4Plus()))
< #else
<   if (!(WOPT_Enable_Simple_If_Conv &&
< 	// bug 5684: deleting branches interferes with branch profiling
<       ! Instrumentation_Enabled 
< 	))
< #endif
<     return FALSE;
< 
< #if defined(TARG_X8664)  // do not if-convert if it has either empty then or else part and it
<   if (
<       // is the only statement in the BB since CG's cflow can be quite effective
<       ((empty_else || empty_then) &&
< #if defined(TARG_IA64)
<       // here select larger than 6 from osprey, I think it may be more aggressive
<        WOPT_Enable_If_Conv_Limit <= 6 &&
< #else
<        (WOPT_Enable_Simple_If_Conv <= 1) &&
< #endif
<        (WN_next(wn) == NULL &&
< 	!(_current_bb->Firststmt() != NULL && // no previous statement in BB
< 	  (_current_bb->Firststmt() != _current_bb->Laststmt() || // prev is LABEL
< 	   (WN_operator(_current_bb->Firststmt()) != OPR_LABEL))))
<        )
<       ) 
<     return FALSE;
< #endif
< 
< 
<   if (
<       // at least one of the then or else statement is non-empty
<       (empty_else && empty_then)
<       )
<     return FALSE;
<     
<   if (!empty_else) {
<     // either the else-stmt is empty or has one  assignment
<     if (!(((WN_first(else_wn) == WN_last(else_wn)) &&
< 	   OPERATOR_is_store(WN_operator(WN_first(else_wn)))) || 
< 	  (WN_operator(else_wn) == OPR_SELECT)))
<       return FALSE;
<   }
< 
<   if (
<       // either the then-stmt is empty or has one assignment
<       (!empty_then &&
<        !(((WN_first(then_wn) == WN_last(then_wn)) &&
< 	  OPERATOR_is_store(WN_operator(WN_first(then_wn)))) || (WN_operator(then_wn) == OPR_SELECT)))
<       )
<     return FALSE;
< 
<   if (
<       // both the then and else are empty or has one assignment with same lhs
<       !(empty_else ||
< 	empty_then ||
< 	Same_store_target(WN_first(else_wn), 
< 			  WN_first(then_wn)))  
<     )
<     return FALSE;
<   return TRUE;
< }
< 
< 
< WN*
< CFG::Conv_to_select(WN* wn)
< {
<   if (WN_opcode(wn) == OPC_BLOCK) {
<     wn = WN_first(wn);
<   }
< 
<   WN *then_wn = WN_then(wn);
<   BOOL empty_then = FALSE;
<   if ( then_wn == NULL )
<     empty_then = TRUE;
<   else if ( WN_opcode(then_wn) == OPC_BLOCK && 
< 	    WN_first(then_wn) == NULL ) {
<     empty_then = TRUE;
<     if (WN_opcode(then_wn) == OPC_BLOCK) {
<       then_wn = WN_first(then_wn);
<     }
<   }
< 
<   WN   *else_wn    = WN_else(wn);
<   BOOL  empty_else = FALSE;
< 
<   if ( else_wn == NULL )
<     empty_else = TRUE;
<   else if ( WN_opcode(else_wn) == OPC_BLOCK && 
< 	    WN_first(else_wn) == NULL ) {
<     empty_else = TRUE;
<     if (WN_opcode(else_wn) == OPC_BLOCK) {
<       else_wn = WN_first(else_wn);
<     }
<   }
< 
<   if (!If_conv_criteria_met(wn, else_wn, then_wn, empty_else, empty_then))
<     return NULL;
< 
<   if (Screen_cand(wn, else_wn, then_wn, empty_else, empty_then))
<     return NULL;
< 
<   //
<   // just evaluate the condition?
<   //
<   WN *if_test = WN_if_test(wn);
<   if ( empty_then && empty_else ) {
<     WN *eval_stmt = WN_CreateEval( if_test );
<     return eval_stmt;
<   }
< 
<     // Get the store from either the first statement of the non-empty block
<     WN *stmt = WN_first(empty_then ? else_wn : then_wn);
< 
<     WN *load = NULL;
<     WN *store = WN_CopyNode(stmt);
<     WN_set_map_id(store, WN_map_id(stmt));
<     MTYPE dsctyp = WN_desc(stmt);
< 
<     if (WN_operator(stmt) == OPR_STID || WN_operator(stmt) == OPR_STBITS)
<       WN_set_aux(store, WN_aux(stmt)); // setting mapping to indicate ST_is_aux
< 
<     // Generate a load for the empty block
<     if (empty_then || empty_else) {
<       if (WN_operator(stmt) == OPR_STID) {
< 	load = WN_Ldid(dsctyp,
< 		       WN_offset(stmt),
< 		       (ST_IDX) WN_aux(stmt),
< 		       WN_ty(stmt),
< 		       WN_field_id(stmt));
< 	WN_set_aux(load, WN_aux(stmt)); // setting mapping to indicate ST_is_aux
<       }
<       else {
< 	MTYPE rtype = WN_rtype(WN_kid0(stmt));
< 	if (MTYPE_byte_size(rtype) < MTYPE_byte_size(dsctyp))
< 	  rtype = dsctyp;// rtype should never be smaller than dsctyp (bug 6910)
< 	else rtype = Mtype_TransferSign(dsctyp, rtype);
< 	load = WN_CreateIload(OPR_ILOAD, 
< 			      rtype,
< 			      dsctyp,
< 			      WN_offset(stmt), TY_pointed(WN_ty(stmt)),
< 			      WN_ty(stmt), 
< 			      Copy_addr_expr(WN_kid1(stmt), _opt_stab->Alias_classification()), 
< 			      WN_field_id(stmt));
< 	// copy alias class info from the ISTORE node
< 	_opt_stab->Alias_classification()->Copy_alias_class(stmt, load);
< 	IDTYPE ip_alias_class = WN_MAP32_Get(WN_MAP_ALIAS_CLASS, stmt);
< 	if (ip_alias_class != OPTIMISTIC_AC_ID)
< 	  WN_MAP32_Set(WN_MAP_ALIAS_CLASS, load, ip_alias_class);
<       }
<     }
<     WN *then_expr = empty_then ? load : WN_kid0(WN_first(then_wn));
<     WN *else_expr = empty_else ? load : WN_kid0(WN_first(else_wn));
<     INT lanswer, ranswer;
< 
<     // profitability check
<     if (
< #if !defined(TARG_IA32) && !defined(TARG_X8664)
<       // The expr in the then-block can be speculated and non-volatile,
<       // is a const or LDA.
<       Is_simple_expr(then_expr) &&
< 
<       // The expr in the else-block can be speculated and non-volatile,
<       // is a const or LDA.
<       Is_simple_expr(else_expr) 
< #else // allow simple expressions of up to 4 leaf nodes
<       (lanswer = (empty_then ? 1 : Is_simple_expr(then_expr))) && 
< 
<       (ranswer = (empty_else ? 1 : Is_simple_expr(else_expr))) && 
< 
<       (lanswer + ranswer) <= WOPT_Enable_If_Conv_Limit
< #endif
<        ) {
<       // Generate a SELECT expression
<       WN *sel = WN_Select( Mtype_comparison(dsctyp),
< 			   WN_if_test(wn), then_expr, else_expr );
<       WN_kid0(store) = sel;
<       WN_Set_Linenum( store, WN_Get_Linenum(wn) );
<       return store;
<     }
<     return NULL;
< }
< 
1819,1820c1421
<   else { 
<     if ( WN_opcode(then_wn) == OPC_BLOCK && 
---
>   else if ( WN_opcode(then_wn) == OPC_BLOCK && 
1823d1423
<   }
1830,1831c1430
<   else {
<     if ( WN_opcode(else_wn) == OPC_BLOCK && 
---
>   else if ( WN_opcode(else_wn) == OPC_BLOCK && 
1834d1432
<   }
1867,1888c1465,1481
< #if defined(TARG_SL) 
<   // more aggressively peer down else and then case for nested selects
<   if (else_wn && ((WN_first(else_wn) == WN_last(else_wn)) && WN_first(else_wn) && (WN_operator(WN_first(else_wn)) == OPR_IF))) {
<     WN *sel_stmt = Conv_to_select(else_wn);
<     if (sel_stmt) {
<       WN* block = WN_CreateBlock();
<       WN_first(block) = sel_stmt;
<       WN_last(block) = sel_stmt;
<       else_wn = block;
<       WN_else(wn) = block;
<     }
<   }
<   if (then_wn && ((WN_first(then_wn) == WN_last(then_wn)) && WN_first(then_wn) && (WN_operator(WN_first(then_wn)) == OPR_IF))) {
<     WN *sel_stmt = Conv_to_select(then_wn);
<     if (sel_stmt) {
<       WN* block = WN_CreateBlock();
<       WN_first(block) = sel_stmt;
<       WN_last(block) = sel_stmt;
<       then_wn = block;
<       WN_then(wn) = block;
<     }
<   }
---
>   if (WOPT_Enable_Simple_If_Conv &&
> #ifdef KEY // bug 5684: deleting branches interferes with branch profiling
>       ! Instrumentation_Enabled &&
> #endif
> 
>       // is beneficial for ISA supporting cmov
> #ifdef TARG_MIPS
>       Is_Target_ISA_M4Plus() &&  
> #endif
> #ifdef KEY  // do not if-convert if it has either empty then or else part and it
>       // is the only statement in the BB since CG's cflow can be quite effective
>       ((!empty_else && !empty_then) ||
>        WOPT_Enable_Simple_If_Conv > 1 ||
>        WN_next(wn) != NULL || // no next statement in BB
>        (_current_bb->Firststmt() != NULL && // no previous statement in BB
>         (_current_bb->Firststmt() != _current_bb->Laststmt() || // prev is LABEL
>          (WN_operator(_current_bb->Firststmt()) != OPR_LABEL)))) &&
1891c1484,1486
<   if (If_conv_criteria_met(wn, else_wn, then_wn, empty_else, empty_then)) { 
---
>       // at least one of the then or else statement is non-empty
>       (!empty_else ||
>        !empty_then) && 
1893,1894c1488,1502
<     if (Screen_cand(wn, else_wn, then_wn, empty_else, empty_then))
<       goto skip_if_conversion;
---
>       // either the else-stmt is empty or has one  assignment
>       (empty_else ||
>        (WN_first(else_wn) == WN_last(else_wn) &&
>         OPERATOR_is_store(WN_operator(WN_first(else_wn))))) &&
> 
>       // either the then-stmt is empty or has one assignment
>       (empty_then ||
>        (WN_first(then_wn) == WN_last(then_wn) &&
>         OPERATOR_is_store(WN_operator(WN_first(then_wn))))) &&
> 
>       // both the then and else are empty or has one assignment with same lhs
>       (empty_else ||
>        empty_then ||
>        Same_store_target(WN_first(else_wn), 
>        			 WN_first(then_wn))) ) { 
1898a1507,1581
>     if (WN_operator(stmt) == OPR_MSTORE)
>       goto skip_if_conversion;
> 
>     // Get the desc type
>     MTYPE dsctyp = WN_desc(stmt);
> 
>     if (dsctyp == MTYPE_M) {
>       // don't generate select for MTYPE_M because there is no register for
>       // MTYPE_M
>       goto skip_if_conversion;
>     }
> 
>     if (! WOPT_Enable_If_Conv_For_Istore &&
>         (WN_operator(stmt) == OPR_ISTORE || WN_operator(stmt) == OPR_ISTBITS))
>       goto skip_if_conversion;
> 
>     if (WN_operator(stmt) == OPR_STID || WN_operator(stmt) == OPR_STBITS) {
>       if (_opt_stab->Is_volatile(WN_aux(stmt)))
> 	goto skip_if_conversion;
>     }
>     else {
>       if (TY_is_volatile(WN_ty(stmt)))
> 	goto skip_if_conversion;
>     }
> 
>     if ((WN_operator(stmt) == OPR_STBITS || WN_operator(stmt) == OPR_ISTBITS) &&
> 	(empty_then || empty_else)) 
>       goto skip_if_conversion;
> 
> #ifdef KEY
>     if (!OPCODE_Can_Be_Speculative(OPC_I4I4ILOAD)) {
>       if (WN_operator(stmt) == OPR_STID || WN_operator(stmt) == OPR_STBITS) {
> 	if (!empty_then) {
> 	  ST *st = _opt_stab->St(WN_aux(WN_first(then_wn)));
> 	  if (ST_sclass(st) == SCLASS_FORMAL_REF)
> 	    goto skip_if_conversion; // may be storing into read-only data (bug 12
> 	}
> 	if (!empty_else) {
> 	  ST *st = _opt_stab->St(WN_aux(WN_first(else_wn)));
> 	  if (ST_sclass(st) == SCLASS_FORMAL_REF)
> 	    goto skip_if_conversion; // may be storing into read-only data (bug 12
> 	}
>       }
>       else if (empty_then || empty_else) {
> 	WN *addr_expr = WN_kid1(stmt);
> 	// because need to generate an extra ILOAD, if the if_test involves
> 	// the addr_expr, it is probably means speculation is unsafe, so give up
>         // bug 7845
> 	if (OPERATOR_is_compare(WN_operator(if_test)) &&
> 	    (Same_addr_expr(WN_kid0(if_test), addr_expr) ||
> 	     Same_addr_expr(WN_kid1(if_test), addr_expr)))
> 	  goto skip_if_conversion;
> 
> 	// because need to generate an extra ILOAD, see that a similar ILOAD has
> 	// occurred unconditionally; check currently limited to conditional expr
> 	// plus previous 2 statements
> 	if (! Has_iload_with_same_addr_expr(addr_expr, if_test)) {
> 	  // check previous statement
> 	  if (_current_bb->Laststmt() == NULL) 
> 	    goto skip_if_conversion;
> 	  if (! Has_iload_with_same_addr_expr(addr_expr, _current_bb->Laststmt()))
> 	  {
> 	    if (WN_prev(_current_bb->Laststmt()) == NULL) 
> 	      goto skip_if_conversion;
> 	    if (!Has_iload_with_same_addr_expr(addr_expr, WN_prev(_current_bb->Laststmt())))
> 	      goto skip_if_conversion;
> 	  }
> 	}
>       }
>     }
> #endif
> #ifdef TARG_X8664
>     if (MTYPE_is_float(dsctyp))
>       goto skip_if_conversion;
> #endif /* TARG_X8664 */
1902,1903d1584
<     MTYPE dsctyp = WN_desc(stmt);
< 
1922,1926d1602
< #ifdef TARG_SL
<         if (rtype == MTYPE_I2 && dsctyp == MTYPE_I2) {
<           rtype = MTYPE_I4;
<         }
< #endif
1982c1658
< 
---
> #ifdef KEY
1984c1660
< 
---
> #endif /* TARG_X8664 */
2050,2057d1725
<         if(WN_prev(goto_wn) != NULL && (WN_prev(goto_wn)) != NULL) {
<           WN*  prev_wn=WN_prev(goto_wn);
<           if ( Cur_PU_Feedback ) {
<             FB_FREQ outgoing_fb=Cur_PU_Feedback->Query_total_out(prev_wn);
<             Cur_PU_Feedback->Annot(goto_wn, FB_EDGE_OUTGOING, outgoing_fb);
<           }
< 
<         }
2645c2313
<   // bug 8690
---
> #ifdef KEY // bug 8690
2650a2319
> #endif
2697,2702c2366,2371
< 
<   // This wn is a OPR_FUNC_ENTRY node. If we copy the map-id directly, we don't
<   // remove the id from the free-list. OPR_REGION and OPR_FUNC_ENTRY are the 
<   // only 2 operators in the same annotation category. So an OPR_REGION picks
<   // up the first free-list entry which turns out to be the same as the one
<   // in OPR_FUNC_ENTRY.
---
> #ifdef KEY
> // This wn is a OPR_FUNC_ENTRY node. If we copy the map-id directly, we don't
> // remove the id from the free-list. OPR_REGION and OPR_FUNC_ENTRY are the 
> // only 2 operators in the same annotation category. So an OPR_REGION picks
> // up the first free-list entry which turns out to be the same as the one
> // in OPR_FUNC_ENTRY.
2703a2373,2375
> #else
>   WN_map_id(copy_wn) = WN_map_id(wn);
> #endif
2792,2802d2463
<         if (WN_operator(stmt) == OPR_CALL && WOPT_Enable_Noreturn_Attr_Opt) {
<           if (PU_has_attr_noreturn(Pu_Table[ST_pu(WN_st(stmt))])) {
<             // ignore the rest statements
<             if (!nextstmt || 
<                 (WN_operator(nextstmt) != OPR_RETURN && 
<                  WN_operator(nextstmt) != OPR_RETURN_VAL)) {
<               nextstmt = WN_Create (OPC_RETURN, 0); 
<             }
<           }
<         }
< 
2876d2536
<     Create_empty_preheader (wn);
2884d2543
<     Create_empty_preheader (wn);
2894d2552
<     Create_empty_preheader (wn);
3052c2710
<     if (ends_bb) {
---
>     if ( ends_bb )
3054d2711
<     }
4988,4989c4645
< 		loop->Loopback()->Kind() == BB_VARGOTO||
< 		loop->Loopback()->Kind() == BB_REGIONSTART,
---
> 		loop->Loopback()->Kind() == BB_VARGOTO,
5179a4836
> #ifdef KEY
5214c4871
< 
---
> #endif
5535,5605d5191
< dump_cfg (CFG *cfg)
< {
<   cfg->Print(stdout);
< }
< 
< void CFG::PrintLoopVis(BB_LOOP * loop, int& id)
< {
<   BB_NODE *tmp;
<   BB_NODE_SET_ITER bb_iter;
< 
<   fprintf(stdout, "subgraph cluster%d {\n", id);
<   FOR_ALL_ELEM(tmp, bb_iter, Init(loop->Body_set())) {
<     fprintf(stdout, "BB%d;\n", tmp->Id());
<   }
< 
<   BB_LOOP_ITER loop_iter(loop->Child());
<   BB_LOOP *child;
< 
<   id = id + 1;
< 
<   FOR_ALL_NODE(child, loop_iter, Init()) {
<     PrintLoopVis(child, id);
<   }
<   fprintf(stdout, "};\n");
< 
< }
< 
< void
< CFG::PrintVis(BOOL draw_loops)
< {
<   CFG_ITER cfg_iter(this);
<   BB_NODE *tmp;
< 
< 
<   fprintf(stdout, "digraph Cfg {\n");
< 
<   if (draw_loops) {
<     BB_LOOP_ITER loop_iter(Loops());
<     BB_LOOP * loop;
<     BB_LOOP * tmp_loop;
< 
<     int loop_num = 0;
<     FOR_ALL_NODE(loop, loop_iter, Init()) {
<       PrintLoopVis(loop, loop_num);
<     }
<   }
< 
<   FOR_ALL_NODE(tmp, cfg_iter, Init()) {
<     tmp->PrintVis();
<   }
<   fprintf(stdout, "}\n");
< 
< }
< 
< void CFG::PrintCDVis(void)
< {
<   CFG_ITER cfg_iter(this);
<   BB_NODE * bb;
<   fprintf(stdout, "digraph CD { \n");
<   FOR_ALL_NODE(bb, cfg_iter, Init()) {
<     BB_NODE * dep_node;
<     BB_NODE_SET_ITER rcfg_iter;
<     fprintf(stdout, "BB%d;\n", bb->Id());
<     FOR_ALL_ELEM(dep_node, rcfg_iter, Init(bb->Rcfg_dom_frontier())) {
<       fprintf(stdout, "BB%d -> BB%d;\n", dep_node->Id(), bb->Id());
<     }
<   }
<   fprintf(stdout, "}\n");
< }
< 
< void
5666c5252
<   // bug 11304
---
> #ifdef KEY // bug 11304
5668c5254
< 
---
> #endif
opt_cfg.cxx
opt_cfg_trans.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_cfg_trans.cxx,v $
---
> // $Revision: 1.7 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_cfg_trans.cxx $
opt_cfg_trans.cxx
opt_combine.cxx
0a1,4
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_combine.cxx,v $
---
> // $Revision: 1.8 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_combine.cxx $
85d88
< #include "betarget.h" // for Can_Do_Fast_Divide
123,127c126
< 
<   else if ( WOPT_Enable_DIVREM && MTYPE_is_integral(rtype)  && 
< 	    ! (WN_operator_is(WN_kid1(old_wn), OPR_INTCONST) && 
< 	       Can_Do_Fast_Divide(MTYPE_I4, WN_const_val(WN_kid1(old_wn))))) {
<     
---
>   else if ( WOPT_Enable_DIVREM && MTYPE_is_integral(rtype) ) {
opt_combine.cxx
opt_cond_const.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_cond_const.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_cond_const.cxx $
224,239d223
< #if defined(TARG_SL)
< #ifndef fork_joint // for searching
< /* if(intrinsic_c2_thread_major())  
<   *            .......
<   * if(intrinsic_c2_thread_major())
<   *              .......
<   * we must not regard this consecutive fork/joint as same condition. 
<   * as for we just borrow if-else structure to do fork-joint 
<   */ 
<   if(cmp->Kind()==CK_OP && 
<      (cmp->Get_opnd(0)->Intrinsic()  == INTRN_C2_THREAD_MAJOR || 
<      cmp ->Get_opnd(0)->Intrinsic() == INTRN_C2_THREAD_MINOR))
<       return false;
< #endif 
< #endif
< 
opt_cond_const.cxx
opt_count.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_count.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_count.cxx $
opt_count.cxx
opt_cse.cxx
3a4,7
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
> /*
10,13c14,17
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_cse.cxx,v $
---
> // $Revision: 1.10 $
> // $Date: 05/09/12 16:35:20-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_cse.cxx $
788d791
<     
929,930d931
<       Is_True(injury->Str_red_num() <= WOPT_Enable_Autoaggstr_Reduction_Threshold,
< 	      ("CSE::Repair_injury_rec: autoaggstr_limit exceeded"));
opt_cse.cxx
opt_daVinci.cxx
1,4d0
< /*
<  * Copyright 2005-2007 NVIDIA Corporation.  All rights reserved.
<  */
< 
10,13c6,9
< // $Revision: 1.2 $
< // $Date: 02/11/07 23:41:53-00:00 $
< // $Author: fchow@keyresearch.com $
< // $Source: /scratch/mee/Patch0002-taketwo/kpro64-pending/be/opt/SCCS/s.opt_daVinci.cxx $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
63,66c59
< #ifndef __MINGW32__
< #if defined(__CYGWIN__) || defined(__APPLE__)
< #include <sys/wait.h>
< #elif defined(BUILD_OS_DARWIN)
---
> #if defined(BUILD_OS_DARWIN)
70,71c63
< #endif
< #endif /* __MINGW32__ */
---
> #endif /* defined(BUILD_OS_DARWIN) */
110d101
< #ifndef __MINGW32__
162d152
< #endif /* __MINGW32__ */
203d192
< #ifndef __MINGW32__
212d200
< #endif /* __MINGW32__ */
opt_daVinci.cxx
opt_dbg.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_dbg.cxx,v $
---
> // $Revision: 1.4 $
> // $Date: 05/03/10 16:47:55-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_dbg.cxx $
opt_dbg.cxx
opt_dce.cxx
3a4,7
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
> /*
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_dce.cxx,v $
---
> // $Revision: 1.21 $
> // $Date: 05/08/16 21:38:07-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_dce.cxx $
78d81
< #include "erbe.h"
163,165d165
< #if defined(TARG_SL)
<     vector<STMTREP *> *_injured_aux_intrnop; // stacks used for store aux intrinsic op need repaired to live
< #endif
424,426d423
< #if defined(TARG_SL)
<         _injured_aux_intrnop = CXX_NEW(vector<STMTREP *>, cfg->Loc_pool());
< #endif
457,462d453
< #if defined(TARG_SL)
<     void Append_Injured_AuxIntrnOp (STMTREP *stmt) const {
<        _injured_aux_intrnop->insert(_injured_aux_intrnop->begin(), (STMTREP *)stmt);
<     };
<     void Repair_Injured_AuxIntrnOP() const;
< #endif
466,505d456
< #if defined(TARG_SL)
< void
< DCE::Repair_Injured_AuxIntrnOP() const {
< 
<   for (INT32 i = 0; i < _injured_aux_intrnop->size(); i++) {
<     STMTREP *stmt = (*_injured_aux_intrnop)[i];
<     if (stmt->Live_stmt())
<       continue;
<     CODEREP *rhs = stmt->Rhs();
<     if (CR_Intrinsic_Op_Slave(rhs)) {
<       CODEREP *parm2cr = rhs->Opnd(0);	// first parameter
<       Is_True(parm2cr->Kind() == CK_IVAR, ("Repair_Injured_AuxIntrnOP::kid of intrinsic op must be parameter"));
<       CODEREP *op2cr = parm2cr->Ilod_base();
<       if (op2cr) {
<         switch (op2cr->Kind()) {
<           case CK_VAR: 
<           {
<             if(op2cr->Defstmt()->Live_stmt())	
< 	      Mark_statement_live(stmt);	
< 	  }
< 	  break;	
< 	  case CK_OP: 
<           {
< 	    Mark_statement_live(stmt);
< 	  };
<      	  break; 	
< 	  default:
< 	    Is_True (0, ("Repair_Injured_AuxIntrnOP::slave intrinsic op(c3_ptr): first parameter is unsupported kind coderep"));	
<         } // end switch
<       } else {
<         Is_True (0, ("Repair_Injured_AuxIntrnOP::slave intrinsic op(c3_ptr): first parameter is null"));
<       }
<     } else {
<       Is_True(0, ("Repair_Injured_AuxIntrnOP::rhs is not injure AuxIntrn"));
<     }
<   }
<   return;
< }
< #endif
< 
1195,1232d1145
< Helper_Eval_redundant_cond_br( CODEREP *origcond, CODEREP *evalcond )
< {
<   if (origcond->Kind() == CK_OP && OPERATOR_is_compare(origcond->Opr())) 
<   {
<     CODEREP *kid0 = origcond->Opnd(0);
<     CODEREP *kid1 = origcond->Opnd(0);
<     if(kid0->Non_leaf()) {
<       if(kid0->Opr()==OPR_INTRINSIC_OP 
< #ifdef TARG_SL2
<           && (kid0->Intrinsic()==INTRN_OP_C2_SCOND_BR ||
<                    kid0->Intrinsic()==INTRN_OP_C2_SCOND_BR_R)
< #ifndef fork_joint
<            && (kid0 ->Intrinsic() == INTRN_C2_THREAD_MAJOR || 
<                  kid0 ->Intrinsic() == INTRN_C2_THREAD_MINOR) 
< #endif 
< 
< #endif //TARG_SL2
<          )
<         return EVAL_UNKNOWN;
<     
<     } 
<     else if(kid1->Non_leaf()) {
<       if(kid1->Opr()==OPR_INTRINSIC_OP 
< #ifdef TARG_SL2
<              && (kid1->Intrinsic()==INTRN_OP_C2_SCOND_BR ||
<                    kid1->Intrinsic()==INTRN_OP_C2_SCOND_BR_R)
< #ifndef fork_joint
<              && (kid1 ->Intrinsic() == INTRN_C2_THREAD_MAJOR ||
<                    kid1 ->Intrinsic() == INTRN_C2_THREAD_MINOR)
< #endif 
< #endif 
< 	 )
<       return EVAL_UNKNOWN;
<     }
<   }
< }
< 
< COND_EVAL
1235,1238d1147
< #if defined(TARG_SL)
<   if (Helper_Eval_redundant_cond_br(origcond, evalcond) == EVAL_UNKNOWN)
<     return EVAL_UNKNOWN;
< #endif
1276a1186
> 
1819d1728
< #if !defined(TARG_SL)
1822,1825d1730
< #else
<       if ( 0 && bb->Labnam() != 0 &&
< 	   LABEL_addr_saved( bb->Labnam() ) ) {
< #endif
2003,2008d1907
< #if defined(TARG_SL)
<   if (CR_Intrinsic_Op_Slave(stmt->Rhs())) {
<     Append_Injured_AuxIntrnOp((STMTREP *)stmt);
<   }
< #endif
< 
4224,4229c4123
<       if (regbb->Kind() == BB_REGIONSTART && regbb->Succ() != NULL && regbb->Succ()->Len() == 1) {
< #ifndef KEY
< 	Is_True(regbb->Succ() != NULL && regbb->Succ()->Len() == 1,
< 		("DCE::Update_region_information, multiple successors "
< 		 "for region start"));
< #endif
---
>       if (regbb->Kind() == BB_REGIONSTART && regbb->Succ()->Len() == 1) {
4468,4470d4361
< #ifdef TARG_SL
<   Repair_Injured_AuxIntrnOP();
< #endif
5139c5030,5031
<     ErrMsg(EC_Uninitialized, output_var_name, Cur_PU_Name);
---
>     fprintf(stderr, "Warning: variable %s in %s might be used uninitialized\n",
> 	    output_var_name, output_pu_name);
opt_dce.cxx
opt_dom.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_dom.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_dom.cxx
opt_dse.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_dse.cxx,v $
---
> // $Revision: 1.17 $
> // $Date: 05/06/13 20:16:52-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_dse.cxx $
opt_dse.cxx
opt_du.cxx
1,4d0
< /*
<  * Copyright 2005-2007 NVIDIA Corporation.  All rights reserved.
<  */
< 
10,13c6,9
< // $Revision: 1.2 $
< // $Date: 02/11/07 23:41:53-00:00 $
< // $Author: fchow@keyresearch.com $
< // $Source: /scratch/mee/Patch0002-taketwo/kpro64-pending/be/opt/SCCS/s.opt_du.cxx $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
1082d1077
< #if defined(TARG_SL2)
1084d1078
< 	RID_TYPE_major(rid) || RID_TYPE_minor(rid) ||
1087,1091d1080
< #else
<     if (RID_TYPE_mp(rid) || RID_TYPE_eh(rid) || RID_TYPE_olimit(rid) ||
< 	RID_TYPE_pragma(rid) ||
< 	RID_level(rid) < Cfg()->Rgn_level()) {
< #endif
1801c1790
<   BZERO (_bb_summary, sizeof(BB_SUMMARY_INFO) * _bb_cnt);
---
>   bzero(_bb_summary, sizeof(BB_SUMMARY_INFO) * _bb_cnt);
opt_du.cxx
opt_eant.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_eant.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_eant.cxx
opt_eavail.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_eavail.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_eavail.cxx $
opt_eavail.cxx
opt_efinalize.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_efinalize.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
120,124d119
<   Is_Trace(etable->Tracing(), (TFile, "EXP_WORKLST::Insert_one_operand\n"));
<   Is_Trace(etable->Tracing(), (TFile, "Inserted expression:\n"));
<   Is_Trace_cmd(etable->Tracing(), insert_cr->Print(3, TFile));
<   Is_Trace(etable->Tracing(), (TFile, "CFG \n"));
<   Is_Trace_cmd(etable->Tracing(), etable->Cfg()->Print(TFile));
opt_efinalize.cxx
opt_ehoist.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ehoist.cxx,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_ehoist.cxx $
opt_ehoist.cxx
opt_emit.cxx
3a4,6
>  * Copyright 2007 PathScale, LLC.  All Rights Reserved.
>  */
> /*
11,14c14,17
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_emit.cxx,v $
---
> // $Revision: 1.13 $
> // $Date: 05/10/14 15:56:28-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_emit.cxx $
1375,1381d1377
< #ifdef TARG_SL2 //region_type_for_major
<       if (RID_TYPE_mp(bb_region->Rid()) || RID_TYPE_eh(bb_region->Rid()) ||
< 	  // kludge for 7.2, see pv 457243
< 	  RID_TYPE_olimit(bb_region->Rid()) ||
< 	  RID_TYPE_major(bb_region->Rid()) ||  RID_TYPE_minor(bb_region->Rid()) ||
< 	  RID_TYPE_pragma(bb_region->Rid())) {
< #else
1386d1381
< #endif
1575,1586d1569
<   {
<     BOOL tr = _trace || Get_Trace (TP_GLOBOPT, ALIAS_DUMP_FLAG);
<     if (Opt_stab()->Phase() == PREOPT_LNO_PHASE) {
<       Opt_stab()->Cr_sr_annot_mgr()->Export_annot 
<                      (_opt_func, alias_mgr, FALSE, tr);
<     } else {
<       Opt_stab()->Cr_sr_annot_mgr()->Discard_offline_annot 
<                      (_opt_func, alias_mgr, tr);
<     }
<     WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Set_active_mgr();  
<   }
< 
opt_emit.cxx
opt_eocc.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_eocc.cxx,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_eocc.cxx $
opt_eocc.cxx
opt_essa.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_essa.cxx,v $
---
> // $Revision: 1.7 $
> // $Date: 05/09/15 16:06:09-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_essa.cxx $
158,159c158
<   BOOL                Same_base_same_offset(const CODEREP *,
< 					    const CODEREP *) const;
---
> 
245,261d243
< // Return TRUE if their base and offset are the same
< BOOL
< ESSA::Same_base_same_offset(const CODEREP *cr1, const CODEREP *cr2) const
< {
<   if (cr1->Kind() != CK_IVAR || cr2->Kind() != CK_IVAR)
<     return FALSE;
< 
<   CODEREP *base1 = cr1->Ilod_base() ? cr1->Ilod_base() : cr1->Istr_base();
<   CODEREP *base2 = cr2->Ilod_base() ? cr2->Ilod_base() : cr2->Istr_base();
<   if (base1 == base2) {
<     if (cr1->Offset() ==  cr2->Offset()) 
<       return TRUE;
<   }
<   return FALSE;
< }
< 
< 
297,303d278
<     //since the ansi rule is turned on by default, but now there're
<     //still some unsafe things. we need to do a fix here
<     //this's definite alias case, which we can do before apply the
<     //the alias rule
<     if(Same_base_same_offset(sr->Lhs(), cr))
<       return TRUE;
< 
315c290
< 			      cr->Ilod_ty(), TRUE) &&
---
> 			      cr->Ilod_ty()) &&
319d293
< 
387c361
< 			      cr->Ilod_ty(), TRUE) &&
---
> 			      cr->Ilod_ty()) &&
429a404,408
> #ifdef KEY // bug 7814
>     if (vsym->Aux_id() == Opt_stab()->Default_vsym())
>       return TRUE;
> #endif
> 
433c412
< 			      use_cr->Ilod_ty(), TRUE) &&
---
> 			      use_cr->Ilod_ty()) &&
opt_essa.cxx
opt_estr.cxx
3a4,11
>  *  Copyright (C) 2007 PathScale, LLC. All Rights Reserved.
>  */
> 
> /*
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
> /*
11,14c19,22
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_estr.cxx,v $
---
> // $Revision: 1.12 $
> // $Date: 05/04/25 21:42:38-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_estr.cxx $
178,181c186
<   if (MTYPE_size_min(cr->Dsctyp()) < MTYPE_size_min(MTYPE_I4)) {
<     if (WOPT_Enable_STR_Short && (MTYPE_size_min(cr->Dsctyp()) == MTYPE_size_min(MTYPE_I2))) {
<       return TRUE;
<     }
---
>   if (MTYPE_size_min(cr->Dsctyp()) < MTYPE_size_min(MTYPE_I4))
183d187
<   }
212c216
< #ifndef TARG_X8664
---
> #ifdef TARG_MIPS
opt_estr.cxx
opt_etable.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_etable.cxx,v $
---
> // $Revision: 1.26 $
> // $Date: 05/08/10 19:20:06-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_etable.cxx $
509,544d508
< #ifdef TARG_NVISA // other targets don't know how to rematerialize these
<   case CK_OP:
<     // add ability to create preg home for expression,
<     // so can later still find the base of the temporary.
<     switch (Opr()) {
<     case OPR_ADD:
<     case OPR_SUB:
<     case OPR_MPY:
< 	{
< 	WN *kid0 = Opnd(0)->Rvi_home_wn(opt_stab);
< 	WN *kid1 = Opnd(1)->Rvi_home_wn(opt_stab);
< 	if (kid0 && kid1) {
< 	  home_wn = WN_CreateExp2 (Opr(), Dtyp(), MTYPE_V, kid0, kid1);
< 	}
< 	}
< 	break;
<     case OPR_CVT:
< 	{
< 	WN *kid = Opnd(0)->Rvi_home_wn(opt_stab);
< 	if (kid) {
< 	  home_wn = WN_CreateExp1 (Opr(), Dtyp(), Dsctyp(), kid);
< 	}
< 	}
< 	break;
<     }
<     break;
<   case CK_IVAR:
<     if (Opr() == OPR_ILOAD && Ilod_base()) {
<       WN *kid0 = Ilod_base()->Rvi_home_wn(opt_stab);
<       if (kid0) {
<         home_wn = WN_CreateIload (Opr(), Dtyp(), Dsctyp(),
<           Offset(), Ilod_ty(), Ilod_base_ty(), kid0);
<       }
<     }
<     break;
< #endif
578,580c542
< // ia32,x86,ia64,nvisa all don't want to do this cause it can cause 
< // inconsistent sizes for the same symbol
< #if defined(TARG_IA32) || defined(TARG_X8664) || defined(TARG_NVISA)
---
> #if defined(TARG_IA32) || defined(TARG_X8664)
585,587c547
< #elif !defined(TARG_IA64)
<     // ia64 has similar problem (inconsistent sizes for the same symbol)
<     // -- OSP_185
---
> #else
594,597d553
<     WN *home_wn = NULL;
< #ifdef TARG_NVISA // only do for nvisa till other targets learn rematerialize
<     home_wn = exp->Rvi_home_wn(htable->Sym());
< #endif
604d559
< #ifndef TARG_NVISA
606,608d560
< #else
<         AUX_ID id = htable->Sym()->Create_preg(dtyp, "vnfre_cst", home_wn);
< #endif
630d581
< #ifndef TARG_NVISA
632,634d582
< #else
<         AUX_ID id = htable->Sym()->Create_preg(dtyp, "epre_cst", home_wn);
< #endif
660d607
< #ifndef TARG_NVISA // done above
662d608
< #endif
727d672
< #ifndef TARG_NVISA
729,730d673
< ETABLE::New_temp_cr(MTYPE dtype, ADDRESSABILITY addressable, CODEREP *rhs)
< #else
732d674
< #endif
755,756d696
<    // Change:  pass rhs so can get preg home info.
<    //
763,766d702
< #ifdef TARG_NVISA
<    WN *home_wn = rhs->Rvi_home_wn(Htable()->Sym());
<    AUX_ID          id = Htable()->Sym()->Create_preg(dtype, "new_cst", home_wn);
< #else
768d703
< #endif
2764,2795d2698
< #ifdef TARG_SL2
< 
< /* this function is used to decide if nth parameter in following intrinsic function can 
<   * be etable candiate. These parameter is address  expression and is offset from
<   * internal buffer start address.
<   */ 
< 
< static BOOL 
< Is_Intrncall_Nth_Parm_Candidate(INTRINSIC id,  INT nth_parm ) {
<       switch(id) {
<         case INTRN_C2_LD_C_IMM:
<         case INTRN_C2_ST_C_IMM:				
<             if(nth_parm == 1) return TRUE;
< 	     return FALSE;
<         case INTRN_C2_LD_V2G_IMM:
<         case INTRN_C2_ST_G2V_IMM:		
<         case INTRN_C2_LD_G_IMM:
<         case INTRN_C2_ST_G_IMM:			
<             if(nth_parm == 2) return TRUE;
<             return FALSE;
<         case INTRN_C2_ST_V_IMM:
< 	     if(nth_parm == 3) return TRUE;
< 	     return FALSE;
<         case INTRN_C2_LD_V_IMM:
< 	     if(nth_parm == 4) return TRUE;
< 	     return FALSE;
<          default:
< 	     return FALSE;
<       }
< }
< #endif 
< 
2838,2842d2740
< #ifdef TARG_SL2
<            if(rhs->Opr()==OPR_INTRINSIC_CALL && Is_Intrncall_Nth_Parm_Candidate(rhs->Intrinsic(), i)) {
<                  continue;
< 	    }
< #endif 
2897a2796
> 
2916,2920c2815
< #ifdef TARG_SL
<         if (cr->Dtyp() == MTYPE_I2 && cr->Dsctyp() == MTYPE_I2) {
<             cr->Set_dtyp(MTYPE_I4);
<         } 
< #endif        
---
> 
3080,3093d2974
< 	      
< #ifdef TARG_SL2
< 	  } else if(opr == OPR_INTRINSIC_OP && 
< 		  	(cr->Intrinsic() == INTRN_OP_C2_SCOND_BR ||
<                        cr->Intrinsic() == INTRN_OP_C2_SCOND_BR_R)) {
<             cr->Set_omitted();
< 
< #ifndef fork_joint
<          } else if(opr == OPR_INTRINSIC_OP && 
< 		 	(cr->Intrinsic() == INTRN_C2_THREAD_MAJOR || 
< 		 	cr->Intrinsic() == INTRN_C2_THREAD_MINOR)) {
<              cr->Set_omitted();
< #endif 
< #endif //TARG_SL2
3165c3046
< #ifndef KEY
---
> #ifndef TARG_X8664 // bug 12918: MIPS cannot use Fixup_type here
3434,3446d3314
< 
<       // bug fix for OSP_188
<       // As to expression whose operator is OPR_CVT, if the descriptor type
<       // of this expr is MTYPE_B, we should not modify the return type of
<       // it's kid, which is MTYPE_B, to some type else.
<       OPERATOR opr = OPCODE_operator(opc);
<       TYPE_ID desc = OPCODE_desc(opc);
<       if (opr == OPR_CVT && desc == MTYPE_B && x->Kind() == CK_VAR &&
< 	  x->Dtyp() == MTYPE_B && x->Dsctyp() == MTYPE_B)
< 	{
< 	  return x;
< 	}
<       
3570c3438
< 	// bug 12471: __builtin_expect's first kid must be constant
---
> #ifdef KEY // bug 12471: __builtin_expect's first kid must be constant
3573a3442
> #endif
opt_etable.cxx
opt_exc.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_exc.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_exc.cxx $
opt_exc.cxx
opt_expr.cxx
10,13c10,13
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_expr.cxx,v $
---
> // $Revision: 1.6 $
> // $Date: 05/01/12 16:07:08-08:00 $
> // $Author: fchow@fluorspar.keyresearch $
> // $Source: be/opt/SCCS/s.opt_expr.cxx $
opt_expr.cxx
opt_fb.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_fb.cxx,v $
---
> // $Revision: 1.11 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_fb.cxx $
781,787d780
< #if defined (TARG_SL) && defined(TARG_SL2)
< 	else if (WN_operator( wn ) != OPR_IO &&
< 		 (WN_is_compgoto_for_minor ( wn ) || WN_is_compgoto_para ( wn ))) {
< 	  node.in_out_same = false;
< 	  break;
< 	}
< #endif
801,827d793
< #if defined(TARG_SL)  && defined(TARG_SL2)
<       if(bb->Kind()==BB_REGIONSTART) {
< 	RID* rid=bb->Regioninfo()->Rid();
< 	if(rid!=NULL) {
< 	  WN* rgn=bb->Regioninfo()->Orig_wn();
< 	  if( rgn!=NULL && WN_operator(rgn)==OPR_REGION) {
< 	    FB_FREQ in_freq = Cur_PU_Feedback->Query( rgn, FB_EDGE_CALL_INCOMING );
< 	    if ( bb->Succ() )
< 	      Add_edge( bb->Id(), bb->Nth_succ(0)->Id(), FB_EDGE_OUTGOING, in_freq);
< 	  }
< 	}
<       }
<       else if (bb->Kind()==BB_REGIONEXIT) {
< 	RID* rid=bb->Regioninfo()->Rid();
< 	if(rid!=NULL) {
< 	  WN* rgn=bb->Regioninfo()->Orig_wn();
< 	  if( rgn!=NULL && WN_operator(rgn)==OPR_REGION)   {
< 	    FB_FREQ out_freq = Cur_PU_Feedback->Query( rgn, FB_EDGE_CALL_OUTGOING);
< 	    if ( bb->Succ() )
< 	      Add_edge( bb->Id(), bb->Nth_succ(0)->Id(), FB_EDGE_OUTGOING, out_freq);
< 	  }
< 	}
<       }
<       else if (! cfg->Removable_bb( bb->Nth_succ(0) ) )
< 	Add_edge( bb->Id(), bb->Nth_succ(0)->Id(), FB_EDGE_OUTGOING, FB_FREQ_ZERO );
<       else 
< #endif
963,996d928
< #if defined (TARG_SL) && defined(TARG_SL2) 
< 	{
< 	  BB_LIST* succs = bb->Succ();
< 	  INT succ_count=0;
< 	  while(succs!=NULL) {
< 	    succ_count++;
< 	    BB_NODE* succbb=succs->Node();
< 	    if(succbb->Kind() == BB_EXIT)
< 	      //according to the cfg building process, the successor bb of BB_EXIT KIND
< 	      // after a region will be used to prevent SSAPRE to do something 
< 	      Add_edge ( bb->Id(), succbb->Id(), FB_EDGE_OUTGOING, FB_FREQ_ZERO);
< 	    else  {
< 	      FB_FREQ freq_out = Cur_PU_Feedback->Query( wn_last, FB_EDGE_CALL_OUTGOING );	
< 	      Add_edge ( bb->Id(), succbb->Id(), FB_EDGE_CALL_OUTGOING, FB_FREQ_UNINIT);
< 	    }
< 	    succs=succs->Next();
< 	  }
< 	}
< 	break;
<       case OPR_REGION_EXIT:
< 	{
< 	  RID* rid=bb->Regioninfo()->Rid();
< 	  if(rid!=NULL) {	
< 	    WN* rgn=bb->Regioninfo()->Orig_wn();
< 	    if( rgn!=NULL && WN_operator(rgn)==OPR_REGION )   {
< 	      FB_FREQ freq_out = Cur_PU_Feedback->Query( rgn, FB_EDGE_CALL_OUTGOING );
< 	      if(bb->Succ()) {
< 		Add_edge( bb->Id(), bb->Nth_succ(0)->Id(), FB_EDGE_OUTGOING,freq_out);
< 	      }
< 	    }
< 	  }	  
<       	}
< 	break;		
< #endif
1061,1063d992
< #if defined (TARG_SL)	
< 	if ( bb->Succ() ) 
< #endif	  	
1823,1824c1752,1753
<   fprintf( fp, "%d nodes:\n", (INT)(_fb_opt_nodes.size() - 1) );
< #endif
---
>   fprintf( fp, "%d nodes:\n", _fb_opt_nodes.size() - 1 );
> #endif /* KEY Mac port */
1833,1834c1762,1763
<   fprintf( fp, "%d edges:\n", (INT)(_fb_opt_edges.size() - 1) );
< #endif
---
>   fprintf( fp, "%d edges:\n", _fb_opt_edges.size() - 1 );
> #endif /* KEY Mac port */
1960,1961c1889,1890
< 		 " = %d)\n", bb->Id(), (INT)_fb_opt_nodes.size() );
< #endif
---
> 		 " = %d)\n", bb->Id(), _fb_opt_nodes.size() );
> #endif /* KEY Mac port */
2105c2034
<     DV->Node_Begin( NODE_ID(INTPTR(nx)), Node_label(nx), *nt );
---
>     DV->Node_Begin( NODE_ID(INT(nx)), Node_label(nx), *nt );
2117,2118c2046,2047
<       DV->Out_Edge( EDGE_ID(NODE_ID(INTPTR(nx)), NODE_ID(INTPTR(nx_dst))),
< 		    *et, NODE_ID(INTPTR(nx_dst)) );
---
>       DV->Out_Edge( EDGE_ID(NODE_ID(INT(nx)), NODE_ID(INT(nx_dst))),
> 		    *et, NODE_ID(INT(nx_dst)) );
opt_fb.cxx
opt_find.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_find.cxx,v $
---
> // $Revision: 1.7 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_find.cxx $
opt_find.cxx
opt_fold.cxx
0a1,4
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_fold.cxx,v $
---
> // $Revision: 1.9 $
> // $Date: 05/03/11 16:42:55-08:00 $
> // $Author: kannann@iridot.keyresearch $
> // $Source: be/opt/SCCS/s.opt_fold.cxx $
477,488d480
< 
<       // bug fix for OSP_130
<       // disabe simplification because SIMPNODE_SimplifyCvtl will not
<       // set the bit_offset and bit_size of EXTRACT_BITS and COMPOSE_BITS,
<       // which is related to lower_level bit_fields operation
<       // TODO: pass the corresponding bit_offset and bit_size
<       //
<       if ((opr == OPR_EXTRACT_BITS || opr == OPR_COMPOSE_BITS) &&
< 		      SIMPNODE_operator(k0) == OPR_SELECT) {
< 	return NOHASH;
<       }
< 
914,919d905
< #ifdef TARG_SL
<       if ( cr->Dtyp() == MTYPE_I2 &&  cr->Dsctyp() == MTYPE_I2) {
<         return OPCODE_make_op(cr->Bit_field_valid() ? OPR_LDBITS : OPR_LDID,
< 			      MTYPE_I4, cr->Dsctyp());
<       } else
< #endif
opt_fold.cxx
opt_htable.cxx
1a2,5
>  * Copyright 2008 PathScale, LLC.  All Rights Reserved.
>  */
> 
> /*
15,18c19,22
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_htable.cxx,v $
---
> // $Revision: 1.44 $
> // $Date: 05/11/02 13:47:36-08:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_htable.cxx $
75d78
< #include "wn_tree_util.h"               // for TREE_ITER
101d103
< #include "opt_alias_mgr.h"
104d105
< #include "opt_sys.h"
468,470d468
< #ifdef TARG_SL2
<        Is_flag_set(CF_INTERNAL_MEM_OFFSET) == cr->Is_flag_set(CF_INTERNAL_MEM_OFFSET) &&
< #endif 
602,603d599
< 	  if (Ilod_ty() != cr->Ilod_ty())
< 	    return FALSE;
786,797c782
<   } else {
< #ifdef Is_True_On
<     extern COMP_UNIT* g_comp_unit;
<     if (Kind () == CK_VAR) {
<       ST* st = g_comp_unit->Opt_stab()->St (Aux_id());
<       if (st && ST_class(st) != CLASS_PREG) {
<         fprintf (fp, " #%s", ST_name(st));
<       }
<     } else if (Kind() == CK_LDA) {
<       fprintf (fp, " #%s", g_comp_unit->Opt_stab()->St_name(Lda_aux_id()));
<     }
< #endif
---
>   } else
799,807d783
<   }
< }
< 
< 
< // this is to make it easier to print codereps in the debugger
< void
< dump_coderep (CODEREP *cr)
< {
<   cr->Print(0,stdout);
872,881d847
< #ifdef TARG_NVISA
<     // maybe it is just me, but I find it confusing that loads were printed
<     // as dsctyp dtyp when whirl has them ordered as dtyp dsctyp.
<     // So switch the order.
<     fprintf(fp, " %s%s", MTYPE_name(Dtyp()), MTYPE_name(Dsctyp()));
<     if (! Bit_field_valid())
<       fprintf(fp, "LDID");
<     else fprintf(fp, "LDBITS");
<     fprintf(fp, " sym%dv%d %d ty=%x ", Aux_id(), Version(), Offset(), Lod_ty());
< #else
889d854
< #endif
1093,1094d1057
<       else if ( rtype == MTYPE_C10 )
< 	return MTYPE_F10;
1112,1113d1074
<       else if ( rtype == MTYPE_F10 )
< 	return MTYPE_C10;
1921,1922d1881
<       // here NOT select #ifdef KEY from pathscale, cause I'm afraid that osprey 
<       // had modified #ifdef KEY to #ifdef TARG_X8664 in last merge.
2165c2124
< #if defined(TARG_X8664) || defined(TARG_NVISA) // bug 5851
---
> #ifdef TARG_X8664 // bug 5851
2184c2143
< #if defined(TARG_X8664) || defined(TARG_NVISA)
---
> #ifdef TARG_X8664
2204c2163
< #if defined(TARG_X8664) || defined(TARG_NVISA)
---
> #ifdef TARG_X8664
2228,2232d2186
< #ifdef TARG_SL
<   if (dtyp == MTYPE_I2 && dsctyp == MTYPE_I2) {
<     dtyp = MTYPE_I4;
<   }
< #endif  
2429c2383
< 		  CODEREP *sbase, OPT_STAB* optstab)
---
> 		  CODEREP *sbase)
2483,2516d2436
<   if (WOPT_Enable_Aggr_Pt_Keep_Track_Ptr) {
<     POINTS_TO* pt = retv->Points_to(optstab);
< 
<     // If the "base is fixed", we don't want to set up the offset 
<     // and CODEREP as indirectly access pointer. The reason is
<     // twofolds: firstly, fixed base + offset is enough for memory 
<     // disambiguation; secondly, the offset field of POINTS_TO
<     // have different meaning when the base-is-fixed and when 
<     // CODEREP is set as a indirect base for the POINTS_TO. 
<     // For fortran cases, Add_idef() may be called upon some WNs 
<     // whose POINTS_TO has fixed base. That is why we need 
<     // condition "!pt->Base_is_fixed() to exclude this case. 
< 
<     if (pt && !pt->Base_is_fixed() && !pt->Pointer_is_coderep_id () 
<         && !pt->Pointer_info_does_help()) {
<       CODEREP* ptr = retv->Ilod_base() ? retv->Ilod_base() : retv->Istr_base();
<       INT32 ofst = retv->Offset();   
<       INT32 sz   = (MTYPE_size_min(retv->Dsctyp()) >> 3); // in bytes
<       if (ptr->Kind() == CK_OP && ptr->Opr () == OPR_ADD) {
<         if (ptr->Opnd(1)->Kind() == CK_CONST) {
<           ofst += ptr->Opnd(1)->Const_val();
<           ptr = ptr->Opnd(0);
<         } else if (ptr->Opnd(0)->Kind() == CK_CONST) {
<           ofst += ptr->Opnd(0)->Const_val();
<           ptr = ptr->Opnd(1);
<         }
<       }
<       pt->Set_pointer_as_coderep_id (ptr->Coderep_id());
<       pt->Set_iofst_kind (OFST_IS_FIXED);
<       pt->Set_byte_size (sz);
<       pt->Set_byte_ofst (ofst);
<     }
<   }
< 
2718d2637
<     case MTYPE_F10:
2722d2640
<     case MTYPE_C10:
3019,3031c2937
<             OPERATOR opr = retv->Opr();
<             CODEREP *retv_op = retv;
<             // may have CVT of ADD/SUB, so look under the CVT;
<             // but then need to move cvt to non-const operand.
<             // but only do this if integer cvt and op under cvt
<             if (opr == OPR_CVT
<               && MTYPE_is_integral(retv->Dtyp())
<               && MTYPE_is_integral(retv->Dsctyp())
<               && retv->Opnd(0)->Kind() == CK_OP)
<             {
<               retv_op = retv->Opnd(0);
<               opr = retv_op->Opr();
<             }
---
>             const OPERATOR opr = retv->Opr();
3034,3045c2940,2941
<                 retv_op->Get_opnd(1)->Kind() == CK_CONST) {
<                   CODEREP *cr = retv_op->Get_opnd(0);
< #ifdef TARG_NVISA
<                   if (retv->Opr() == OPR_CVT) {
<                     // need to preserve cvt
<                     // changing CVT(ADD(x,c)) to scale(CVT(x),c)
<                     DevWarn("pull out constant when cvt(add)");
<                     cr = retv;
<                     cr->Set_opnd(0, retv_op->Get_opnd(0));
<                     cr = Hash_Op(cr); // need to rehash when changing node
<                   }
< #endif
---
>                 retv->Get_opnd(1)->Kind() == CK_CONST) {
>                   CODEREP *cr = retv->Get_opnd(0);
3048c2944
<                   cr = retv_op->Get_opnd(1);
---
>                   cr = retv->Get_opnd(1);
3067,3070d2962
<       if (WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()) {
<         MEMOP_ANNOT* annot = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Get_annot (wn);
<         if (annot) { opt_stab->Cr_sr_annot_mgr()->Import_annot (retv, annot); }
<       }
3092,3096d2983
< #ifdef TARG_SL2
<       if(WN_is_internal_mem_ofst(wn)) {
<         cr->Set_flag(CF_INTERNAL_MEM_OFFSET);
<       }
< #endif 
3185,3186c3072,3073
< 		    base_ccr.Scale(), (CODEREP *)(INTPTR) WN_load_addr_ty(wn),
< 		    lbase, NULL, opt_stab);
---
> 		    base_ccr.Scale(), (CODEREP *) WN_load_addr_ty(wn),
> 		    lbase, NULL);
3263,3268d3149
< 
<     if (WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()) {
<       MEMOP_ANNOT* annot = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Get_annot (wn);
<       if (annot) { opt_stab->Cr_sr_annot_mgr()->Import_annot (retv, annot); }
<     }
< 
3281,3282c3162
< 		    (mINT32)(INTPTR)index, (CODEREP *)(INTPTR) WN_load_addr_ty(wn), 
< 	             base, NULL, opt_stab);
---
> 		    (mINT32)(INTPTR)index, (CODEREP *) WN_load_addr_ty(wn), base, NULL);
3292,3296d3171
< 
<     if (WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()) {
<       MEMOP_ANNOT* annot = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Get_annot (wn);
<       if (annot) { opt_stab->Cr_sr_annot_mgr()->Import_annot (retv, annot); }
<     }
3338c3213
< 		    num_byte, lbase, NULL, opt_stab);
---
> 		    num_byte, lbase, NULL);
3348,3352d3222
< 
<     if (WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()) {
<       MEMOP_ANNOT* annot = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Get_annot (wn);
<       if (annot) { opt_stab->Cr_sr_annot_mgr()->Import_annot (retv, annot); }
<     }
3491c3361
< #if defined(KEY) && !defined(TARG_NVISA)
---
> #ifdef KEY
3495d3364
< #endif
3497d3365
< #ifdef KEY
3509c3377
< #if defined(KEY) && !defined(TARG_NVISA)
---
> #ifdef KEY
3685,3688d3552
< #ifdef    TARG_SL2 //fork_joint
<   case OPR_SL2_FORK_MAJOR:
<   case OPR_SL2_FORK_MINOR:  	
< #endif 
3831c3695
<                                NULL, opt_stab));
---
>                                NULL));
3850d3713
< 	// bug fix for OSP_87 & OSP_90
3857c3720
< 	  info.clobber_string_idx = WN_st_idx(prag);
---
> 	  info.clobber_string_idx = WN_pragma_arg2(prag);
3937,3943d3799
<   if (OPERATOR_is_store (opr)) {
<     if (WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()) {
<       MEMOP_ANNOT* annot = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Get_annot (Wn());
<       if (annot) opt_stab->Cr_sr_annot_mgr()->Import_annot (this, annot);
<     }
<   }
< 
4015,4019d3870
< #ifdef TARG_SL
<         if (dtyp == MTYPE_I2 && dsctyp == MTYPE_I2) {
<           dtyp = MTYPE_I4;
<         }
< #endif
4134,4135c3985
< 				  (CODEREP *)(INTPTR) ilod_base_ty, NULL, 
< 				  lbase, opt_stab) );
---
> 				  (CODEREP *) ilod_base_ty, NULL, lbase) );
4165,4166c4015
< 				(CODEREP *)(INTPTR) ilod_base_ty, NULL, lbase, 
<                                 opt_stab));
---
> 				(CODEREP *) ilod_base_ty, NULL, lbase) );
4215,4216c4064
< 			       num_byte, NULL, lbase,
<                                opt_stab));
---
> 			       num_byte, NULL, lbase));
4259c4107
<       Set_st(opt_stab->St((IDTYPE)(INTPTR)WN_st(Wn())));
---
>       Set_st(opt_stab->St((IDTYPE)WN_st(Wn())));
5045,5050d4892
< void
< dump_stmtrep (STMTREP *sr)
< {
<   sr->Print(stdout);
< }
< 
5494c5336
<   BCOPY(sr,this,sizeof(STMTREP));
---
>   bcopy(sr,this,sizeof(STMTREP));
5533,5534c5375
< 			       cr->Mload_size(), NULL, cr->Istr_base(),
<                                htable->Opt_stab()));
---
> 			       cr->Mload_size(), NULL, cr->Istr_base()));
5600,5951d5440
< /////////////////////////////////////////////////////////////////////////
< //
< //   Implementation of MEMOP_ANNOT_CR_SR_MGR 
< //
< ////////////////////////////////////////////////////////////////////////
< //
< MEMOP_ANNOT_CR_SR_MGR::MEMOP_ANNOT_CR_SR_MGR (MEM_POOL* mp, BOOL trace):
<   MEMOP_ANNOT_MGR(mp) {
< 
<   _imported = BS_Create_Empty (128, _mp);
<   _exported = BS_Create_Empty (128, _mp);
< 
<   _trace = trace;
< }
<  
< // Lookup the corresponding annotation 
< MEMOP_ANNOT*
< MEMOP_ANNOT_CR_SR_MGR::Get_annot (CODEREP* cr) {
<   Is_True (cr != NULL, ("CODEREP is NULL"));
<   CR_2_MEM_ANNOT_MAP::const_iterator iter = _cr_map.find ((const CODEREP*)cr);
<   return iter != _cr_map.end () ? (*iter).second : NULL;
< }
<   
< MEMOP_ANNOT_ITEM*
< MEMOP_ANNOT_CR_SR_MGR::Get_annot (CODEREP* cr, MEM_ANNOT_KIND kind) {
<   Is_True (cr != NULL, ("CODEREP is NULL"));
< 
<   MEMOP_ANNOT* annot = Get_annot (cr);
<   MEMOP_ANNOT_ITEM_VECT& v = annot->All_items ();
<   for (MEMOP_ANNOT_ITEM_ITER iter = v.begin (); iter != v.end (); iter++) {
<     if ((*iter).Kind () == kind) 
<       return &(*iter);
<   }
<   return NULL;
< }
< 
< MEMOP_ANNOT*
< MEMOP_ANNOT_CR_SR_MGR::Get_annot (STMTREP* sr) {
<   Is_True (sr != NULL, ("STMTREP is NULL"));
< 
<   SR_2_MEM_ANNOT_MAP::const_iterator iter = _sr_map.find (sr);
<   return iter != _sr_map.end () ? (*iter).second : NULL;
< }
< 
< MEMOP_ANNOT_ITEM*
< MEMOP_ANNOT_CR_SR_MGR::Get_annot (STMTREP* sr, MEM_ANNOT_KIND kind) {
<   Is_True (sr != NULL, ("STMTREP is NULL"));
< 
<   MEMOP_ANNOT* annot = Get_annot (sr);
<   MEMOP_ANNOT_ITEM_VECT& v = annot->All_items ();
<   for (MEMOP_ANNOT_ITEM_ITER iter = v.begin (); iter != v.end (); iter++) {
<     if ((*iter).Kind () == kind) 
<       return &(*iter);
<   }
< }
< 
< // Associate a MEMOP_ANNOT with given WN/CODEREP/STMTREP
< //
< void
< MEMOP_ANNOT_CR_SR_MGR::Add_annot (CODEREP* cr, const MEMOP_ANNOT_ITEM& annot_item) {
<   Is_True (cr != NULL, ("CODEREP is NULL"));
< 
<   Is_True (cr->Kind() == CK_VAR || cr->Kind() == CK_IVAR, 
<            ("Expression should be load"));
<   MEMOP_ANNOT* annot = Get_annot (cr);  
<   if (annot) 
<     annot->Replace_or_add (annot_item); 
<   else {
<     annot = Alloc_annot ();
<     annot->Replace_or_add (annot_item);
<     _cr_map[cr] = annot; 
<   }
< }
<  
< void
< MEMOP_ANNOT_CR_SR_MGR::Add_annot 
<   (STMTREP* stmt, const MEMOP_ANNOT_ITEM& annot_item) {
< 
<   Is_True (stmt != NULL, ("STMTREP is NULL"));
<   Is_True (OPCODE_is_store (stmt->Op()), ("statement should be store"));
<   
<   MEMOP_ANNOT* annot = Get_annot (stmt);
<   if (annot) 
<     annot->Replace_or_add (annot_item); 
<   else {
<     annot = Alloc_annot ();
<     annot->Replace_or_add (annot_item);
<     _sr_map[stmt] = annot; 
<   }
< }
< 
< void
< MEMOP_ANNOT_CR_SR_MGR::Set_annot (CODEREP* cr, MEMOP_ANNOT* annot) {
< 
<   Is_True (cr != NULL, ("CODEREP is NULL"));
<   Is_True (Alloc_by_this_class (annot), 
<            ("annotation is not allocated by this class"));
<   _cr_map[cr] = annot; 
< }
< 
< void
< MEMOP_ANNOT_CR_SR_MGR::Set_annot (STMTREP* sr, MEMOP_ANNOT* annot) {
<   Is_True (sr != NULL, ("STMTREP is NULL"));
<   Is_True (Alloc_by_this_class (annot), 
<            ("annotation is not allocated by this class"));
<   _sr_map[sr] = annot;
< }
< 
< // Transfer annotation from WN=>MEMOP_ANNOT map.
< //
< MEMOP_ANNOT*
< MEMOP_ANNOT_CR_SR_MGR::Import_annot (CODEREP* cr, MEMOP_ANNOT* annot) {
<   MEMOP_ANNOT* t = Alloc_annot ();
<   *t = *annot;
<   Set_imported (t);
<   Set_annot (cr,t);  
<   Set_imported (t);
<   return t;
< }
< 
< MEMOP_ANNOT*
< MEMOP_ANNOT_CR_SR_MGR::Import_annot (STMTREP* sr, MEMOP_ANNOT* annot) {
<   MEMOP_ANNOT* t = Alloc_annot ();
<   *t = *annot;
<   Set_imported (t);
<   Set_annot (sr,t);  
<   Set_imported (t);
<   return t;
< }
< 
< MEMOP_ANNOT*
< MEMOP_ANNOT_CR_SR_MGR::Import_annot (MEMOP_ANNOT* annot) {
<   MEMOP_ANNOT* t = Alloc_annot ();
<   *t = *annot;
<   Set_imported (t);
<   return t;
< }
< 
< // Transfer the annotation associated with any descendant of <root> 
< // to MEMOP_ANNOT_WN_MAP. If there is only one annotation, we have two
< // options:
< //   - inline the annotation in POINTS_TO, or 
< //   - allocate annot structure and associate it with corresponding WN
< //
< //  Of couse, the 2nd option is more expensive than the 1st.However, 
< //  we have to do that when this function is invoked by LNO preopt because
< //  POINTS_TOs will be discarded soon make the annotation lost. However, 
< //  the life-time of annotation structures is under control of preopt/wopt.
< //
< //  2nd option should be used when <inline_annot> is set, otherwise, 
< //  1st option is used.
< //
< void
< MEMOP_ANNOT_CR_SR_MGR::Export_annot 
<   (WN* root, const ALIAS_MANAGER* am, BOOL inline_annot, BOOL trace) {
< 
<   WN_MEMOP_ANNOT_MGR* wn_annot_mgr = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr(); 
<   Is_True (wn_annot_mgr != NULL, ("Annotation manager is NULL"));
< 
<   if (trace) {
<     fprintf (TFile, "Export memory annotations:\n");
<   }
< 
<   // Clear stale maps
<   wn_annot_mgr->Invalidate ();
< 
<   for (TREE_ITER iter (root); iter.Wn() != NULL; ++iter) {
< 
<     WN* wn = iter.Wn();
<     OPERATOR opr = WN_operator (wn);  
<     if (!OPERATOR_is_load (opr) && !OPERATOR_is_store (opr)) { continue; }
<     
<     if ((OPERATOR_is_scalar_load (opr) || OPERATOR_is_scalar_store (opr)) &&
<         ST_sclass(WN_st(wn)) == SCLASS_REG) {
<       continue;
<     }
< 
<     IDTYPE alias_id = am->Id(wn); 
<     Is_True (alias_id != 0, 
<         ("Function MEMOP_ANNOT_CR_SR_MGR::Export_annot() should be called "
< 	 "after alias ID are generated"));
< 
<     POINTS_TO* pt = am->Pt(alias_id);
<     if (!pt->Has_annotation ()) continue;
<    
<     MEMOP_ANNOT* annot = NULL;
<     PT_MEM_ANNOT& mem_annot = pt->Mem_annot ();
< 
<     if (mem_annot.Item_is_inlined ()) {
< 
<       const MEMOP_ANNOT_ITEM& item = mem_annot.Get_inlined_item ();
<       Is_True (item.Kind() != MEM_ANNOT_INVALID, 
<                ("Invalid item kind is supposed to has been eliminated at this time"));
< 
<       if (!inline_annot) {
<         annot = wn_annot_mgr->Alloc_annot ();  
<         annot->Replace_or_add (item);
<       } else if (trace) {
<         fprintf (TFile, "WN:id%3d is annot with (inlined):<", alias_id);
< 	item.Print (TFile);
< 	fprintf (TFile, ">\n");
<       }
< 
<     } else {
< 
<       MEMOP_ANNOT* t = mem_annot.Get_annots_ptr ();
<       INT item_cnt = t->Item_count();
< 
<       if (inline_annot && item_cnt == 1) {
< 	
< 	// if there is only one annotation, inline it into the POINTS_TO structure.  
< 	//
<         MEMOP_ANNOT_ITEM& item = (*t)[0];
<         mem_annot.Remove_all_annot ();
<         mem_annot.Replace_or_add_annot (item); 
< 	Is_True (mem_annot.Item_is_inlined (), 
< 	         ("Item should be inlined with POINTS_TO structure"));
<         if (trace) {
<           fprintf (TFile, "WN:id%3d is annot with (inlined):<", alias_id);
< 	  item.Print (TFile);
< 	  fprintf (TFile, ">\n");
< 	}
<       } else if (item_cnt > 0) {
<         annot = wn_annot_mgr->Alloc_annot ();  
<         *annot = *t;
<       } else {
<         // number of annotation = 0
<         pt->Mem_annot().Invalidate (); 
<       }
< 
<       Set_exported (t);
<     }
< 
<     if (annot) {
<       Set_exported (annot);
< 
<       wn_annot_mgr->Set_annot (wn, annot); 
<       mem_annot.Remove_all_annot ();
<       mem_annot.Set_annots (annot);
< 
<       if (trace) {
<         fprintf (TFile, "WN:id%3d is annot with:<", alias_id);
<         annot->Print (TFile);
< 	fprintf (TFile, ">\n");
<       }
<     }
<   }
< 
<   if (trace) {
<     INT cnt = 0;
<     fprintf (TFile, "These annotations are not exported:");
< 
<     MOA_VECT_ITER iter = _all_annot.begin (); 
<     Is_True (iter != _all_annot.end(), ("There are at least one element")); 
<     // the first annotation (id:0) is NULL, ignore it
< 
<     for (iter++; iter != _all_annot.end (); iter++) {
<       if (!Is_exported (*iter)) {
<         cnt++;
< 	fprintf (TFile, "%d,", (*iter)->Id());
<       }
<     }
< 
<     if (cnt == 0) { fprintf (TFile, "none"); }
<     fprintf (TFile, "\n");
<   }
< }
< 
< // When active WN_MEMOP_ANNOT_MGR is NULL, we need to discard the "offline" 
< // annotation in that "offline" data structure will be allocated by 
< // WN_MEMOP_ANNOT_MGR.
< // 
< void
< MEMOP_ANNOT_CR_SR_MGR::Discard_offline_annot 
<   (WN* root, const ALIAS_MANAGER* am, BOOL trace) {
< 
<   WN_MEMOP_ANNOT_MGR* wn_annot_mgr = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr(); 
<   Is_True (wn_annot_mgr == NULL, ("Annotation manager is supposed to be NULL"));
< 
<   if (trace) {
<     fprintf (TFile, "Discard offline annotations:\n");
<   }
< 
<   for (TREE_ITER iter (root); iter.Wn() != NULL; ++iter) {
< 
<     WN* wn = iter.Wn();
<     OPERATOR opr = WN_operator (wn);  
<     if (!OPERATOR_is_load (opr) && !OPERATOR_is_store (opr)) { continue; }
<     
<     if ((OPERATOR_is_scalar_load (opr) || OPERATOR_is_scalar_store (opr)) &&
<         ST_sclass(WN_st(wn)) == SCLASS_REG) {
<       continue;
<     }
< 
<     IDTYPE alias_id = am->Id(wn); 
<     Is_True (alias_id != 0, 
<         ("Function MEMOP_ANNOT_CR_SR_MGR::Export_annot() should be called "
< 	 "after alias ID are generated"));
< 
<     POINTS_TO* pt = am->Pt(alias_id);
<     if (!pt->Has_annotation ()) continue;
<    
<     PT_MEM_ANNOT& mem_annot = pt->Mem_annot ();
<     if (!mem_annot.Item_is_inlined ()) {
<       mem_annot.Invalidate ();
<     }
<   }
< }
< 
< void
< MEMOP_ANNOT_CR_SR_MGR::Print (FILE* f, BOOL verbose) const {
<   
<   fprintf (f, "Memory annotations are:\n%s", DBar);
<    
<   for (MOA_VECT_CITER iter = _all_annot.begin (); 
<        iter != _all_annot.end(); iter++) {
< 
<     MEMOP_ANNOT* p = *iter;
<     if (p) { p->Print (f); fprintf (f,"\n"); }
<   }
< 
<   fprintf (f, "Imported annotations are:");  
<   BS_Print (_imported, f);
<   fprintf (f, "\n");
< 
<   fprintf (f, "Exported annotations are:");  
<   BS_Print (_exported, f);
<   fprintf (f, "\n");
< 
<   if (!verbose) { fprintf (f, "\n"); return; }
< 
<   for (CR_2_MEM_ANNOT_MAP::const_iterator iter = _cr_map.begin ();
<        iter != _cr_map.end (); iter++) {
<     const CR_MEMANNOT_PAIR& pair = *iter; 
<     fprintf (f, "CR%d <", pair.first->Coderep_id());
<     pair.first->Print_node (0, f);
<     fprintf (f, "is annotated with:");
<     pair.second->Print (f);
<     fprintf (f, "\n");
<   }
<    
<   for (SR_2_MEM_ANNOT_MAP::const_iterator iter = _sr_map.begin ();
<        iter != _sr_map.end (); iter++) {
<     const SR_MEMANNOT_PAIR& pair = *iter; 
<     fprintf (f, "stmt<");
<     pair.first->Print_node (f);
<     fprintf (f, "> is annotated with:"); 
<     pair.second->Print (f);
<     fprintf (f, "\n");
<   }
<   fprintf (f, "\n");
< }
opt_htable.cxx
opt_htable_emit.cxx
0a1,4
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_htable_emit.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 05/05/06 08:36:10-07:00 $
> // $Author: bos@eng-24.pathscale.com $
> // $Source: be/opt/SCCS/s.opt_htable_emit.cxx $
506,513d509
< 
<   if (Opt_stab()->Phase() == MAINOPT_PHASE) {
<     BOOL tr = Trace() || Get_Trace (TP_GLOBOPT, ALIAS_DUMP_FLAG);
<     Opt_stab()->Cr_sr_annot_mgr()->
<       Export_annot (_opt_func, _alias_mgr, TRUE, tr);
<     WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Set_active_mgr();  
<   }
< 
opt_htable_emit.cxx
opt_ivr.cxx
3a4,7
>  * Copyright 2007 (C) PathScale, LLC.  All Rights Reserved.
>  */
> 
> /*
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ivr.cxx,v $
---
> // $Revision: 1.19 $
> // $Date: 05/02/25 21:07:11-08:00 $
> // $Author: fchow@fluorspar.keyresearch $
> // $Source: be/opt/SCCS/s.opt_ivr.cxx $
opt_ivr.cxx
opt_lclsc.cxx
opt_lclsc.cxx
opt_leaf_iter.cxx
6,8c6,8
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
---
> // $Revision$
> // $Date$
> // $Author$
opt_leaf_iter.cxx
opt_lftr2.cxx
14,17c14,17
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_lftr2.cxx,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_lftr2.cxx $
opt_lftr2.cxx
opt_lmv.cxx
opt_lmv.cxx
opt_lmv_helper.cxx
opt_lmv_helper.cxx
opt_loop.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_loop.cxx,v $
---
> // $Revision: 1.7 $
> // $Date: 05/11/30 21:00:36-08:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_loop.cxx $
1245d1244
< #if !defined(OSP_OPT) || !defined(TARG_IA64)
1247c1246
< #endif
---
> 
1272,1273d1270
<   if ( cmp->Get_opnd(1)->Kind() != CK_CONST && loop->Exit_early())
<     return RAISE(FALSE, "early exit without const comparison");
opt_loop.cxx
opt_loop_trans.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_loop_trans.cxx,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_loop_trans.cxx $
382c382
< 		  (INT)new_loop.size(), (INT)ends.size());
---
> 		  new_loop.size(), ends.size());
opt_loop_trans.cxx
opt_ltable.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ltable.cxx,v $
---
> // $Revision: 1.14 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_ltable.cxx $
opt_ltable.cxx
opt_main.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_main.cxx,v $
---
> // $Revision: 1.23 $
> // $Date: 05/10/15 13:29:13-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_main.cxx $
351d350
< #ifndef __MINGW32__
353d351
< #endif /* __MINGW32__ */
355,358c353
< #include "opt_wovp.h"     // for write once variable promotion
< #include "opt_misc.h"
< #include "opt_lmv.h"
< #include "opt_lmv_helper.h"
---
> 
364c359
< #if defined(__linux__) || defined(STATIC_BUILD) || defined(BUILD_OS_DARWIN)
---
> #if defined(__linux__) || defined(BUILD_OS_DARWIN)
513d507
<   BOOL  _wovp; /* Write-once variable promotion   */
519c513
<   BOOL  _loop_multiver;   // loop multiversioning 
---
> 
560d553
<       WOPT_Enable_WOVP =
575d567
<       WOPT_Enable_WOVP = FALSE;
676,677d667
<     
<     if (_phase != PREOPT_LNO_PHASE) WOPT_Enable_Loop_Multiver = FALSE;
718d707
<       WOPT_Enable_WOVP           = _wovp;
727d715
<       WOPT_Enable_WOVP           = _wovp;
768d755
<     WOPT_Enable_Loop_Multiver = _loop_multiver;
828d814
<     _wovp = WOPT_Enable_WOVP; /* Write-once variable promotion  */
843d828
<     _loop_multiver = WOPT_Enable_Loop_Multiver;
920d904
< #ifndef __MINGW32__
931d914
< #endif /* __MINGW32__ */
940d922
< #ifndef __MINGW32__
952d933
< #endif /* __MINGW32__ */
1097,1100d1077
<   if (Get_Trace(TP_GLOBOPT, -1)) {
<     fprintf (TFile,  "%s \t Pre_Optimizer phase=%d\n %s\n", DBar, phase, DBar);
<   }
< 
1169,1171d1145
< #ifdef KEY
< 	LOWER_UPLEVEL |
< #endif
1185,1186d1158
< #elif defined(TARG_SL)
<     BOOL target_64bit = FALSE;
1196c1168
< #if defined(KEY) && !(defined(TARG_IA64) || defined(TARG_SL))
---
> #ifdef KEY
1331,1334d1302
<   if (WOPT_Enable_Pt_Summary) {
<     comp_unit->Opt_stab()->Points_to_summarizer()->
<        Bind_callee_points_to_summary (wn_tree);
<   }
1425,1429d1392
<   if (WOPT_Enable_Pt_Summary) {
<     SET_OPT_PHASE("Points-to Summary Annotation");
<     comp_unit->Opt_stab()->Points_to_summarizer()->
<        Annotate_points_to_summary();
<   }
1439d1401
<   Analyze_pu_attr (comp_unit->Opt_stab(), Opt_current_pu_st);
1625,1629d1586
<   if(WOPT_Enable_WOVP){
<      WOVP wovp(comp_unit->Cfg(), comp_unit->Opt_stab());
<      wovp.Do_wovp();
<   }
< 
1843,1847d1799
<     if (WOPT_Enable_Loop_Multiver) {
<       LOOP_MULTIVER lm (comp_unit);
<       lm.Perform_loop_multiversioning ();
<     }
< 
1947,1949d1898
< 
<   WN_CopyMap(opt_wn, WN_MAP_FEEDBACK, wn_orig);
< 
opt_main.cxx
opt_min_essa.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_min_essa.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_min_essa.cxx
opt_misc.cxx
opt_misc.cxx
opt_mtype_b.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_mtype_b.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_mtype_b.cxx
opt_mu_chi.cxx
126,135d125
< 
<     // transfer the mem-op annotation 
<     if ((occ->Is_load() || occ->Is_store()) && 
<       WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()) {
<       MEMOP_ANNOT* annot = WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Get_annot(wn);
<       if (annot) {
<         MEMOP_ANNOT* t = Cr_sr_annot_mgr()->Import_annot (annot);
<         occ->Points_to()->Mem_annot().Set_annots (t);
<       }
<     }
opt_mu_chi.cxx
opt_pch.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_pch.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_pch.cxx
opt_project.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_project.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_project.cxx $
opt_project.cxx
opt_prop.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_prop.cxx,v $
---
> // $Revision: 1.23 $
> // $Date: 05/07/20 20:47:32-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_prop.cxx $
189,190c189
<   INT32 weight = 0;
<   if (!Propagatable(rhs, FALSE, 0, FALSE, FALSE, &height, &weight, FALSE ,NULL))
---
>   if (!Propagatable(rhs, FALSE, 0, FALSE, FALSE, &height, FALSE, NULL))
328,329c327,328
< 		       BOOL inside_cse, INT32 *height, INT32 *weight,
< 		       BOOL in_array, BB_NODE *curbb)
---
> 		       BOOL inside_cse, INT32 *height, BOOL in_array,
> 		       BB_NODE *curbb)
333d331
<   INT32 weight0 = 0;
339d336
<     *weight = 1;
354d350
<     *weight = 1;
390c386
<                           icopy_phase, inside_cse, height, weight, in_array, curbb);
---
>                           icopy_phase, inside_cse, height, in_array, curbb);
399c395
<                              icopy_phase, inside_cse, &height0, &weight0, in_array, curbb);
---
>                              icopy_phase, inside_cse, &height0, in_array, curbb);
402d397
< 	*weight += weight0;
416d410
<       (*weight)++;
432c426,431
<     if (icopy_phase && !x->Is_isop_flag_set(ISOP_ICOPY_VISITED)) {
---
>     if (icopy_phase) {
>       if (x->Is_isop_flag_set(ISOP_ICOPY_VISITED)) {
> 	*height = 1;	// don't really know the height, so return 1
>         return (PROPAGATABILITY) (0x3 & x->Propagatability()); // to prevent sign extension
>       }
>       else {
435a435,445
>     }
>     else {
>       if (x->Is_isop_flag_set(ISOP_COPY_VISITED)) {
> 	*height = 1;	// don't really know the height, so return 1
>         return (PROPAGATABILITY) (0x3 & x->Propagatability()); // to prevent sign extension
>       }
>       else {
> 	x->Set_isop_flag(ISOP_COPY_VISITED);
>         Add_visited_node(x);
>       }
>     }
460d469
<     *weight = 0;
463,464c472
< 			   icopy_phase, inside_cse, &height0, &weight0,
< 			   in_array, curbb);
---
> 			   icopy_phase, inside_cse, &height0, in_array, curbb);
467d474
<       *weight += weight0;
478,479c485
<     if (*height >= WOPT_Enable_Prop_Limit || 
< 	*weight >= WOPT_Enable_Prop_Weight_Limit) { // exceeds prop limit
---
>     if (*height >= WOPT_Enable_Prop_Limit) { // exceeds prop limit
486d491
<     (*weight)++;
959c964
<     if (ST_is_const_initialized_scalar(st, psym->St_ofst(), init_tcon))
---
>     if (ST_is_const_initialized_scalar(st, init_tcon))
1145c1150
<   INT32 height, weight;
---
>   INT32 height;
1154c1159
< 			&weight, in_array, curbb);
---
> 			in_array, curbb);
1236c1241
<   INT32 height, weight;
---
>   INT32 height;
1238c1243
< 		      icopy_phase, inside_cse, &height, &weight, in_array, curbb);
---
> 		      icopy_phase, inside_cse, &height, in_array, curbb);
1441c1446
< #if defined(KEY) && !defined(TARG_NVISA)
---
> #ifdef KEY
1445,1448c1450
<         else {
< 	  // OSP_384
< 	  if(opr == OPR_ASM_INPUT)
< 	    x->Opnd(i)->Set_flag(CF_DONT_PROP);
---
>         else
1450d1451
< 	}
1452,1454d1452
< 	// for NVISA, the usage of asm is an array of const val,
< 	// then was passing arr[3] and was seeing the array node
< 	// rather than the const val under the asm_input
1708c1706
<   INT32 height, weight;
---
>   INT32 height;
1711c1709
< 		     &height, &weight, FALSE/*in_array*/, NULL) == PROPAGATABLE)
---
> 		     &height, FALSE/*in_array*/, NULL) == PROPAGATABLE)
1919c1917
<   INT32 height, weight;
---
>   INT32 height;
1930c1928
< 		     &height, &weight, FALSE/*in_array*/, NULL) == PROPAGATABLE)
---
> 		     &height, FALSE/*in_array*/, NULL) == PROPAGATABLE)
1946c1944
<   INT32 height, weight;
---
>   INT32 height;
1973c1971
< 		     &height, &weight, FALSE/*in_array*/, NULL) == PROPAGATABLE)
---
> 		     &height, FALSE/*in_array*/, NULL) == PROPAGATABLE)
opt_prop.cxx
opt_region_emit.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_region_emit.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_region_emit.cxx
opt_rename.cxx
0a1,4
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rename.cxx,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_rename.cxx $
342,344c346
< 	      (is_mu || cr->Dsctyp() == MTYPE_BS ? 
< 				tmp : 
< 				cr->Convert_type(htable, tmp, FALSE)) :
---
> 	      (is_mu ?  tmp : cr->Convert_type(htable, tmp, FALSE)) :
opt_rename.cxx
opt_revise_ssa.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_revise_ssa.cxx,v $
---
> // $Revision: 1.20 $
> // $Date: 05/09/15 15:45:49-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_revise_ssa.cxx $
180c180
<   BZERO(wn, sizeof(WN));
---
>   bzero(wn, sizeof(WN));
253c253
<       BZERO (&wn, sizeof(WN));
---
>       bzero(&wn, sizeof(WN));
370c370
<           BZERO(&wn, sizeof(WN));
---
>           bzero(&wn, sizeof(WN));
558c558
<           BZERO(&wn, sizeof(WN));
---
>           bzero(&wn, sizeof(WN));
638,640d637
<       // Original code used mclass to get rtype,
<       // but have since added mtype to sym, 
<       // and mtype is more accurate than mclass (preserves sign
1195,1198d1191
<           TY_IDX stbits_tyidx = Void_Type;
< 	  if (opr == OPR_STBITS) {
< 	    stbits_tyidx = MTYPE_To_TY(lhs->Dsctyp());
< 	  }
1244c1237
< 	      v->Dtyp(), v->Dsctyp(), v->Offset(), stbits_tyidx, 0, TRUE));
---
> 	      v->Dtyp(), v->Dsctyp(), v->Offset(), Void_Type, 0, TRUE));
1248c1241
< 	    lhs->Dtyp(), lhs->Dsctyp(), lhs->Offset(), stbits_tyidx, 0, TRUE));
---
> 	    lhs->Dtyp(), lhs->Dsctyp(), lhs->Offset(), Void_Type, 0, TRUE));
1286,1287c1279,1280
< 			  lhs->Offset(), (CODEREP *)(INTPTR)Make_Pointer_Type(Void_Type), 
<    		      NULL, lhs->Istr_base(), _opt_stab));
---
> 			  lhs->Offset(), (CODEREP *)Make_Pointer_Type(Void_Type), 
>    		      NULL, lhs->Istr_base()));
1356c1349
<     if (x->Is_var_volatile() || _opt_stab->Is_volatile(cr->Scalar_aux_id())) 
---
>     if (x->Is_var_volatile())
1372,1382d1364
<     // if sizes don't match, add cvt
<     if (MTYPE_is_integral(x->Dtyp()) 
<       && MTYPE_byte_size(cr->Dtyp()) != MTYPE_byte_size(x->Dtyp())) 
<     {
<       DevWarn("insert cvt above zero-version");
<       CODEREP cvt_cr;
<       cvt_cr.Init_expr(OPCODE_make_op(OPR_CVT, cr->Dtyp(), x->Dtyp()), x);
<       x = _htable->Rehash(&cvt_cr);
<     }
<     else
<       x->Set_dtyp(cr->Dtyp());
opt_revise_ssa.cxx
opt_rvi.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rvi.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_rvi.cxx $
1312,1344d1311
< // this function is used to decide if nth parameter in following intrinsic function need 
< // to do RVI optimization. These parameter is address  expression and is offset from
< // internal buffer start address.
< // ====================================================================
< 
< #if defined(TARG_SL)
< BOOL 
< RVI::Is_Intrncall_Nth_Parm_Need_RVI(INTRINSIC id,  INT nth_parm ) {
<   switch(id) {
<   case INTRN_C2_LD_C_IMM:
<   case INTRN_C2_ST_C_IMM:				
<     if(nth_parm == 1) return TRUE;
<     return FALSE;
<   case INTRN_C2_LD_V2G_IMM:
<   case INTRN_C2_ST_G2V_IMM:		
<   case INTRN_C2_LD_G_IMM:
<   case INTRN_C2_ST_G_IMM:			
<     if(nth_parm == 2) return TRUE;
<     return FALSE;
<   case INTRN_C2_ST_V_IMM:
<     if(nth_parm == 3) return TRUE;
<     return FALSE;
<   case INTRN_C2_LD_V_IMM:
<     if(nth_parm == 4) return TRUE;
<     return FALSE;
<   default:
<     return FALSE;
<   }
<   return FALSE;
< }
< #endif
< 
< // ====================================================================
1371,1378d1337
< #ifdef TARG_SL
<       // the parameter one in the two intrinsic functions are used as offset relative to 
<       // vbuf start address. We don't want to these two parameter to be screening out
<       // since we need allocate special handling when expanding the intrinsic call 
<      if( (opr==OPR_INTRINSIC_CALL || opr == OPR_INTRINSIC_OP)  && 
< 	 Is_Intrncall_Nth_Parm_Need_RVI(WN_intrinsic(wn), ikid)) 
<        continue; 
< #endif 
opt_rvi.cxx
opt_rvi_emit.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rvi_emit.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_rvi_emit.cxx
opt_rvilr.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rvilr.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_rvilr.cxx
opt_rvitab.cxx
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rvitab.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
175,177d174
< #ifdef TARG_SL
<       return (((UINT32)opc+val+(UINT32)WN_lda_offset(wn) + (UINT32)WN_is_internal_mem_ofst(wn)) % RVI_CTAB_SIZE);
< #else 
179d175
< #endif
opt_rvitab.cxx
opt_rviwn.cxx
opt_rviwn.cxx
opt_speculate.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_speculate.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_speculate.cxx $
58d57
< #include <vector>
266c265
<     fprintf(TFile, " num components=%d\n", (INT)component.size());
---
>     fprintf(TFile, " num components=%d\n", component.size());
opt_speculate.cxx
opt_spre_finalize.cxx
2a3,6
> //
> //  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
> //
> // ====================================================================
6,9c10,13
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_spre_finalize.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_spre_finalize.cxx
opt_ssa.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ssa.cxx,v $
---
> // $Revision: 1.24 $
> // $Date: 05/09/15 15:45:49-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_ssa.cxx $
879,880d878
<       if (_opt_stab->Cr_sr_annot_mgr ())
<         _opt_stab->Cr_sr_annot_mgr()->Print (TFile);
894,897d891
<   
<   // Clear WN annotation map lest we accidently use it in preopt/wopt.
<   if (WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()) 
<     WN_MEMOP_ANNOT_MGR::WN_mem_annot_mgr()->Invalidate ();
1047,1048c1041,1042
<     // begin - fix for bug OSP 194
<     if( opt_stab->Is_volatile(aux_id) )
---
> #ifdef KEY
>     if (opt_stab->Is_volatile(aux_id))
1050c1044
<     // end - fix for bug OSP 194 
---
> #endif
1084d1077
<       Is_True(!(dtype==MTYPE_I2 && rtype== MTYPE_I2), ("Create illegal coderep i2i2"));
1265,1271d1257
< #ifdef TARG_SL //fork_joint
<     if(WN_is_compgoto_para(wn)) 
<        stmt->Set_fork_stmt_flags(TRUE);
<     else if(WN_is_compgoto_for_minor(wn)) 
< 	stmt -> Set_minor_fork_stmt_flags(TRUE);
< #endif 
< 
opt_ssa.cxx
opt_ssu.cxx
10,13c10,13
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ssu.cxx,v $
---
> // $Revision: 1.9 $
> // $Date: 05/08/15 23:44:00-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_ssu.cxx $
146,148c146
<     // fix bug no OSP_52
<     if (cr->Dtyp() == MTYPE_V || cr->Dtyp() == MTYPE_UNKNOWN ||
< 	cr->Dsctyp() == MTYPE_V || cr->Dsctyp() == MTYPE_UNKNOWN)
---
>     if (cr->Dtyp() == MTYPE_V || cr->Dtyp() == MTYPE_UNKNOWN)
opt_ssu.cxx
opt_stable.cxx
10,13c10,13
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_stable.cxx,v $
---
> // $Revision: 1.8 $
> // $Date: 05/08/12 12:08:13-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_stable.cxx $
518,522c518,519
<         // NVISA hits this cause aggcm off by default,
< 	// fred doesn't remember why assertion is there, and code seems
< 	// fine without it, so ifdef it out.
<         // Is_True(WOPT_Enable_Aggressive_Code_Motion,
< 	//    ("EXP_WORKLST::SPRE_perform_insert_delete: cannot find phi for preg %d at BB%d", Preg(), defbb->Id()));
---
>         Is_True(WOPT_Enable_Aggressive_Code_Motion,
> 	    ("EXP_WORKLST::SPRE_perform_insert_delete: cannot find phi for preg %d at BB%d", Preg(), defbb->Id()));
opt_stable.cxx
opt_sym.cxx
1a2,4
>  * Copyright 2007 PathScale, LLC.  All Rights Reserved.
>  */
> /*
15,18c18,21
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_sym.cxx,v $
---
> // $Revision: 1.37 $
> // $Date: 05/06/27 19:22:30-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_sym.cxx $
154,156c157
< OPT_STAB::OPT_STAB(MEM_POOL *pool) : aux_stab(pool), 
<   _ac_2_vsym_map(256, (IDTYPE)0, pool, FALSE),
<   _pt_sum(pool)
---
> OPT_STAB::OPT_STAB(MEM_POOL *pool) : aux_stab(pool)
196,202d196
< 
<   _ac_2_vsym_map.Init ();
<   _pt_sum.Set_opt_stab (this);  
< 
<   BOOL t = Get_Trace (TP_GLOBOPT, CR_DUMP_FLAG);
<   _cr_sr_annot_mgr = CXX_NEW (MEMOP_ANNOT_CR_SR_MGR (mem_pool, t), mem_pool);
<   _cr_sr_annot_mgr->Set_active_mgr ();
212,213d205
<   CXX_DELETE (_cr_sr_annot_mgr, _cr_sr_annot_mgr->Mem_pool());
< 
484,507d475
<   // Count in pointers which have points-to records in the points-to- 
<   // summary of this callee.
<   // 
<   if (WN_operator(wn) == OPR_CALL && WOPT_Enable_Pt_Summary) {
<     PU_POINTS_TO_SUMMARY* sum = _pt_sum.Get_bound_pt_sum (wn);
<     if (sum) {
<       UNAME_VECTOR& ptrs = sum->Out_set().Name_space()->All_names();  
<       for (UNAME_VECTOR_ITER iter = ptrs.begin (); 
<            iter != ptrs.end (); iter++) {
<         UNIFORM_NAME* name = *iter;  
<         if (name->Type () == UN_NAMED_GLOBAL) {
< 	  ST* st = name->ST_for_named_global ();
<           ST_CHAIN_INFO *st_chain_info = st_chain_map->Lookup(ST_index(st));
<           if (st_chain_info == NULL) {
<             aux_sym_cnt++;
<             st_chain_info = CXX_NEW(ST_CHAIN_INFO, &_st_chain_pool);
<             st_chain_info->Set_list_head(aux_sym_cnt);
<             st_chain_map->Insert(ST_st_idx(st), st_chain_info);
< 	  }
< 	}
<       } /* end of for-loop */
<     }
<   }
< 
709d676
<   TY_IDX hl_ty = (TY_IDX)0;
760,763d726
<     if (WN_field_id(wn) != (TY_IDX)0) {
<       UINT32 dummy;
<       WN_hl_object_ty(wn, hl_ty, dummy);
<     }
806,809d768
<     if (WN_field_id(wn) != (TY_IDX)0) {
<       UINT32 dummy;
<       WN_hl_object_ty(wn, hl_ty, dummy);
<     }
934,935d892
<   sym->Set_def_bbs(NULL);  
< 
939a897
> 
977d934
<   sym->Points_to()->Set_hl_ty(hl_ty);
1181,1183d1137
< 
<   sym->Set_def_bbs(NULL);
<   
1214,1222d1167
< #ifdef TARG_NVISA
<   // want to find def for filling in home_wn of preg,
<   // which is needed for correct memory state info in Find_Lda.
<   WN *home_wn = NULL;
<   if (cr->Defstmt() && cr->Defstmt()->Rhs()) {
<     home_wn = cr->Defstmt()->Rhs()->Rvi_home_wn(opt_stab);
<   }
<   mINT64 offset = opt_stab->Alloc_preg(preg_ty, name, home_wn);
< #else
1224d1168
< #endif
2524,2530d2467
<       // Do not discard the high-level type which may be different from
<       // object-type. This is an example: "LDID agg.field". The agg.field
<       // is treated as a separate symbol (i.e. it has unique aux_id) by 
<       // Enter_symbol(). The pt->Ty() record the type-of(agg.field), and
<       // pt->Highlevel_ty() records type-of(agg).
<       //
<       TY_IDX hl_ty = pt->Highlevel_Ty();
2543,2546d2479
< 
<       if (hl_ty != (TY_IDX)0 && pt->Highlevel_Ty() == (TY_IDX)0) {
< 	pt->Set_hl_ty(hl_ty);
<       }
2653a2587,2588
> 
> 
2761d2695
< 
3166,3181d3099
<   if ((OPERATOR_is_load (opr) || OPERATOR_is_store (opr)) &&
<        WOPT_Enable_Vsym_Unique) {
<       IDTYPE ac = _alias_classification->Alias_class(memop_wn);
<       if (ac != OPTIMISTIC_AC_ID && ac != PESSIMISTIC_AC_ID) {
<           AUX_ID vsym_id = _ac_2_vsym_map.Lookup(ac);
<         if (vsym_id == (AUX_ID)0) {
<           vsym_id = Create_vsym(EXPR_IS_ANY);
<           AUX_STAB_ENTRY *vsym = Aux_stab_entry(vsym_id);
<           vsym->Set_stype(VT_UNIQUE_VSYM);
<           vsym->Points_to()->Set_alias_class (ac);
<           _ac_2_vsym_map.Insert(ac, vsym_id);
<         }
<         return vsym_id;
<      }
<   }
< 
opt_sym.cxx
opt_tail.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_tail.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_tail.cxx $
485,487d484
< #ifdef __MINGW32__
<     char *new_str = (char *) __builtin_alloca (len);
< #else
489d485
< #endif /* __MINGW32__ */
opt_tail.cxx
opt_u64_lower.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_u64_lower.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_u64_lower.cxx $
opt_u64_lower.cxx
opt_util.cxx
1,4d0
< /*
<  * Copyright 2005-2007 NVIDIA Corporation.  All rights reserved.
<  */
< 
15,18c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_util.cxx,v $
---
> // $Revision: 1.8 $
> // $Date: 05/09/21 19:23:40-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_util.cxx $
76,78d71
< #if defined(TARG_SL)
< #include "intrn_info.h"
< #endif
242,244d234
< #ifdef __MINGW32__
<     DevWarn("sbrk not supported on Win NT");
< #else
246d235
< #endif /* __MINGW32__ */
461c450
< #elif defined(TARG_X8664) || defined(TARG_NVISA)
---
> #elif defined(TARG_X8664)
660,671d648
< 
< #if defined(TARG_SL)
< BOOL CR_Intrinsic_Op_Slave( CODEREP *cr) {
<   if (cr->Kind() == CK_OP && cr->Opr() == OPR_INTRINSIC_OP) {
<     INTRINSIC ins = cr->Intrinsic();
<     if (INTRN_is_slave(ins))
<       return TRUE;
<   }
<   return FALSE;
< }
< #endif
< 
opt_util.cxx
opt_verify.cxx
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_verify.cxx,v $
---
> // $Revision: 1.7 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_verify.cxx $
opt_verify.cxx
opt_vn.cxx
3a4,7
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
> /*
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vn.cxx,v $
---
> // $Revision: 1.8 $
> // $Date: 04/12/23 16:50:47-08:00 $
> // $Author: kannann@iridot.keyresearch $
> // $Source: be/opt/SCCS/s.opt_vn.cxx $
885d888
< 
opt_vn.cxx
opt_vn_expr.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vn_expr.cxx,v $
---
> // $Revision: 1.9 $
> // $Date: 05/06/24 15:12:00-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_vn_expr.cxx $
309d308
<    case MTYPE_F10:
opt_vn_expr.cxx
opt_vnfre.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vnfre.cxx,v $
---
> // $Revision: 1.8 $
> // $Date: 04/12/21 14:57:20-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_vnfre.cxx $
571,574d570
<    // bug fix for OSP_101 & & OSP_103 & OSP_117 & OSP_189
<    //
<    BOOL _check_cr_compatible (VN_VALNUM valnum);
<    
850,856d845
< 	 
< 	 // bug fix for OSP_101 & OSP_103 $ OSP_117 & OSP_189		
< 	 //
< 	 if (_check_cr_compatible(valnum)) {
< 	   _set_do_vnfre(valnum, FALSE);
< 	   continue;
< 	 }
1229,1265d1217
< // bug fix for OSP_101 & OSP_103 & OSP_117 & OSP_189
< // check the compatibility of codereps which are mapped to the same value number,
< // they are not compatible, if Dtyp() and Dsctyp() of one coderep are all MTYPE_B,
< // while there existing coderep whose Dtyp() and Dsctyp() are all not MTYPE_B
< // TODO: Is it better to do not map these uncompatible codereps to the same value number?
< //
< BOOL
< VALNUM_FRE::_check_cr_compatible (VN_VALNUM valnum)
< {
<    BOOL has_uncompatible_cr = FALSE;
<    BOOL mtype_bool = FALSE;
<    BOOL mtype_non_bool = FALSE;
< 
<    EXP_WORKLST *worklist = _worklst(valnum);
<    EXP_OCCURS  *occ;
<    EXP_OCCURS_ITER  occ_iter;
< 
<    if (worklist == NULL)
<      return has_uncompatible_cr;
<    FOR_ALL_NODE(occ, occ_iter, Init(worklist->Real_occurs().Head()))
<    {
<      CODEREP *cr = occ->Occurrence();
<      if (cr->Dtyp() == MTYPE_B && cr->Dsctyp() == MTYPE_B)
<        mtype_bool = TRUE;
<      else if (cr->Dtyp() != MTYPE_B && cr->Dsctyp() != MTYPE_B)
<      //else if (cr->Dtyp() == MTYPE_I4 && cr->Dsctyp() == MTYPE_I4)
<        mtype_non_bool = TRUE;
< 
<      if (mtype_bool == TRUE && mtype_non_bool == TRUE) {
<        has_uncompatible_cr = TRUE;
<      }
<    }
<    
<    return has_uncompatible_cr;
< }
< 
< 
1551,1552c1503,1504
< 		   rhs->Check_if_result_is_address(_etable->Htable()->Sym()),
< 		   rhs);
---
> 			   rhs->Check_if_result_is_address(_etable->
> 							   Htable()->Sym()));
opt_vnfre.cxx
opt_whirlview.cxx
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_whirlview.cxx,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:20-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_whirlview.cxx $
81d80
< #include "intrn_info.h"
opt_whirlview.cxx
opt_wn.cxx
3a4,7
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
> /*
11,14c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_wn.cxx,v $
---
> // $Revision: 1.31 $
> // $Date: 05/09/15 15:45:49-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_wn.cxx $
543d546
<     case MTYPE_F10:	return OPC_F10F10LDID;
547,549d549
< #ifdef TARG_IA64
<     case MTYPE_C10:	return OPC_C10C10LDID;
< #endif
570a571
>     case MTYPE_F10:
658,660d658
< #if defined(TARG_IA64)
<       case 32: return MTYPE_C10;
< #else
663d660
< #endif
670,672d666
< #if defined(TARG_IA64)
<       case 16: return MTYPE_F10;
< #else
675d668
< #endif
757,759d749
< #if defined(TARG_IA64)
<       case 32: return OPC_C10C10LDID;
< #else
762d751
< #endif
769,771d757
< #if defined(TARG_IA64)
<       case 16: return OPC_F10F10LDID;
< #else
774d759
< #endif
856,858d840
< #if defined(TARG_IA64)
<       case 32: return OPC_C10STID;
< #else
861d842
< #endif
868,870d848
< #if defined(TARG_IA64)
<       case 16: return OPC_F10STID;
< #else
873d850
< #endif
opt_wn.cxx
opt_wovp.cxx
opt_wovp.cxx
wodriver.cxx
0a1,7
> /*
>  * Copyright (C) 2007. PathScale, LLC. All Rights Reserved.
>  */
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
5,8c12,15
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/wodriver.cxx,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
92d98
< 
119a126
> 
122,125c129
< #if 0
<   extern INT32 WOPT_Unroll_Skip;
<   WOPT_Unroll_Skip_List = Build_Skiplist ( WOPT_Unroll_Skip );
< #endif
---
> 
wodriver.cxx
bb_node_set.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/bb_node_set.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
bb_node_set.h
idx_32_set.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/idx_32_set.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
idx_32_set.h
opt_alias_analysis.h
opt_alias_analysis.h
opt_alias_class.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_alias_class.h,v $
---
> // $Revision: 1.7 $
> // $Date: 05/02/10 12:00:52-08:00 $
> // $Author: fchow@fluorspar.keyresearch $
> // $Source: be/opt/SCCS/s.opt_alias_class.h $
550d549
<   BOOL                Expr_may_contain_pointer (WN* const expr);
558d556
<   BOOL                Assignment_may_xfer_pointer (WN* const); 
opt_alias_class.h
opt_array.h
5,8c5,8
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_array.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
57d56
< 
opt_array.h
opt_base.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_base.h,v $
---
> // $Revision: 1.8 $
> // $Date: 05/01/26 14:58:09-08:00 $
> // $Author: fchow@fluorspar.keyresearch $
> // $Source: be/opt/SCCS/s.opt_base.h $
opt_base.h
opt_bb.h
1a2,6
> 
> /*
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
6,9c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_bb.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
745d749
<   void         Set_merge(BB_NODE *b){ _u2._merge = b; }
1154d1157
<   void         PrintVis(void) const;            // print the bb structure
1622a1626
> 
opt_bb.h
opt_bdce.h
1a2,6
> 
> /*
>  *  Copyright (C) 2007. QLogic Corporation. All Rights Reserved.
>  */
> 
6,9c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_bdce.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
83d87
< 
92d95
< 
105c108
<   UINT64 Bitmask_of_size(UINT64);
---
>   UINT64 Bitmask_of_size(INT32);
125,127d127
< #if defined(TARG_SL)
<   void Repair_Injured_AuxIntrnOP (void);
< #endif
opt_bdce.h
opt_cfg.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_cfg.h,v $
---
> // $Revision: 1.7 $
> // $Date: 05/01/13 17:16:54-08:00 $
> // $Author: fchow@fluorspar.keyresearch $
> // $Source: be/opt/SCCS/s.opt_cfg.h $
157d156
< class LMV_CFG_ADAPTOR; 
316d314
<   void         Create_empty_preheader (WN* loop); 
371,381d368
<   // functions about loop multiversioning 
<   BB_NODE*     LMV_clone_block (const BB_NODE* src, LMV_CFG_ADAPTOR*);
<   BB_NODE*     LMV_create_alike_block (BB_KIND kind, BB_NODE* model);
<   void         LMV_clone_pred_succ_relationship (LMV_CFG_ADAPTOR*); 
<   void         LMV_clone_loop_body (LMV_CFG_ADAPTOR*); 
<   void         LMV_update_internal_labels (LMV_CFG_ADAPTOR*);
<   BB_LOOP*     LMV_clone_BB_LOOP (LMV_CFG_ADAPTOR*);
<   void         LMV_gen_precondioning_stuff (LMV_CFG_ADAPTOR*);
<   void         LMV_clone_BB_IFINFO (LMV_CFG_ADAPTOR* );
< 
< 
391,393d377
<   void         PrintLoopVis(BB_LOOP * loop, int & id);
<   void         PrintVis(BOOL draw_loops);
<   void         PrintCDVis(void);
529c513
< 				       _label_map->Get_val((POINTER)(INTPTR)l);
---
> 				       _label_map->Get_val((POINTER)l);
532c516
< 				{ _label_map->Add_map((POINTER)(INTPTR)labnum,
---
> 				{ _label_map->Add_map((POINTER)labnum,
640,647d623
<   // code generation for loop multiversioning.
<   BOOL         LMV_eligible_for_multiversioning (const BB_LOOP*, BOOL);
<   void         LMV_clone_loop (LMV_CFG_ADAPTOR*);
<   BOOL         If_convertible_cond(WN* wn);
<   BOOL         If_conv_criteria_met(WN* wn, WN* else_wn, WN* then_wn, BOOL empty_else, BOOL empty_then);
<   BOOL         Screen_cand(WN* wn, WN* else_wn, WN* then_wn, BOOL empty_else, BOOL empty_then);
<   WN*          Conv_to_select(WN* wn);
< 
opt_cfg.h
opt_cfg_trans.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_cfg_trans.h,v $
---
> // $Revision: 1.7 $
> // $Date: 04/12/21 14:57:17-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_cfg_trans.h $
opt_cfg_trans.h
opt_combine.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_combine.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_combine.h
opt_config.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_config.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_config.h
opt_dbg.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_dbg.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_dbg.h
opt_dce.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_dce.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_dce.h
opt_defs.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_defs.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
193,198d192
< #define WOVP_DUMP_FLAG         0x20 /* dump after write-once variable promotion*/
< #define PT_SUMMARY_FLAG        0x40 /* trace the points-to summary */    
< #define LOOP_MULTVER_FLAG      0x80 /* Loop multiversioning */ 
< #if defined(TARG_SL)
< #define LCLSC_TRACE_FLAG      0x100 /* trace stack shrink optimization */
< #endif
opt_defs.h
opt_dfs.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_dfs.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_dfs.h
opt_du.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_du.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_du.h
opt_efinalize.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_efinalize.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_efinalize.h
opt_emit.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_emit.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_emit.h
opt_emit_template.h
1a2,5
>  * Copyright (C) 2007 PathScale, LLC.  All Rights Reserved.
>  */
> 
> /*
15,18c19,22
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_emit_template.h,v $
---
> // $Revision: 1.35 $
> // $Date: 05/11/22 17:29:23-08:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_emit_template.h $
392c396,399
<             if (! MTYPE_is_float(exp->Asm_input_rtype()) &&
---
>             if (
> #if 1 // bug 13104
> 	        ! MTYPE_is_float(exp->Asm_input_rtype()) && 
> #endif
394d400
< 			  // OSP_388 and OSP_390
618,622d623
< #ifdef TARG_SL
<       if(exp->Is_flag_set(CF_INTERNAL_MEM_OFFSET)) {
<           WN_Set_is_internal_mem_ofst(wn);
<       }
< #endif 
641,647d641
< #ifdef TARG_SL
<       if (exp->Dtyp() == MTYPE_I2 && exp->Dsctyp() == MTYPE_I2) {
<         wn = WN_Create((aux_entry->Bit_size() > 0 && aux_entry->Field_id() == 0)
< 			? OPR_LDBITS : OPR_LDID,
< 	   	        MTYPE_I4, exp->Dsctyp(), 0); 
<       } else
< #endif
660,670d653
< 	BOOL reset_type = TRUE;
< 	if (field_id != 0 && TY_kind(ty_idx) == KIND_STRUCT) {
< 	  // check if is referring to struct field which does match size
< 	  UINT cur_field_id = 0;
< 	  FLD_HANDLE fld = FLD_get_to_field (ty_idx, field_id, cur_field_id);
< 	  Is_True (! fld.Is_Null(), ("Invalid field id %d for type 0x%x",
<                           field_id, ty_idx));
< 	  if (TY_size(FLD_type(fld)) == MTYPE_byte_size(exp->Dsctyp()))
< 		reset_type = FALSE;
< 	}
< 	if (reset_type) {
677d659
<       }
833,838d814
< #ifdef TARG_SL //fork_joint
<      if (srep->Fork_stmt_flags())
< 	 	WN_Set_is_compgoto_para(rwn);
<      else if(srep->Minor_fork_stmt_flags()) 
< 	 	WN_Set_is_compgoto_for_minor(rwn);
< #endif 
865d840
<           // bug fix for OSP_87 and OSP_90
867c842
< 				  (ST_IDX) p->clobber_string_idx,
---
> 				  (ST_IDX) 0,
871d845
< 	  if(WN_kid0(prag) == 0)
opt_emit_template.h
opt_error.h
5,8c5,8
<  * $Revision: 1.1.1.1 $
<  * $Date: 2005/10/21 19:00:00 $
<  * $Author: marcel $
<  * $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_error.h,v $
---
>  * $Revision$
>  * $Date$
>  * $Author$
>  * $Source$
opt_error.h
opt_estr.h
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_estr.h,v $
---
> // $Revision: 1.5 $
> // $Date: 05/04/25 21:42:38-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_estr.h $
194d193
< 
opt_estr.h
opt_etable.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_etable.h,v $
---
> // $Revision: 1.7 $
> // $Date: 05/02/09 19:36:42-08:00 $
> // $Author: fchow@fluorspar.keyresearch $
> // $Source: be/opt/SCCS/s.opt_etable.h $
2026,2027c2026
<   CODEREP	 *New_temp_cr(MTYPE dtype, ADDRESSABILITY addressable, 
< 				CODEREP *rhs);
---
>   CODEREP	 *New_temp_cr(MTYPE dtype, ADDRESSABILITY addressable);
opt_etable.h
opt_exc.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_exc.h,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_exc.h $
opt_exc.h
opt_fb.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_fb.h,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_fb.h $
247,249d246
<   FB_FREQ Get_node_freq_in( IDTYPE nx ) const {
<     return _fb_opt_nodes[nx].freq_total_in;
<   }
opt_fb.h
opt_fold.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_fold.h,v $
---
> // $Revision: 1.4 $
> // $Date: 05/03/10 16:47:55-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_fold.h $
opt_fold.h
opt_htable.h
0a1,8
> /*
>  * Copyright 2008 PathScale, LLC.  All Rights Reserved.
>  */
> 
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
11,14c19,22
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_htable.h,v $
---
> // $Revision: 1.26 $
> // $Date: 05/10/14 18:28:23-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_htable.h $
107,108d114
< #include <map>
< #include "be_memop_annot.h"
211,215d216
< #ifdef TARG_SL2
<   // offset relative to internal memory (vbuf & sbuf)  and used as parameter 
<   // in intrinisc_vbuf_offset and intrinsic_sbuf_offset
<   CF_INTERNAL_MEM_OFFSET = 0x400, 
< #endif 
257,260d257
< enum ISCONST_FLAG {
<   ISCONST_RVI_CANDIDATE = 0x1,    // used by TARG_SL 
< }; 
< 
312,317d308
< #ifdef TARG_SL2 
<   UINT32    usecnt:12;               // number of times this node's
<                                      // expression appears.
<                                      // not used for ISCONST and ISLDA
<   CR_FLAG   flags:11;                
< #else
322d312
< #endif            
383,388d372
< #if defined(TARG_SL)
<       struct {
<         INT64    const_val;           // constant value, ISCONST
<         mUINT16  _isconst_flags; 
<       }isconst_val; 
< #else 
390d373
< #endif
494d476
< 
499a482,485
> #ifndef TARG_X8664
>       if (wt == MTYPE_U4 || wt == MTYPE_I4) 
> 	Set_dtyp_const_val(wt, (v << 32) >> 32);
> #else
501c487
< 	Set_dtyp_const_val(wt, ((INT64)v << 32) >> 32);
---
> 	Set_dtyp_const_val(wt, (v << 32) >> 32);
503a490
> #endif
505d491
< 
509d494
< 
518d502
< 
628,629c612,613
<   void	    Set_dtyp_const_val(MTYPE dt, INT64 v) { 
< 					Is_True(Kind() == CK_CONST,
---
> #ifndef TARG_X8664
>   void	    Set_dtyp_const_val(MTYPE dt, INT64 v) { Is_True(Kind() == CK_CONST,
631,636c615
< 					// use given mtype if value fits
< 					if (dt == MTYPE_U4
< 					  && (v == ((UINT64) v << 32) >> 32))
< 					  _dtyp = MTYPE_U4;
< 					else if (dt == MTYPE_I4
< 					  && (v == ((INT64) v << 32) >> 32))
---
> 					if (v == (v << 32) >> 32)
638,643c617,618
< 					else if (dt == MTYPE_U8)
< 					  _dtyp = MTYPE_U8;
< 					else 
< 					  _dtyp = MTYPE_I8;
< #if defined(TARG_SL)
< 					u2.isconst.isconst_val.const_val = v; }
---
> 					else _dtyp = MTYPE_I8;
> 					u2.isconst.const_val = v; }
644a620,624
>   void	    Set_dtyp_const_val(MTYPE dt, UINT64 v) { Is_True(Kind() == CK_CONST,
> 					    ("CODEREP::Set_dtyp_const_val, illegal kind"));
> 					if (v == (v << 32) >> 32)
> 					  _dtyp = MTYPE_U4;
> 					else _dtyp = MTYPE_I8;
646,647c626
< #endif // TARG_SL
< 
---
> #endif
820,831d798
< #if defined(TARG_SL)
<   void Set_RVI_Candidate() {
<     u2.isconst.isconst_val._isconst_flags |= ISCONST_RVI_CANDIDATE; 
<   }
<   BOOL RVI_Candidate() {
<     return u2.isconst.isconst_val._isconst_flags & ISCONST_RVI_CANDIDATE; 
<   }
<   void Reset_RVI_Candidate() {
<     u2.isconst.isconst_val._isconst_flags &= ~ISCONST_RVI_CANDIDATE; 
<   }
< 
< #endif
915,917d881
< #if defined(TARG_SL)
< 					u2.isconst.isconst_val.const_val = v; }
< #else
919d882
< #endif
924,926d886
< #if defined(TARG_SL)
< 					return u2.isconst.isconst_val.const_val; }
< #else
928d887
< #endif
1065c1024
< 					u2.isivar.base[2] = (CODEREP*)(INTPTR)ty; }
---
> 					u2.isivar.base[2] = (CODEREP*)ty; }
1086c1045
< 					 u2.isivar.base[4] = (CODEREP*)(INTPTR)ty; }
---
> 					 u2.isivar.base[4] = (CODEREP*)ty; }
1501,1503d1459
< #ifdef TARG_SL
<       IDX_32 hash_idx = Hash_lda(cr->Lda_base_st(),(IDTYPE)(cr->Offset() + cr->Is_flag_set(CF_INTERNAL_MEM_OFFSET)));
< #else 
1505d1460
< #endif
1598,1599c1553
< 		       CODEREP *, 
<                        OPT_STAB* );
---
> 		       CODEREP *);
1815,1819d1768
< #ifdef TARG_SL //fork_joint
<  BOOL       _sl2_compgoto_para : 1; //used to mark if the stmt is a compgoto for sl2 major fork. 
<  BOOL       _sl2_compgoto_for_minor: 1; // used to mark if the stmt is a compgoto for sl2 minor fork. 
<  UINT        _unused : 3;      // allocate new flag bits from here.
< #else  
1821d1769
< #endif
2106,2113d2053
< #ifdef TARG_SL //fork_joint
<   // we need passing fork compgoto flag from whirl node to stmtrep 
<   BOOL      Fork_stmt_flags(void) const   { return _sl2_compgoto_para; }
<   void       Set_fork_stmt_flags(BOOL f)  { _sl2_compgoto_para = f; }
<   BOOL      Minor_fork_stmt_flags(void)  const  { return _sl2_compgoto_for_minor; } 
<   void        Set_minor_fork_stmt_flags(BOOL f) { _sl2_compgoto_for_minor = f; } 
< #endif 
< 
2157,2158d2096
<   BOOL      Is_incr(void) const;        // is v = v +/- const, the RHS
<                                         // pattern is recursively defined.
2240,2331d2177
< ///////////////////////////////////////////////////////////////////////////
< //
< //   MEMOP_ANNOT_CR_SR_MAP is a map between CODEREP/STMTREP to their 
< // corresponding annotations. 
< //
< ///////////////////////////////////////////////////////////////////////////
< //
< struct cr_cmp {
<   bool operator () (const CODEREP* cr1, const CODEREP* cr2) const {
<     Is_True (cr1->Coderep_id() != 0 && cr2->Coderep_id() != 0, ("CODEREP does not has ID"));
<     return cr1->Coderep_id() < cr2->Coderep_id(); 
<   }
< };
<  
< typedef std::pair<const CODEREP*, MEMOP_ANNOT*> CR_MEMANNOT_PAIR;
< typedef mempool_allocator<CR_MEMANNOT_PAIR> CR_ANNOT_MAP_ALLOC;
< typedef std::map<const CODEREP*, MEMOP_ANNOT*, cr_cmp, CR_ANNOT_MAP_ALLOC> CR_2_MEM_ANNOT_MAP;
< 
< struct sr_cmp {
<   bool operator () (const STMTREP* sr1, const STMTREP* sr2) const {
<     return sr1 < sr2;
<   }
< };
< 
< typedef std::pair<const STMTREP*, MEMOP_ANNOT*> SR_MEMANNOT_PAIR;
< typedef mempool_allocator<SR_MEMANNOT_PAIR>    SR_ANNOT_MAP_ALLOC;
< typedef std::map<const STMTREP*, MEMOP_ANNOT*, sr_cmp, SR_ANNOT_MAP_ALLOC>
<         SR_2_MEM_ANNOT_MAP;
< 
< class MEMOP_ANNOT_CR_SR_MGR : public MEMOP_ANNOT_MGR {
< private:
<   CR_2_MEM_ANNOT_MAP _cr_map;
<   SR_2_MEM_ANNOT_MAP _sr_map;
<   BOOL _trace;
<   BS* _imported;
<   BS* _exported;
< 
<   void Set_imported (MEMOP_ANNOT* a) 
<         { _imported = BS_Union1D (_imported, a->Id(), _mp); }
<   BOOL Is_imported (MEMOP_ANNOT* a) const 
<         { return BS_MemberP (_imported, a->Id());}
< 
<   void Set_exported (MEMOP_ANNOT* a)
<         { _exported = BS_Union1D (_exported, a->Id(), _mp); }
<   BOOL Is_exported (MEMOP_ANNOT* a)
<         { return BS_MemberP (_exported, a->Id()); }
< 
< public:
<   MEMOP_ANNOT_CR_SR_MGR (MEM_POOL* mp, BOOL trace);
< 
<   // Lookup the corresponding annotation 
<   MEMOP_ANNOT*      Get_annot (CODEREP* cr);
<   MEMOP_ANNOT_ITEM* Get_annot (CODEREP* cr, MEM_ANNOT_KIND kind) ;
<   MEMOP_ANNOT*      Get_annot (STMTREP* sr) ;
<   MEMOP_ANNOT_ITEM* Get_annot (STMTREP* sr, MEM_ANNOT_KIND kind);
< 
<   // Associate a MEMOP_ANNOT with given WN/CODEREP/STMTREP
<   void Add_annot (CODEREP* cr, const MEMOP_ANNOT_ITEM& annot_item);
<   void Add_annot (STMTREP* stmt, const MEMOP_ANNOT_ITEM& annot_item);
<   void Set_annot (CODEREP* cr, MEMOP_ANNOT* annot);
<   void Set_annot (STMTREP* sr, MEMOP_ANNOT* annot);
< 
<   // Import annotation from WN=>MEMOP_ANNOT map.
<   MEMOP_ANNOT* Import_annot (CODEREP* cr, MEMOP_ANNOT* annot) ;
<   MEMOP_ANNOT* Import_annot (STMTREP* sr, MEMOP_ANNOT* annot) ;
<   MEMOP_ANNOT* Import_annot (MEMOP_ANNOT* annot) ;
< 
<   // Export the annotation associated with any descendant of <tree> 
<   // to MEMOP_ANNOT_WN_MAP. If there is only one annotation, we have two
<   // options:
<   //   - inline the annotation in POINTS_TO, or 
<   //   - allocate annot structure and associate it with corresponding WN
<   //
<   //  Of couse, the 2nd option is more expensive than the 1st.However, 
<   //  we have to do that when this function is invoked by LNO preopt because
<   //  POINTS_TOs will be discarded soon make the annotation lost. However, 
<   //  the life-time of annotation structures is under control of preopt/wopt.
<   //
<   //  2nd option should be used when <inline_annot> is set, otherwise, 
<   //  1st option is used.
<   //
<   void Export_annot (WN* tree, const ALIAS_MANAGER*, 
<                      BOOL inline_annot, BOOL trace);
< 
<   // When active WN_MEMOP_ANNOT_MGR is NULL, we need to discard the "offline" 
<   // annotation in that "offline" data structure is supposed to be allocated by 
<   // WN_MEMOP_ANNOT_MGR.
<   //
<   void Discard_offline_annot (WN*, const ALIAS_MANAGER*, BOOL trace);
< 
<   void Print (FILE* f, BOOL verbose=FALSE) const;
< };
opt_htable.h
optimizer.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/optimizer.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
optimizer.h
opt_ivr.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ivr.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_ivr.h
opt_lclsc.h
opt_lclsc.h
opt_leaf_iter.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_leaf_iter.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_leaf_iter.h
opt_lftr2.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_lftr2.h,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:18-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_lftr2.h $
opt_lftr2.h
opt_lmv.h
opt_lmv.h
opt_lmv_helper.h
opt_lmv_helper.h
opt_loop.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_loop.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_loop.h
opt_main.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_main.h,v $
---
> // $Revision: 1.4 $
> // $Date: 05/03/10 16:47:55-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_main.h $
opt_main.h
opt_misc.h
opt_misc.h
opt_mu_chi.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_mu_chi.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_mu_chi.h
opt_pch.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_pch.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_pch.h
opt_project.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_project.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_project.h
opt_prop.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_prop.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
102c102
< 			       BOOL inside_cse, INT32 *height,INT32*weight,
---
> 			       BOOL inside_cse, INT32 *height,
opt_prop.h
opt_region_emit.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_region_emit.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_region_emit.h
opt_rvi_emit.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rvi_emit.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_rvi_emit.h
opt_rvi.h
6,9c6,9
< // $Revision: 1.2 $
< // $Date: 02/11/07 23:41:55-00:00 $
< // $Author: fchow@keyresearch.com $
< // $Source: /scratch/mee/2.4-65/kpro64-pending/be/opt/SCCS/s.opt_rvi.h $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
59c59
< static char *opt_rvircs_id = opt_rvi_INCLUDED"$ $Revision: 1.2 $";
---
> static char *opt_rvircs_id = opt_rvi_INCLUDED"$ $Revision$";
328,330c328
< #if defined(TARG_SL)
<   BOOL Is_Intrncall_Nth_Parm_Need_RVI(INTRINSIC, INT);
< #endif
---
> 
380,384d377
< 			 // don't want pregs for what may be local
< 			 // const table that asm refers to
< 			 // because then symbol will be moved outside
< 			 // of asm scope.
< 			 opc == OPC_ASM_STMT ||
opt_rvi.h
opt_rvilr.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rvilr.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_rvilr.h
opt_rvitab.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rvitab.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_rvitab.h
opt_rviwn.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_rviwn.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_rviwn.h
opt_ssa.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ssa.h,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_ssa.h $
opt_ssa.h
opt_ssu.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_ssu.h,v $
---
> // $Revision: 1.4 $
> // $Date: 05/08/15 23:41:36-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_ssu.h $
opt_ssu.h
opt_stmt.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_stmt.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_stmt.h
opt_sym.h
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_sym.h,v $
---
> // $Revision: 1.15 $
> // $Date: 05/06/29 16:05:28-07:00 $
> // $Author: fchow@fluorspar.internal.keyresearch.com $
> // $Source: be/opt/SCCS/s.opt_sym.h $
109d108
< #include "opt_alias_analysis.h"
144d142
< class MEMOP_ANNOT_CR_SR_MGR;
279d276
<   friend class WOVP;	  // WOVP needs to modify Aux_stab_entry
793d789
<   OPT_PU_POINTS_TO_SUMMARIZER _pt_sum;
909,913d904
<   // this data structure is used to map from alias-class to its corresponding
<   // unique-vsym.
<   typedef mempool_allocator< std::pair<IDTYPE, AUX_ID> > AC_VSYM_ALLOC;
<   ID_MAP<IDTYPE, AUX_ID>  _ac_2_vsym_map;
< 
929d919
<   MEMOP_ANNOT_CR_SR_MGR    * _cr_sr_annot_mgr;
980,982d969
<   // Misc 
<   BOOL     Its_ret_val_of_malloc (VER_ID ver);
< 
1010,1011d996
<   OPT_PU_POINTS_TO_SUMMARIZER* Points_to_summarizer (void) 
<                                          { return &_pt_sum; }
1013d997
<   MEM_POOL* Ver_pool(void)               { return &_ver_pool; }
1383,1385d1366
< 
<   MEMOP_ANNOT_CR_SR_MGR* Cr_sr_annot_mgr (void) const { return _cr_sr_annot_mgr;} 
< 
1399d1379
<   void    Summarize_points_to (void);
opt_sym.h
opt_sys.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_sys.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
62d61
< #ifndef BZERO
64,68d62
< #endif
< 
< #ifndef BCOPY
< #define BCOPY bcopy
< #endif
71d64
< //  Return the CPU time in millisecond.
opt_sys.h
opt_tail.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_tail.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_tail.h
opt_transform.h
15,18c15,18
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_transform.h,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_transform.h $
opt_transform.h
opt_union_find.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_union_find.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_union_find.h
opt_util.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_util.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
57c57
< sstatic char *opt_utilrcs_id = 	opt_util_INCLUDED"$Revision$";
---
> static char *opt_utilrcs_id = 	opt_util_INCLUDED"$Revision$";
173,175d172
< #if defined(TARG_SL)
< extern BOOL CR_Intrinsic_Op_Slave(CODEREP * cr);
< #endif
opt_util.h
opt_verify.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_verify.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_verify.h
opt_vertab.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vertab.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_vertab.h
opt_vn_expr.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vn_expr.h,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_vn_expr.h $
opt_vn_expr.h
opt_vn_expr_taxonomy.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vn_expr_taxonomy.h,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_vn_expr_taxonomy.h $
118d117
< #include "intrn_info.h"
opt_vn_expr_taxonomy.h
opt_vnfre.h
6,9c6,9
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vnfre.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
opt_vnfre.h
opt_vn.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vn.h,v $
---
> // $Revision: 1.7 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_vn.h $
opt_vn.h
opt_vn_hashtab.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vn_hashtab.h,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_vn_hashtab.h $
opt_vn_hashtab.h
opt_vn_ivc.h
11,14c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_vn_ivc.h,v $
---
> // $Revision: 1.6 $
> // $Date: 04/12/21 14:57:19-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_vn_ivc.h $
opt_vn_ivc.h
opt_wn.h
1a2,6
> 
> /*
>  * Copyright 2004, 2005, 2006 PathScale, Inc.  All Rights Reserved.
>  */
> 
6,9c11,14
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_wn.h,v $
---
> // $Revision: 1.5 $
> // $Date: 04/12/21 14:57:20-08:00 $
> // $Author: bos@eng-25.internal.keyresearch.com $
> // $Source: /home/bos/bk/kpro64-pending/be/opt/SCCS/s.opt_wn.h $
opt_wn.h
opt_wovp.h
opt_wovp.h
wodriver.h
5,8c5,8
< // $Revision: 1.1.1.1 $
< // $Date: 2005/10/21 19:00:00 $
< // $Author: marcel $
< // $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/wodriver.h,v $
---
> // $Revision$
> // $Date$
> // $Author$
> // $Source$
wodriver.h
