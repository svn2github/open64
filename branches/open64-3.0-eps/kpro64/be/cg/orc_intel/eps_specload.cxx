#include "eps.h"
#include "recovery.h"   // we borrow some utility functions from GIS module
#include "label_util.h"

int SpecLDs_Node::_id_count;

SpecLDs_Node::SpecLDs_Node(OP* newld, OP* ld, OP* chk)
{
    _ld = Dup_OP(ld);
    _chk = chk;
    _id = _id_count++;
    // 2008.11.07
    _new_ld = Dup_OP(newld);

    DDG* ddg = EPS::current_eps_driver()->get_ddg();
    ddg->Find_LD_Recovery_Cand(newld, _id, _recovery_candidates);

    if(EPSDBG(1)) {
        std::list<OP*>::iterator it;
        fprintf(EPSLOG, "new LD-CHK:\n");
        fprintf(EPSLOG, "LD:");
        eps_print_asm(EPSLOG, _ld, NULL);
        fprintf(EPSLOG, "CHK: %p", _chk);
        eps_print_asm(EPSLOG, _chk, NULL);
        for(it=_recovery_candidates.begin(); it!=_recovery_candidates.end(); it++) {
            OP* op = *it;
            fprintf(EPSLOG, "%p ", op);
            eps_print_asm(EPSLOG, op, NULL);
        }
    }
}

void SpecLDs_Node::update(OP* old_op, OP* new_op)
{
    for(std::list<OP*>::iterator it=_recovery_candidates.begin(); it!=_recovery_candidates.end(); it++) {
        OP* cand = *it;
        if(cand==old_op) {
            if(EPSDBG(1)) {
                fprintf(EPSLOG, "update %p %p\n", old_op, new_op);
            }
            _recovery_candidates.push_back(new_op);
            break;
        }
    }
    _recovery_candidates.remove(old_op);
}

void SpecLDs_Node::add_recovery_cand(OP* orig, OP* bk)
{
    for(std::list<OP*>::iterator it=_recovery_candidates.begin(); it!=_recovery_candidates.end(); it++) {
        OP* cand = *it;
        if(cand==orig) {
            _recovery_candidates.push_back(bk);

            if(EPSDBG(1)) {
                fprintf(EPSLOG, "add recovery cand\n");
                eps_print_asm(EPSLOG, bk, NULL);
                fprintf(EPSLOG, "\n");
            }

            return;
        }
    }
}

SpecLDs_Node* SpecLDs::new_spec_load(OP* newld, OP* ld, OP* chk)
{
    SpecLDs_Node* node = (SpecLDs_Node*)CXX_NEW(SpecLDs_Node(newld, ld, chk), EPS::current_eps_mempool());
    _spec_lds[chk] = node;

    return node;
}

SpecLDs_Node* SpecLDs::move_instruction(OP* new_op, OP* chk)
{
    SpecLDs_Node* node = _spec_lds[chk];
//    EPS_ASSERT(node!=NULL, "node must be not NULL.\n");
    if(node==NULL) {
        // this chk is not generated by EPS but by GIS
        return NULL;
    }

    std::list<OP*>::iterator it;
    for(it=node->_recovery_candidates.begin();
        it!=node->_recovery_candidates.end();
        it++) {
            OP* cand = (*it);
            if(cand==new_op) {
                node->_recovery_ops.push_back(new_op);

                if(EPSDBG(1)) {
                    fprintf(EPSLOG, "move above chk\n");
                    eps_print_asm(EPSLOG, chk, NULL);
                    eps_print_asm(EPSLOG, new_op, NULL);
                    fprintf(EPSLOG, "\n");
                }

                if(OP_load(new_op) && (!CGTARG_Is_OP_Speculative_Load(new_op)) && (new_op->eps_flags&(OP_EPS_SPECLOAD|OP_EPS_ADVLOAD))==0) {
                    if(OP_Is_Float_Mem(new_op)) Change_ld_Form(new_op, ECV_fldtype_s);
                    else Change_ld_Form(new_op, ECV_ldtype_s);
                }
                return node;
            }
    }
    return NULL;
}

SpecLDs_Node* SpecLDs::pushdown(OP* op, OP* chk)
{
    SpecLDs_Node* node = _spec_lds[chk];
    if(!node) return NULL;
    if(OP_call(op)) return NULL;
    if(OP_store(op)) return NULL;
    if(chk_op_anti_dependent(op, chk)) return NULL;

    std::list<OP*>::iterator it;
    for(it=node->_recovery_candidates.begin();
        it!=node->_recovery_candidates.end();
        it++) {
            OP* cand = (*it);
            if(cand==op) {
                if(OP_load(op) && !CGTARG_Is_OP_Speculative_Load(op)) return NULL;
                if(OP_store(op)) return NULL;

                node->_recovery_ops.push_back(op);
//                if(OP_load(op) && (!CGTARG_Is_OP_Speculative_Load(op)) && (op->eps_flags&(OP_EPS_SPECLOAD|OP_EPS_ADVLOAD))==0) {
//                    if(OP_Is_Float_Mem(op)) Change_ld_Form(op, ECV_fldtype_s);
//                    else Change_ld_Form(op, ECV_ldtype_s);
//                }
                return node;
            }
    }

    return NULL;
}

SpecLDs_Node* SpecLDs::change(OP* oldchk, OP* newchk)
{
    SpecLDs_Node* node = _spec_lds[oldchk];
    if(node==NULL) return NULL;
    node->_chk = newchk;

    _spec_lds.erase(_spec_lds.find(oldchk));
    _spec_lds[newchk] = node;
    return node;
}

BB* SpecLDs::generate_recovery_block(OP* chk)
{
    SpecLDs_Node* node = _spec_lds[chk];
    //EPS_ASSERT(node!=NULL, "node must be not NULL.\n");
    if(node==NULL) {
        // this chk is not generated by EPS but by GIS
        return NULL;
    }

    BB* last_bb = OP_bb(chk);

    while(BB_next(last_bb)!=NULL) last_bb = BB_next(last_bb);

    BB* recovery_bb = Gen_BB_Like(OP_bb(chk));
    Insert_BB(recovery_bb, last_bb);

    EPS::current_eps_driver()->AddRecoveryBlock(BB_id(recovery_bb));

    Set_BB_loop_head_bb(recovery_bb, BB_loop_head_bb(OP_bb(chk)));
    BB_bbregs(recovery_bb) = TYPE_MEM_POOL_ALLOC(BBREGS,&MEM_pu_pool);

    if(EPSDBG(1)) {
        fprintf(stderr, "creating recovery bb: %d\n", BB_id(recovery_bb));
    }

    // Duplicate spec load and set the dup to normal ld.
    OP* recovery_op = Dup_OP(node->newld());
    TN* ldtype_tn = OP_Is_Float_Mem(recovery_op)?Gen_Enum_TN(ECV_fldtype):Gen_Enum_TN(ECV_ldtype);
    Set_OP_opnd(recovery_op, ENUM_LDTYPE_POS, ldtype_tn);
    Reset_OP_speculative(recovery_op);
    BB_Append_Op(recovery_bb, recovery_op);

    int size=0;
    std::list<OP*>::iterator it;
    for(it=node->_recovery_ops.begin(); it!=node->_recovery_ops.end(); it++) {
        int i;
        OP* op = *it;

        for(i=0; i<OP_results(op); i++) {
            TN* result_tn = OP_result(op, i);
            if(TN_Is_Allocatable(result_tn)) GTN_UNIVERSE_Add_TN(result_tn);
        }
        for(i=0; i<OP_opnds(op); i++) {
            TN* opnd_tn = OP_opnd(op, i);
            if(TN_Is_Allocatable(opnd_tn)) GTN_UNIVERSE_Add_TN(opnd_tn);
        }
        recovery_op = Dup_OP(op);

        /* 2008.11.07 jaemok  comment out
        if(OP_load(recovery_op)) {
            TN* ldtype_tn = OP_Is_Float_Mem(recovery_op)?
                Gen_Enum_TN(ECV_fldtype):Gen_Enum_TN(ECV_ldtype);
            Set_OP_opnd(recovery_op, ENUM_LDTYPE_POS, ldtype_tn);
        }
        */
        Reset_OP_speculative(recovery_op);
        BB_Append_Op(recovery_bb, recovery_op);
        size++;
    }

    if(EPSDBG(1)) fprintf(EPSLOG, "recovery size = %d\n", size);

    // label the recovery block.
    Set_BB_recovery(recovery_bb);
    TN* label_tn = Gen_Label_TN(Gen_Label_For_BB(recovery_bb), 0);
    Set_chk_tgt(chk, label_tn);

    return recovery_bb;
}

BB* SpecLDs::update_cfg(OP* chk)
{
    EPS_ASSERT(OP_chk(chk), "Must be chk op.\n");

    // At first, find recovery bb
    TN* target_tn = Get_chk_tgt(chk);
    EPS_ASSERT(TN_is_label(target_tn), "Must be a label\n");
    BB* recovery_bb = Get_Label_BB(TN_label(target_tn));

    BB* home_bb = OP_bb(chk);
    BOOL home_intact = BB_scheduled(home_bb);
    BOOL home_chk_split = BB_chk_split(home_bb);
    BOOL home_split_head = BB_chk_split_head(home_bb);

    BOOL cut = TRUE;
    BB* bottom_bb = NULL;
    bottom_bb = RGN_Divide_BB(home_bb, chk);
    if(bottom_bb==NULL) {
        cut = FALSE;
        bottom_bb = BB_next(home_bb);
        EPS_ASSERT(bottom_bb==BB_Unique_Successor(home_bb), "bottom_bb must have unique successor.\n");
        EPS_ASSERT(bottom_bb==BB_Fall_Thru_Successor(home_bb), "bottom_bb must fall thru.\n");
    } else {
        Set_BB_loop_head_bb(bottom_bb, BB_loop_head_bb(home_bb));
    }

    // Build corresponding edges.
    RGN_Unlink_Pred_Succ(home_bb, bottom_bb);
    RGN_Link_Pred_Succ_With_Prob(home_bb, bottom_bb, BTM_PROB);
    
    RGN_Gen_And_Insert_Node(recovery_bb,home_bb,bottom_bb, Home_Region(home_bb)->Regional_Cfg());
    RGN_Link_Pred_Succ_With_Prob(home_bb, recovery_bb, REC_PROB);
    
    Add_Goto_Op(recovery_bb, bottom_bb);
    RGN_Link_Pred_Succ_With_Prob(recovery_bb, bottom_bb, 1.0F);

    BB_freq(recovery_bb) = BB_freq(home_bb) * rec_prob;
    BB_freq(bottom_bb) = BB_freq(home_bb);

    // Set various BB flags.

    if(cut) {
        if(IPFEC_Chk_Compact) {
            if(!home_chk_split || home_split_head){
                Set_BB_chk_split_head(home_bb);
            }
            Set_BB_chk_split(home_bb);           
            Set_BB_chk_split(bottom_bb);
//            if(home_intact){
//                Set_BB_scheduled(home_bb);
//                Set_BB_scheduled(bottom_bb);
//            }else{
//                Reset_BB_scheduled(home_bb);
//                Reset_BB_scheduled(bottom_bb);
//            }
        }else{
            Reset_BB_scheduled(home_bb);
            Reset_BB_scheduled(bottom_bb);
        }
        return bottom_bb;
    }
    return NULL;
}

void SpecLDs::update(OP* old_op, OP* new_op)
{
    for(SPEC_LDS_MAP::iterator it=_spec_lds.begin(); it!=_spec_lds.end(); it++) {
        SpecLDs_Node* node = (*it).second;
        if(node==NULL) continue;
        node->update(old_op, new_op);
    }
}

void SpecLDs::add_recovery_cand(OP* orig, OP* bk)
{
    for(SPEC_LDS_MAP::iterator it=_spec_lds.begin(); it!=_spec_lds.end(); it++) {
        SpecLDs_Node* node = (*it).second;
        if(node==NULL) continue;
        if(EPSDBG(1)) {
            fprintf(EPSLOG, "check add_recovery_cand:\n");
            fprintf(EPSLOG, "%p, %p\n", orig, bk);
        }
        node->add_recovery_cand(orig, bk);
    }
}

BOOL SpecLDs::chk_op_anti_dependent(OP* op, OP* chk)
{
    TOP opcode = OP_code(chk);

    if(!EPS::is_scheduling()) return FALSE;

    if(opcode!=TOP_chk_s_i && opcode!=TOP_chk_a && opcode!=TOP_chk_f_a) {
        return FALSE;
    }

    SpecLDs_Node* node;
    SPEC_LDS_MAP::iterator it = _spec_lds.find(chk);
    if(it==_spec_lds.end()) {
        fprintf(stderr, "Warning: no spec_ld_chk node : %p ", chk);
        eps_print_asm(stderr, chk, NULL);
        return FALSE;
    }
    node = (*it).second;

    int i;
    TN* opnd;
    for(i=0; i<OP_results(op); i++) {
        opnd = OP_result(op, i);
        if(TN_is_register(opnd) && TN_is_true_pred(opnd)) continue;
        if(OP_Refs_TN(node->ld(), opnd)) {
            if(EPSDBG(1)) fprintf(EPSLOG, "chk-op dependent\n");
//            return TRUE;
        }
        if(OP_Defs_TN(node->ld(), opnd)) {
            if(EPSDBG(1)) fprintf(EPSLOG, "chk-op dependent\n");
//            return TRUE;
        }
    }
    for(i=0; i<OP_opnds(op); i++) {
        opnd = OP_opnd(op, i);
        if(TN_is_register(opnd) && TN_is_true_pred(opnd)) continue;
        if(OP_Defs_TN(node->ld(), opnd)) {
            if(EPSDBG(1)) fprintf(EPSLOG, "chk-op dependent\n");
//            return TRUE;
        }
    }

    std::list<OP*>::iterator it_op;
    for(it_op=node->_recovery_ops.begin(); it_op!=node->_recovery_ops.end(); it_op++) {
        OP* recovery_op = *it_op;
        for(i=0; i<OP_results(op); i++) {
            opnd = OP_result(op, i);
            if(TN_is_register(opnd) && TN_is_true_pred(opnd)) continue;
            if(OP_Refs_TN(recovery_op, opnd)) {
                if(EPSDBG(1)) fprintf(EPSLOG, "chk-op dependent\n");
//                return TRUE;
            }
            if(OP_Defs_TN(recovery_op, opnd)) {
                if(EPSDBG(1)) fprintf(EPSLOG, "chk-op dependent\n");
//                return TRUE;
            }
        }
        for(i=0; i<OP_opnds(op); i++) {
            opnd = OP_opnd(op, i);
            if(TN_is_register(opnd) && TN_is_true_pred(opnd)) continue;
            if(OP_Defs_TN(recovery_op, opnd)) {
                if(EPSDBG(1)) fprintf(EPSLOG, "chk-op dependent\n");
//                return TRUE;
            }
        }
    }
    return FALSE;
}

