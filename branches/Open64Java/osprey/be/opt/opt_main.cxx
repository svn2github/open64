//-*-c++-*-

/*
 * Copyright 2002, 2003, 2004, 2005, 2006 PathScale, Inc.  All Rights Reserved.
 */

// ====================================================================
// ====================================================================
//
// Module: opt_main.cxx
// $Revision: 1.1.1.1 $
// $Date: 2005/10/21 19:00:00 $
// $Author: marcel $
// $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_main.cxx,v $
//
// ====================================================================
//
// Copyright (C) 2000, 2001 Silicon Graphics, Inc.  All Rights Reserved.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of version 2 of the GNU General Public License as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it would be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
// Further, this software is distributed without any warranty that it
// is free of the rightful claim of any third person regarding
// infringement  or the like.  Any license provided herein, whether
// implied or otherwise, applies only to this software file.  Patent
// licenses, if any, provided herein do not apply to combinations of
// this program with other software, or any other product whatsoever.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
//
// Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pky,
// Mountain View, CA 94043, or:
//
// http://www.sgi.com
//
// For further information regarding this notice, see:
//
// http://oss.sgi.com/projects/GenInfo/NoticeExplan
//
// ====================================================================
// ====================================================================


/*

  HISTORY OF THE GLOBAL OPTIMIZER
  -------------------------------
  
  This is a brief history of the development of the Mongoose global
  optimizer project at SGI, with acknowledgment of the key contributors
  of the project. In 1994, as the compiler group at SGI was finishing
  the Ragnarok compiler for the MIPS R8000 processor, which was designed
  to address the scientific applications, the group recognized several
  limitations of the Ragnarok compiler.  In the second half of 1994, the
  group set out to design a new compiler that not only produces highly
  efficient code for both scientific and non-scientific applications,
  but also must be stable and fast enough to be used for day-to-day
  development of large applications.  The group also decided to overhaul
  the infrastructure of the compiler to take advantage of the latest
  advances in compiler technology.
  
  The global optimizer is not only designed to be a major optimization
  phase in the compiler, but also as a utility component that can be 
  invoked by other phases.  The IPO (inter-procedural optimization) 
  and LNO (loop-nest optimization) phases rely heavily on the global 
  optimizer for pre-conditioning the code, and their analyses and 
  processing depend on use-def and alias information generated by and 
  fed to them by the optimizer.  Design discussions on the new compiler 
  started around August. 1994. Actual development started in Oct., 1994.  
  The following is a (probably incomplete) list of features with dates 
  of the Mongoose optimizer releases.
  
  
  Release 7.0, May 1996.
  
  Most functionalities are finished in 7.0.  The major decision was to
  use SSA as *the* IR in the optimizer, contrary to using SSA form as an
  augmentation to the IR in many other compilers.  It leads to the
  development of HSSA form, and extensions to represent indirect aliases
  in SSA form.  The optimizer group also made the conscious decision to 
  divide the optimization algorithms used into two different types: 
  SSA-based and the bitvector-based.  At the time, it was not clear how 
  to perform an important optimization - partial redundancy elimination -
  in terms of SSA form, so we used the old and tried bitvector approach.
  When the compiler is released, its performance has already surpassed 
  those of the Ucode compiler and Ragnarok compiler. 
  
  Features of the release include:
  
  Symbol table & alias analysis
  * optimizer-centric symbol table
  * points-to based alias analysis
  * rule-based alias analysis for extensibility
  
  SSA 
  * HSSA form (hash-based value numbering)
  * efficient representation of aliases and indirect memory operation in SSA
  * use of zero SSA version
  * refinement of points-to analysis using SSA 
  * copy propagation without overlapping variable life times
  * induction variable recognition
  * do-loop recognition
  * dead code elimination
  * support of C++ exception handling
  
  Bitvector
  * partial redundancy elimination
  * strength reduction
  * linear function test replacement
  * induction variable elimination
  * register variable identification (register promotion)
  
  
  Release 7.1, Nov 1996.
  
  The development between 7.1 and 7.0 was relatively short.  The release
  focused on improving the stability of the optimizer, fine-tuning the
  optimizations, and improving the debuggability of the optimizer.  For
  example, we introduced heavy uses of assertions and verification
  routines in the optimizer, maximized code re-uses, and collected many
  test cases for optimizer bugs into a regression test suite.
  
  
  Release 7.2, Aug 1997.
  
  The major issue tackled in 7.2 was the undesirable separation between
  SSA-based optimizations and bitvector-based optimizations.  As
  discussed earlier, PRE was the only important optimization that did
  not have a known equivalent algorithm in the SSA domain.  The
  optimizer group was determined to solve the problem.  The outcome is
  the invention of the SSAPRE algorithm.  Strength reduction and linear
  function test replacement were later integrated into the SSAPRE
  algorithm.  In addition, we found that register promotion could
  actually be formulated as a pair of redundancy elimination problems.
  The 7.2 optimizer can compile large applications faster than 7.1 due
  to smaller memory footprint made possible by the use of SSA-based
  optimizations throughout the optimizer.  In the software engineering
  side, we started to move towards using generic programming techniques
  (using the template feature in the C++ language) to maximize
  code-reuse.  The SSAPRE implementation displays a high degree of
  code-reuse because its coding infrastructure is shared by 3 different
  optimizations based on the SSAPRE framework.  By virtue of the 3
  different incarnations of the SSAPRE concept as 3 different
  optimizations, SSAPRE is also an good example of concept-reuse.
  
  New features of 7.2 include:
  
  * alias classification: based on Steensgard's almost linear-time
    points-to analysis
  * invention of the sparse approach to PRE
      * strength reduction
      * linear function test replacement
      * busy code motion (code hoisting)
      * load and store optimization for register promotion of both scalar and 
        indirect variables (the second register promotion phase RVI2 is still
        implemented via bit vectors due to lack of manpower resources to do
        the conversion)
      * aggressive code motion (speculation of expressions)
  * second-order effect of PRE (new optimization opportunities exposed by PRE)
  * F90 support
  * new scheme for CVT optimizations 
    (important for 32 bit variables on 64-bit processors)
  * restrict pointer support
  * generalization of REGION: use optimization regions to partition program
    into smaller optimization units; exception region to support C++
    exception handling with optimizations enabled; MP region to support
    parallelization.
  * some work to avoid exponential optimization time due to the formation of
    huge trees during optimization
  * IPA support: generate sliced SSA to build IPA summary information
  
  
  Release 7.3,  May 1999
  
  At the end of release 7.2, all major parts of the optimizer input and
  output HSSA form.  This laid the foundation for performing iterative
  optimizations for Release 7.3.  As a result of iterating optimizations, 
  a 1.0 ratio for the abstraction penalty benchmark was achieved.  
  Furthermore, we started adapting the SSAPRE algorithm to deal with value 
  redundancy as well as lexical redundancy.  However, only full value 
  redundancy are optimized at the end of 7.3.  We expect extension to 
  cover partial value redundancy to be finished in future releases.  
  
  New features of 7.3 includes:
  
  * iterative global value numbering (GVN)
  * full value redundancy elimination (based on GVN)
  * live-range shrinking
     (an extension to load/store optimization in the SSAPRE framework)
  * bitwise dead and redundant code elimination 
     (elimination of dead and redundant bitwise operationss)
  * control flow optimization
     (remove partial and full redundant branches by code duplication)
  * iterative optimizations
     (capture the second-order effect optimizations)
  * linear function test replacement enhancements
  * new profile data update scheme
  
  
  SGIpro 1.0, not released yet.
  
  After release 7.3, the group started to focus on the next compiler for
  the IA-64 architecture.  Most resources were concentrated on the
  architecture-dependent portions of the compilers.  Relative few
  enhancements were made to the optimizer.  New features in osprey 1.0:
  
  * IA-64 convert opcode optimizations
     * an extension of the bitwise optimization framework done in 7.3
  * perform lowering within the optimizer to expose CVTLs specific to IA-64
  * introduce boolean data type (MTYPE_B) for better use of predicate registers 
  * new scheme to optimize bit-field accesses
     * a bit-field variable is considered an individual scalar in
       earlier phases to benefit from all scalar optimizations
     * it is lowered into the load/store of the enclosing words followed by
       bit extraction or bit composition to allow for redundancy elimination
       and load/store optimizations.
  
  
  People
  
  When the global optimizer project was started, there were four team members.
  Sun Chan has been the manager of the global optimizer group throughout most
  of its development.  His building of a high quality optimizer team and 
  his setting of high expectations are the keys to the success of the 
  project.  Fred Chow is not only the most important contributor of the 
  optimizer, but also the architect of the Mongoose compiler.  His many 
  years of experience in developing the MIPS Ucode compiler has kept us 
  on the right track.  Raymond Lo has contributed significantly to the 
  architecture of the optimizer, and has worked on almost every part of 
  the optimizer.  He succeeds Sun Chan as the manager of the optimizer group.
  Shin-Ming Liu was among the original team members, and he laid the
  overall programming methodology and coding style.  Over time, we have
  recruited additional team members that have contributed to different
  parts of the project.  The global optimizer would nowhere be as good as 
  it is today without the dedicated work of these top compiler engineers.  
  Here is a list of all the people who have contributed significantly to the 
  global optimizer, in alphabetical order:
  
  	Sun Chan
  	Fred Chow 
  	Peter Dahl
  	Rune Dahl 
  	Robert Kennedy
  	Shin-Ming Liu
  	Raymond Lo
  	David Stephenson
  	Mark Striech
  	Peng Tu
  
  
  Publications
  
  Robert Kennedy, Fred Chow, Sun Chan, Shin-Ming Liu, Raymond Lo, and
  Peng Tu, "Partial Redundancy Elimination in SSA form", ACM TOPLAS, May
  1999.
  
  Raymond Lo, Fred Chow, Robert Kennedy, Shin-Ming Liu, and Peng Tu,
  "Register Promotion by Sparse Partial Redundancy Elimination of Loads
  and Stores", Proceedings of the ACM SIGPLAN Conference on Programming
  Language Design and Implementation (PLDI-98), June 17-19, 1998.
  
  Robert Kennedy, Fred Chow, Peter Dahl, Raymond Lo, and Mark Streich,
  "Strength Reduction via SSAPRE", International Conference on Compiler
  Construction (CC '98), Lisbon, Portugal, March 30, 1998.
  
  Fred Chow, Sun Chan, Robert Kennedy, Shin-Ming Liu, Raymond Lo and
  Peng Tu, "A New Algorithm for Partial Redundancy Elimination based on
  SSA Form", Proceedings of the ACM SIGPLAN `97 Conference on
  Programming Language Design and Implementation, pp. 273-286, June
  15-18, 1997.
  
  S.-M. Liu, R. Lo and F. Chow, "Loop Induction Variable
  Canonicalization in Parallelizing Compiler", Intl. Conf. on Parallel
  Architectures and Compilation Techniques (PACT 96), Oct 1996.
  
  Fred Chow, Sun Chan, Shin-Ming Liu, Raymond Lo, and Mark Streich,
  "Effective Representation of Aliases and Indirect Memory Operations in
  SSA Form", 6th Intl. Conf.  on Compiler Construction (CC'96),
  pp. 253-267,Apr 1996.
  
*/ 


#ifdef USE_PCH
#include "opt_pch.h"
#endif // USE_PCH
#pragma hdrstop


#define opt_main_CXX	"opt_main.cxx"

#define __STDC_LIMIT_MACROS
#include <stdint.h>
#define USE_STANDARD_TYPES
#include <alloca.h>
#include "pu_info.h"		/* for PU_Info_state and related things */

#include "unistd.h"

#include "defs.h"
#include "erbe.h"		/* Error messages		*/
#include "glob.h"		/* for Feedback_File_Name	*/
#include "config_targ.h"
#include "config_ipa.h"         /* IPA_Enable_Alias_Class       */
#include "config.h"		/* Query_Skiplist		*/
#include "wn.h"
#include "wn_simp.h"
#include "wn_lower.h"
// Remove the following line
#include "wn_util.h"

#include "ir_reader.h"
#include "tracing.h"
#include "be_util.h"
#include "region_util.h"
#include "fb_whirl.h"		// for FB_Annotate_whirl

#include "optimizer.h"
#include "opt_alias_class.h"
#include "opt_cfg.h"
#include "opt_main.h"
#include "opt_fb.h"
#include "opt_exc.h"
#include "opt_sym.h"
#include "opt_ssa.h"
#include "opt_emit.h"
#include "opt_du.h"

#include "opt_dbg.h"
#include "opt_goto.h"
#include "opt_rvi.h"
#include "opt_util.h"
#include "opt_alias_mgr.h"
#include "opt_alias_interface.h"	/* for Verify_alias() */
#include "opt_vn.h"                     /* Global value numbering (gvn) */

#include "config_lno.h"
#include "config_opt.h"			// for Delay_U64_Lowering

#include "dep_graph.h"			/* for tracing Current_Dep_Graph */
#include "wb_ipl.h"			/* whirl browser for ipl */ 

#include "regex.h"                      // For regcomp and regexec
#include "xstats.h"                     // For PU_WN_BB_Cnt
#include "opt_wovp.h"     // for write once variable promotion
#include "opt_misc.h"

extern "C" void
Perform_Procedure_Summary_Phase (WN* w, struct DU_MANAGER *du_mgr,
				 struct ALIAS_MANAGER *alias_mgr,
				 EMITTER *emitter);
#ifdef __linux__
extern void (*Perform_Procedure_Summary_Phase_p) (WN*, DU_MANAGER*,
						  ALIAS_MANAGER*, void*);
#define Perform_Procedure_Summary_Phase (*Perform_Procedure_Summary_Phase_p)
#else
#pragma weak Perform_Procedure_Summary_Phase
#endif // __linux__

extern BOOL Enable_WN_Simp;
extern void Simplify_bool_expr(COMP_UNIT *);
extern void WN_unroll(WN *);

static MEM_POOL  Opt_global_pool;
static MEM_POOL  Opt_local_pool;
static ST       *Opt_current_pu_st = NULL;
static PU_IDX    Opt_current_pu;

static void Opt_memory_init_pools(void)
{
  OPT_POOL_Initialize(&Opt_global_pool, "Opt_global_pool", FALSE,
		      MEM_DUMP_FLAG + 1);
  OPT_POOL_Initialize(&Opt_local_pool,  "Opt_local_pool",  FALSE,
		      MEM_DUMP_FLAG + 1);
  OPT_POOL_Push(&Opt_global_pool, MEM_DUMP_FLAG+1);
  OPT_POOL_Push(&Opt_local_pool, MEM_DUMP_FLAG+1);
}

static void Opt_memory_terminate_pools(void)
{
  OPT_POOL_Pop(&Opt_global_pool, MEM_DUMP_FLAG+1);
  OPT_POOL_Pop(&Opt_local_pool, MEM_DUMP_FLAG+1);
  OPT_POOL_Delete(&Opt_global_pool, MEM_DUMP_FLAG+1);
  OPT_POOL_Delete(&Opt_local_pool, MEM_DUMP_FLAG+1);
}

static void Opt_set_current_pu_name(WN *wn_tree)
{
  Is_True(wn_tree != NULL && (WN_opcode(wn_tree) == OPC_REGION ||
			      WN_opcode(wn_tree) == OPC_FUNC_ENTRY),
	  ("Opt_set_current_pu_name, unknown WN"));
  ST *st;
  if (WN_opcode(wn_tree) == OPC_REGION) {
    // find the func_entry
    WN *pu = REGION_find_pu(wn_tree);
    Is_True(pu != NULL && WN_opcode(pu) == OPC_FUNC_ENTRY,
	    ("Opt_set_current_pu_name, could not find func entry"));
    st = WN_st(pu);
  } else {
    st = WN_st(wn_tree);
  }

  if (Opt_current_pu_st == NULL) {
    Opt_current_pu_st = st;
    Opt_current_pu = ST_pu(st);
  }
  else if (st != Opt_current_pu_st) {
    Opt_current_pu_st = st;
    Opt_current_pu = ST_pu(st);
  }
  else {
  }
}

// ====================================================================
// class WOPT_SWITCHES
//   This class is designed to save the original global WOPT_Enable_*
//   flags.  Once all flags are saved, we can then freely adjust all
//   flags within the optimizer.  But, before we exit the optimizer,
//   we restore the global flags to their original state.
//   For the nature of this work, we use the constructor and
//   destructor of this class to call two private functions:
//
//     Adjust_Optimization(void)
//       and
//     Unadjust_Optimization(void)
//
//   The major advantage to use the destructor, is the C++ compiler
//   help assuring that the original state are restored.
//
//   Whenever you add a new flag, please follow the existing setup:
//     a. add a member, for this new flag, follow the naming
//        convention.
//     b. add a line in the constructor, to save the value in this new
//        flag. For the destructor, restore the original value.
//     c. add to Adjust_Optimization and Unadjust_Optimization, if you
//        need to adjust the flag for different phase.
//     d. all flags are in alphabetical order.  It makes easier to
//        update.
// ====================================================================
class WOPT_SWITCHES {
private:
  OPT_PHASE _phase;
  INT32     _pragma_flags;
  BOOL  _add_do_loop_info;
  BOOL  _add_label_loop_info;
  BOOL  _addr;
  BOOL  _aggressive_dce;
  BOOL  _aggressive_code_motion;
  BOOL  _alias_classification;
  BOOL  _alias_class_fortran_rule;
  BOOL  _alias_pointer_parms;
  BOOL  _combine_operations;
  BOOL  _call_zero_version; 
  BOOL  _compare_simp;
  INT32 _copy_propagate;
  BOOL  _copy_prop_into_array;/* propagate array ref into array index */
  BOOL  _crsimp;         /* coderep simplifier				*/
  BOOL  _dce;
  BOOL  _dce_alias;
  BOOL  _dce_label;
  BOOL  _dse_aggressive;
  BOOL  _du_full;	/* full DU info for indirect references */
  BOOL  _edge_placement;
  BOOL  _exp_pre;
  BOOL  _fold2const;	/* simplification during copy propagation	*/
  BOOL  _lno_copy;
  BOOL  _fsa;
  BOOL  _goto;
  BOOL  _iload_prop;
  BOOL  _input_prop;
  BOOL  _itself_prop;
  BOOL  _ivar_common;
  BOOL  _ive;		/* induction-var elimination */
  BOOL  _ivr;		/* induction-var recognition */
  BOOL  _ldx;            /* index load optimization */
  BOOL  _lego_opt;
  BOOL  _load_pre;
  BOOL  _local_rvi;
  BOOL  _ocopy;
  BOOL  _parm;		/* insert optparm nodes over call parms */
  BOOL  _phi_simp;
  BOOL  _prop_aggressive; 
  BOOL  _replace_second_iv;
  BOOL  _restricted_map;
  BOOL  _rvi;		/* reg-var identification			*/
  BOOL  _simp_iload;
  BOOL  _slt;
  BOOL  _store_pre;
  BOOL  _ssa_pre;
  BOOL  _tail_recur;
  INT32 _trip;
  BOOL  _update_vsym;
  INT32 _value_numbering;  /* 0==off, 1==single-pass, 2==iterative */
  BOOL  _verbose;
  INT32 _verify;	/* verify data structures      	                */
  BOOL  _vn_full;
  BOOL  _vsym_unique;
  BOOL  _while_loop;	/* cvt while-do to do-loop			*/
  BOOL  _wn_simp;	/* WHIRL node simplifier			*/
  BOOL  _wovp; /* Write-once variable promotion   */
  BOOL  _zero_version;
  BOOL  _epre_before_ivr; // For running epre early
  BOOL  _lpre_before_ivr; // For running lpre early
  BOOL  _spre_before_ivr; // For running spre early
  BOOL  _bdce_before_ivr; // For running bdce early


  WOPT_SWITCHES(const WOPT_SWITCHES&);
  WOPT_SWITCHES& operator = (const WOPT_SWITCHES&);
  void Adjust_Optimization(void) {
    switch (_phase) {
    case PREOPT_DUONLY_PHASE:
      /* set all optimizations off */
      WOPT_Enable_Add_Do_Loop_Info =
      WOPT_Enable_Add_Label_Loop_Info =
      WOPT_Enable_Aggressive_dce =
      WOPT_Enable_Aggressive_Code_Motion =
      WOPT_Enable_Alias_Classification =
      WOPT_Enable_Alias_Class_Fortran_Rule =
      WOPT_Enable_Combine_Operations =
      WOPT_Enable_Compare_Simp =
      WOPT_Enable_CRSIMP =
      WOPT_Enable_DCE =
      WOPT_Enable_DCE_Alias =
      WOPT_Enable_Edge_Placement =
      WOPT_Enable_Exp_PRE =
      WOPT_Enable_Fold2const =
      WOPT_Enable_LNO_Copy_Propagate =
      WOPT_Enable_FSA =
      WOPT_Enable_Goto =
      WOPT_Enable_Input_Prop =
      WOPT_Enable_Itself_Prop =
      WOPT_Enable_Ivar_Common =
      WOPT_Enable_IVE =
      WOPT_Enable_IVR =
      WOPT_Enable_Ldx =
      WOPT_Enable_Load_PRE =
      WOPT_Enable_Local_Rvi =
      WOPT_Enable_Output_Copy = 
      WOPT_Enable_Parm =
      WOPT_Enable_Phi_Simp =
      WOPT_Enable_RVI =
      WOPT_Enable_SLT =
      WOPT_Enable_Store_PRE =
      WOPT_Enable_SSA_PRE =
      WOPT_Enable_Vsym_Unique =
      WOPT_Enable_WOVP =
      Enable_WN_Simp =			// disable WHIRL simplifier
      // WOPT_Enable_Zero_Version =
      WOPT_Enable_Tail_Recur =
	FALSE;

      WOPT_Enable_Copy_Propagate = TRUE;
      WOPT_Enable_Verify = 1;
      break;

    case PREOPT_IPA0_PHASE:
    case PREOPT_IPA1_PHASE:
      WOPT_Enable_Call_Zero_Version = FALSE;
      WOPT_Enable_Combine_Operations = FALSE;
      WOPT_Enable_Goto = FALSE;
      WOPT_Enable_WOVP = FALSE;
      WOPT_Enable_Tail_Recur = FALSE;
      break;

    case MAINOPT_PHASE:
      WOPT_Enable_While_Loop = FALSE;

      // disable edge placement if new pre is off
      if (! WOPT_Enable_SSA_PRE) {
	WOPT_Enable_Edge_Placement = FALSE;
	WOPT_Enable_Backedge_Placement = FALSE;
      }
      else {
        WOPT_Enable_RVI1 = FALSE;
        if (!WOPT_Enable_Exp_PRE && WOPT_Enable_Load_PRE) {
          // need to establish var phi hash
          WOPT_Enable_Exp_PRE = TRUE;
          WOPT_Enable_Exp_PRE_Limit = 0;
        }
      }

      if (Opt_Level > 2 && PU_mp_needs_lno(Get_Current_PU())) {
	WOPT_Enable_Lego_Opt = TRUE;
      }

      if (Opt_Level <= 2) {
	// off for -O2, turned on at -O3, PV 507356
	WOPT_Enable_Replace_Second_IV = FALSE;

	// improve compile time
	if (!WOPT_Enable_Extra_Rename_Pass_Set)
	  WOPT_Enable_Extra_Rename_Pass = 1;
      }

      if (WOPT_Enable_Lego_Opt) {
	WOPT_Enable_Compare_Simp = TRUE;
	WOPT_Enable_Replace_Second_IV = TRUE;
	WOPT_Enable_LFTR_Ivar = TRUE;
	// WOPT_Enable_Iload_Prop = FALSE;
      }

      // if the global flag "Allow_wrap_around_opt" is off
      if ( ! Allow_wrap_around_opt ) {
        WOPT_Enable_LFTR2 = FALSE;
        WOPT_Enable_Compare_Simp = FALSE;
        WOPT_Enable_IVR = FALSE;
      }

      // disable WHIRL simplifier
      Enable_WN_Simp = FALSE;

      // always disable LNO copy prop
      WOPT_Enable_LNO_Copy_Propagate = FALSE;

      // only combine operations in the main optimizer phase
      WOPT_Enable_Combine_Operations = _combine_operations;

      // do not get rid of useless labels (yet?) during mainopt
      WOPT_Enable_DCE_Label = FALSE;

      // allow prop of array refs into array indexes during mainopt
      if ( ! WOPT_Enable_Copy_Prop_Ops_Into_Array_Set )
	WOPT_Enable_Copy_Prop_Ops_Into_Array = TRUE;

      if (WOPT_Enable_Feedback_LPRE || WOPT_Enable_Feedback_EPRE)
	WOPT_Enable_Zero_Version = FALSE;

      break; // end MAINOPT_PHASE
    case PREOPT_LNO_PHASE: 
      if (Run_autopar && Current_LNO->IPA_Enabled
#ifdef KEY // bug 6383
	  && PU_WN_BB_Cnt < 2000
#endif
	  ) { 
	WOPT_Enable_Call_Zero_Version = FALSE;
	WOPT_Enable_Zero_Version = FALSE;
	WOPT_Enable_DU_Full = TRUE;
      } 
      // fall though 
    default:
      // if the global flag "Allow_wrap_around_opt" is off
      if ( ! Allow_wrap_around_opt ) {
        WOPT_Enable_Compare_Simp = FALSE;
        WOPT_Enable_IVR = FALSE;
      }
      WOPT_Enable_Combine_Operations = FALSE;
      WOPT_Enable_SLT = FALSE;
      break;
    } // switch
    WOPT_Enable_Ldx = Indexed_Loads_Allowed;

    if (_pragma_flags & WOPT_TAIL_RECUR_FINISHED)
      WOPT_Enable_Tail_Recur = FALSE;

    if (_phase != MAINOPT_PHASE || !WOPT_Enable_New_Phase_Ordering)
    {
      WOPT_Enable_Epre_Before_Ivr = FALSE; // For running epre early
      WOPT_Enable_Lpre_Before_Ivr = FALSE; // For running lpre early
      WOPT_Enable_Spre_Before_Ivr = FALSE; // For running spre early
      WOPT_Enable_Bdce_Before_Ivr = FALSE; // For running bdce early
    }
  }

  void Unadjust_Optimization(void) {
    switch (_phase) {
    case PREOPT_DUONLY_PHASE:
      /* reset all optimizations */
      WOPT_Enable_Compare_Simp = _compare_simp;
      WOPT_Enable_Add_Do_Loop_Info = _add_do_loop_info;
      WOPT_Enable_Add_Label_Loop_Info = _add_label_loop_info;
      WOPT_Enable_Aggressive_dce = _aggressive_dce;
      WOPT_Enable_Aggressive_Code_Motion = _aggressive_code_motion;
      WOPT_Enable_Alias_Classification = _alias_classification;
      WOPT_Enable_Alias_Class_Fortran_Rule = _alias_class_fortran_rule;
      WOPT_Enable_Copy_Propagate = _copy_propagate;
      WOPT_Enable_CRSIMP         = _crsimp;
      WOPT_Enable_DCE            = _dce;
      WOPT_Enable_DCE_Alias      = _dce_alias;
      WOPT_Enable_DU_Full        = _du_full;
      WOPT_Enable_Edge_Placement = _edge_placement;
      WOPT_Enable_Exp_PRE        = _exp_pre;
      WOPT_Enable_Fold2const     = _fold2const;
      WOPT_Enable_FSA            = _fsa;
      WOPT_Enable_Generate_Trip_Count = _trip;
      WOPT_Enable_Improved_Addr_Taken = _addr;
      WOPT_Enable_Input_Prop     = _input_prop;
      WOPT_Enable_Ivar_Common    = _ivar_common;
      WOPT_Enable_IVE            = _ive;
      WOPT_Enable_IVR            = _ivr;
      WOPT_Enable_Ldx            = _ldx;
      WOPT_Enable_LNO_Copy_Propagate = _lno_copy;
      WOPT_Enable_Load_PRE       = _load_pre;
      WOPT_Enable_Local_Rvi      = _local_rvi;
      WOPT_Enable_Output_Copy    = _ocopy;
      WOPT_Enable_Parm           = _parm;
      WOPT_Enable_Phi_Simp       = _phi_simp;
      WOPT_Enable_RVI            = _rvi;
      WOPT_Enable_Store_PRE      = _store_pre;
      WOPT_Enable_SSA_PRE        = _ssa_pre;
      WOPT_Enable_Verify         = _verify;
      WOPT_Enable_Vsym_Unique    = _vsym_unique;
      WOPT_Enable_WOVP           = _wovp;
      WOPT_Enable_Zero_Version   = _zero_version;
      WOPT_Enable_Epre_Before_Ivr = _epre_before_ivr;
      break;
    case PREOPT_IPA0_PHASE:
    case PREOPT_IPA1_PHASE:
      WOPT_Enable_Compare_Simp = _compare_simp;
      WOPT_Enable_IVR            = _ivr;
      WOPT_Enable_SLT            = _slt;
      WOPT_Enable_WOVP           = _wovp;
      break;
    case MAINOPT_PHASE:
      WOPT_Enable_Compare_Simp = _compare_simp;
      WOPT_Enable_Copy_Prop_Ops_Into_Array = _copy_prop_into_array;
      WOPT_Enable_CRSIMP         = _crsimp;
      WOPT_Enable_DCE_Label      = _dce_label;
      WOPT_Enable_IVR            = _ivr;
      WOPT_Enable_Lego_Opt       = _lego_opt;
      WOPT_Enable_While_Loop     = _while_loop;
      WOPT_Enable_Improved_Addr_Taken = _addr;
      WOPT_Enable_Generate_Trip_Count = _trip;
      WOPT_Enable_LNO_Copy_Propagate  = _lno_copy;
      WOPT_Enable_Zero_Version   = _zero_version;
      break;
    case PREOPT_LNO_PHASE:
      if (Run_autopar && Current_LNO->IPA_Enabled) { 
        WOPT_Enable_Call_Zero_Version = _call_zero_version;
        WOPT_Enable_Zero_Version = _zero_version;
        WOPT_Enable_DU_Full = _du_full;
      } 
    default:
      WOPT_Enable_SLT = _slt;
      break;
    }

    Enable_WN_Simp = _wn_simp;
    WOPT_Enable_Goto = _goto;
    WOPT_Enable_Combine_Operations = _combine_operations;
    WOPT_Enable_Tail_Recur = _tail_recur;
    WOPT_Enable_Replace_Second_IV = _replace_second_iv;
    WOPT_Enable_Restricted_Map = _restricted_map;
    WOPT_Enable_Value_Numbering = _value_numbering;
    WOPT_Enable_Itself_Prop     = _itself_prop;

    WOPT_Enable_Epre_Before_Ivr = _epre_before_ivr; // For running epre early
    WOPT_Enable_Lpre_Before_Ivr = _lpre_before_ivr; // For running lpre early
    WOPT_Enable_Spre_Before_Ivr = _spre_before_ivr; // For running spre early
    WOPT_Enable_Bdce_Before_Ivr = _bdce_before_ivr; // For running bdce early

    Alias_Pointer_Parms = _alias_pointer_parms;
  }

public:
  WOPT_SWITCHES(OPT_PHASE phase, INT32 pragma_flags, BOOL disable_parm_alias) {
    _phase = phase;
    _pragma_flags = pragma_flags;

    _alias_pointer_parms = Alias_Pointer_Parms;
    if (disable_parm_alias) 
      Alias_Pointer_Parms = FALSE;

    _add_do_loop_info = WOPT_Enable_Add_Do_Loop_Info;
    _add_label_loop_info = WOPT_Enable_Add_Label_Loop_Info;
    _addr = WOPT_Enable_Improved_Addr_Taken;
    _aggressive_dce = WOPT_Enable_Aggressive_dce;
    _aggressive_code_motion = WOPT_Enable_Aggressive_Code_Motion;
    _alias_classification = WOPT_Enable_Alias_Classification;
    _alias_class_fortran_rule = WOPT_Enable_Alias_Class_Fortran_Rule;
    _call_zero_version = WOPT_Enable_Call_Zero_Version;
    _combine_operations = WOPT_Enable_Combine_Operations;
    _compare_simp = WOPT_Enable_Compare_Simp;
    _copy_propagate = WOPT_Enable_Copy_Propagate;
    _copy_prop_into_array = WOPT_Enable_Copy_Prop_Ops_Into_Array;
    _crsimp = WOPT_Enable_CRSIMP;
    _dce = WOPT_Enable_DCE;
    _dce_alias = WOPT_Enable_DCE_Alias;
    _dce_label = WOPT_Enable_DCE_Label;	/* eliminate dead labels? */
    _du_full = WOPT_Enable_DU_Full;	/* full DU for indirects */
    _edge_placement = WOPT_Enable_Edge_Placement;
    _exp_pre = WOPT_Enable_Exp_PRE;
    _fold2const = WOPT_Enable_Fold2const;
    _lno_copy = WOPT_Enable_LNO_Copy_Propagate;
    _fsa = WOPT_Enable_FSA;
    _goto = WOPT_Enable_Goto;
    _input_prop = WOPT_Enable_Input_Prop;
    _itself_prop = WOPT_Enable_Itself_Prop;
    _ivar_common = WOPT_Enable_Ivar_Common;
    _ive = WOPT_Enable_IVE;		/* induction-var elim */
    _ivr = WOPT_Enable_IVR;		/* induction-var recognition */
    _ldx = Indexed_Loads_Allowed;       /* from config.h, -OPT:ldx */
    _lego_opt = WOPT_Enable_Lego_Opt;
    //_ldx = WOPT_Enable_Ldx;
    _load_pre = WOPT_Enable_Load_PRE;
    _local_rvi = WOPT_Enable_Local_Rvi;
    _ocopy = WOPT_Enable_Output_Copy;
    _parm = WOPT_Enable_Parm;		/* put optparm over params */
    _phi_simp = WOPT_Enable_Phi_Simp;
    _rvi = WOPT_Enable_RVI;		/* reg-var identification */
    _slt = WOPT_Enable_SLT;
    _store_pre = WOPT_Enable_Store_PRE;
    _ssa_pre = WOPT_Enable_SSA_PRE;
    _trip = WOPT_Enable_Generate_Trip_Count;
    _update_vsym = WOPT_Enable_Update_Vsym;
    _value_numbering = WOPT_Enable_Value_Numbering;
    _verbose = WOPT_Enable_Verbose;
    _vsym_unique = WOPT_Enable_Vsym_Unique;
    _verify = WOPT_Enable_Verify;	/* verify data structures */
    _while_loop = WOPT_Enable_While_Loop;/*cvt while-do to do-loop */
    _wn_simp = Enable_WN_Simp;
    _wovp = WOPT_Enable_WOVP; /* Write-once variable promotion  */
    _zero_version = WOPT_Enable_Zero_Version;
    _vsym_unique = WOPT_Enable_Vsym_Unique;
    _dse_aggressive = WOPT_Enable_Dse_Aggressive;
    _prop_aggressive = WOPT_Enable_Prop_Aggressive;
    _iload_prop = WOPT_Enable_Iload_Prop;
    _vn_full = WOPT_Enable_VN_Full;
    _simp_iload = WOPT_Enable_Simp_Iload;
    _tail_recur = WOPT_Enable_Tail_Recur;
    _replace_second_iv = WOPT_Enable_Replace_Second_IV;
    _restricted_map = WOPT_Enable_Restricted_Map;
    _epre_before_ivr = WOPT_Enable_Epre_Before_Ivr; // For running epre early
    _lpre_before_ivr = WOPT_Enable_Lpre_Before_Ivr; // For running lpre early
    _spre_before_ivr = WOPT_Enable_Spre_Before_Ivr; // For running spre early
    _bdce_before_ivr = WOPT_Enable_Bdce_Before_Ivr; // For running bdce early

    Adjust_Optimization();
  }
  ~WOPT_SWITCHES(void)                       { Unadjust_Optimization(); }

};

//  COMP_UNIT constructor
//
COMP_UNIT::COMP_UNIT(WN *t, ALIAS_MANAGER *am, OPT_PHASE phase, 
		     MEM_POOL *gpool,MEM_POOL *lpool)
{
  extern void  Initialize_CR_simp(CODEMAP*); // or we include opt_fold.h

  _phase = phase;
  Set_tlog_phase(phase);
  _mem_pool = gpool;
  _loc_pool = lpool;
  _input_tree = t;
  _rid = REGION_get_rid(_input_tree);
  _arule = am->Rule();
  _alias_mgr = am;
  _cfg = CXX_NEW(CFG(gpool, lpool), gpool);
  _opt_stab = CXX_NEW(OPT_STAB(gpool), gpool);
  _exc = CXX_NEW(EXC(_cfg, _opt_stab, gpool), gpool); 
  _cfg->Set_exc(_exc);
  _ssa = CXX_NEW(SSA(gpool, lpool), gpool);
  _emitter =  CXX_NEW(EMITTER(lpool, gpool, phase), gpool);
  _htable = CXX_NEW(CODEMAP(CODE_HTABLE_SIZE, _cfg,
			    _opt_stab, _ssa,
                            VAR_PHI_HASH_SIZE, phase, gpool),
		    gpool);
  _main_emitter = NULL;
  WN_init_flags(gpool);            // Create a debugging WN map
  Initialize_CR_simp(_htable);     // CR simplifier needs to be initialized
  VN_EXPR::Init_Free_Lists(gpool); // Initialize free lists for value numbering
}


// COMP_UNIT destructor
//
COMP_UNIT::~COMP_UNIT(void)
{
  VN_EXPR::Reclaim_Free_Lists(); // Reclaim free lists for value numbering
  WN_fini_flags();                // Delete the debugging WN map
  CXX_DELETE(_cfg,      _mem_pool);
  CXX_DELETE(_opt_stab, _mem_pool);
  CXX_DELETE(_ssa,      _mem_pool);
  CXX_DELETE(_emitter,  _mem_pool);
  CXX_DELETE(_htable,   _mem_pool);
  CXX_DELETE(_exc,      _mem_pool);
}


void COMP_UNIT::Create_mainopt_res(void)
{ 
  _cfg->Analyze_loops();
}


// Return TRUE if optimization should be skipped
// NOTE: this is used by Perform_Global_Optimization (wodriver.c) and by
// Pre_Optimizer (opt_main.cxx).
// NOTE: WN_st is not defined for a region.
static BOOL Disable_opt(WN *wn_tree, ST *pu_st)
{
  BOOL is_pu = (WN_opcode(wn_tree) == OPC_FUNC_ENTRY);
  char *pu_name = ST_name(pu_st);
  char *rgn_name = (char*)alloca(strlen(pu_name) + 32);

  if (is_pu)
    sprintf(rgn_name,"function %s",pu_name);
  else
    sprintf(rgn_name,"region %d (function %s)",
	    RID_id(REGION_get_rid(wn_tree)),pu_name);

  // skip the functions specified
  if (WOPT_Enable_Skip != NULL) {
    regex_t buf;
    regmatch_t dummy[1];
    if (regcomp(&buf, WOPT_Enable_Skip, REG_NOSUB | REG_NEWLINE) == 0 &&
        regexec(&buf, pu_name, 1, dummy, 0) == 0) {
      DevWarn("WOPT skip %s", rgn_name);
      return TRUE;
    }
  }

  // skip_equal, skip_before, skip_after function count specified
  if ( Query_Skiplist ( WOPT_Skip_List, Current_PU_Count() ) ) {
    if ( Show_Progress )
      ErrMsg(EC_Skip_PU, " WOPT", Current_PU_Count(), rgn_name);
    return TRUE;
  }

  // process the functions specified
  if (WOPT_Enable_Process != NULL) {
    regex_t buf;
    regmatch_t dummy[1];
    if (regcomp(&buf, WOPT_Enable_Process, REG_NOSUB | REG_NEWLINE) == 0 &&
        regexec(&buf, pu_name, 1, dummy, 0) == 0) {
    } else {
      DevWarn("WOPT skip %s", rgn_name);
      return TRUE;
    }
  }

  return FALSE;
}

static BOOL
This_preopt_renumbers_pregs(INT32 phase)
{
  return ((((phase == PREOPT_IPA0_PHASE) && // ipl
	    IPA_Enable_Alias_Class) ||
	   (phase == PREOPT_LNO_PHASE) ||
	   (phase == PREOPT_PHASE)) &&
	  !Is_Set_PU_Info_flags(Current_PU_Info,
				PU_PREGS_RENUMBERED));
}


static void
Verify_Codemap(COMP_UNIT *comp_unit)
{
#ifdef Is_True_On  
  SET_OPT_PHASE("Verify CODEMAP");

  Is_True(comp_unit->Verify_IR(comp_unit->Cfg(),comp_unit->Htable(),0),
	  ("Verify CFG wrong"));

  if (Get_Trace(TKIND_INFO, TINFO_TIME)) 
    SET_OPT_PHASE("Skip verify CODEMAP because timing trace is on");
  else
    Is_True(comp_unit->Verify_CODEMAP(), ("CODEMAP corrupted."));

  if (Get_Trace(TKIND_INFO, TINFO_TIME)) 
    SET_OPT_PHASE("Skip verify CODEMAP because timing trace is on");
  else {
    Is_True(comp_unit->Verify_CODEMAP(), ("CODEMAP corrupted."));
    comp_unit->Htable()->Verify_hashing();
  }
  
  if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
    SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
  } else {
    SET_OPT_PHASE("Verify Live-Range");
    comp_unit->Verify_version();
  }
#endif // Is_True_On  
} // Verify_Codemap


extern void CFG_transformation(COMP_UNIT *cu, bool, bool, bool);
extern void Rename_CODEMAP(COMP_UNIT *);


static void 
Do_Pre_Before_Ivr(COMP_UNIT *comp_unit)
{
  // This provides an experimental framework for moving PRE and BCDE up
  // before IVR, and is off by default.  It has been minimally tested, but
  // works for most of the cases on which it has been tested.  One problem
  // encountered, which has not yet been fixed, is the following assertion
  // when compiling sanity_tests/overall/compile_only/cmetric.c with options
  // "-n32 -mips4 -O3 -c -WOPT:lpre4ivr=on:spre4ivr=on:bdce4ivr=on":
  //
  //   ### Assertion failure at line 706 of ../../be/opt/opt_htable.h:
  //   ### Compiler Error in file vn26_cmetric.c during Global Optimization
  //       -- New PRE: Build initial occurrence lists phase:
  //   ### CODEREP::Kid_count, illegal kind CK_VAR
  //

  // Always do a minimal DCE before early versions of PRE and BDCE,
  // since it sets up the and marks PHI nodes (liveness) appropriately
  // for these phases.
  //
  if (WOPT_Enable_Epre_Before_Ivr ||
      WOPT_Enable_Lpre_Before_Ivr ||
      WOPT_Enable_Spre_Before_Ivr ||
      WOPT_Enable_Bdce_Before_Ivr)
  {
    BOOL dummy;
    comp_unit->Do_dead_code_elim(FALSE/*do_unreachable*/,
				 FALSE/*do_dce_global*/,
				 FALSE/*do_dce_alias*/,
				 FALSE/*do_agg_dce*/,
				 FALSE/*do_identity_removal*/,
				 FALSE/*do_preg_renumbering*/,
				 &dummy/*paths_removed*/);
  }

  // Disable strength reduction, lftr, and pre for constants in this
  // early invocation of PRE algorithms.
  //

  if (WOPT_Enable_Epre_Before_Ivr)
  {
        SET_OPT_PHASE("SSA PRE before RVI");
        comp_unit->Do_new_pre();
        if (Get_Trace(TP_GLOBOPT, CR_DUMP_FLAG)) {
          comp_unit->Htable()->Print(TFile);
        }
	Verify_Codemap(comp_unit);
  }
  if (WOPT_Enable_Lpre_Before_Ivr)
  {
    SET_OPT_PHASE("Load PRE before RVI");
    comp_unit->Htable()->Verify_var_phi_hash();
    comp_unit->Do_load_pre(FALSE /*do_consts*/, TRUE /*do_loads*/);
    
    if (Get_Trace(TP_GLOBOPT, CR_DUMP_FLAG)) {
      comp_unit->Htable()->Print(TFile);
    }
    Verify_Codemap(comp_unit);
  }
  if (WOPT_Enable_Spre_Before_Ivr)
  {
    SET_OPT_PHASE("Store PRE before RVI");
    comp_unit->Htable()->Verify_var_phi_hash();
    comp_unit->Do_store_pre();

    if (Get_Trace(TP_GLOBOPT, CR_DUMP_FLAG)) {
      comp_unit->Htable()->Print(TFile);
    }
    Verify_Codemap(comp_unit);
  }
  if (WOPT_Enable_Bdce_Before_Ivr)
  {
    SET_OPT_PHASE("Bitwise DCE before RVI");
    comp_unit->Do_bitwise_dce(FALSE /* copy propatage on */);
  }

  if (WOPT_Enable_Epre_Before_Ivr || WOPT_Enable_Epre_Before_Ivr)
  {
    SET_OPT_PHASE("Second rename before RVI");
    Rename_CODEMAP(comp_unit);
  }

} // Do_Pre_Before_Ivr


WN *
Pre_Optimizer(INT32 phase, WN *wn_tree, DU_MANAGER *du_mgr,
	      ALIAS_MANAGER *alias_mgr)
{
  WN *wn_orig = wn_tree; // needed for region <--> RID consistency

  SET_OPT_PHASE("Preparation");

  if (Get_Trace(TP_GLOBOPT, -1)) {
    fprintf (TFile,  "%s \t Pre_Optimizer phase=%d\n %s\n", DBar, phase, DBar);
  }

  Is_True(phase == PREOPT_IPA0_PHASE ||
	  phase == PREOPT_IPA1_PHASE ||
	  phase == PREOPT_LNO_PHASE ||
	  phase == PREOPT_DUONLY_PHASE ||
	  phase == PREOPT_PHASE ||
	  phase == MAINOPT_PHASE,
          ("Unknown optimizer phase."));

  Is_True(WN_opcode(wn_orig)==OPC_FUNC_ENTRY || WN_opcode(wn_orig)==OPC_REGION,
	  ("Pre_Optimizer, unknown WHIRL entry point"));

  // sets Opt_current_pu_st static
  Opt_set_current_pu_name(wn_tree);

  // If dont_opt is TRUE then do lowering only.
  BOOL dont_opt = Disable_opt(wn_tree, Opt_current_pu_st);

  WN *wopt_pragma = (WN_opcode(wn_orig) == OPC_FUNC_ENTRY) ? 
    WN_func_pragmas(wn_orig) : WN_region_pragmas(wn_orig);
  INT32 pragma_flags = 0;
  BOOL  disable_parm_alias = FALSE;
  for (wopt_pragma = WN_first(wopt_pragma);
       wopt_pragma != NULL;
       wopt_pragma = WN_next(wopt_pragma)) {
	 if ( WN_pragma(wopt_pragma) == WN_PRAGMA_WOPT_FINISHED_OPT ) {
	   pragma_flags = WN_pragma_arg2(wopt_pragma);
	 }
       }

  if (IS_FORTRAN && PU_args_aliased(Pu_Table[Opt_current_pu])) {
    disable_parm_alias = TRUE;
  }

  WOPT_SWITCHES WOPT_Enable((OPT_PHASE)phase, pragma_flags,
			    disable_parm_alias);

  // A nested function that is not MP does not inherit the 
  // restricted mapping. e.g. varfmt nested functions.
  if (WN_opcode(wn_orig) != OPC_REGION) {
    if (PU_is_nested_func(Pu_Table[Opt_current_pu]) &&
	!PU_mp(Get_Current_PU()))
      WOPT_Enable_Restricted_Map = FALSE;
  }

  BOOL Fold_ILOAD_save = WN_Simp_Fold_ILOAD;
  BOOL Fold_LDA_save = WN_Simp_Fold_LDA;

  enable_tree_freq_display();  // enable frequency display for ascii
			       // WHIRL dumps

  if (phase == MAINOPT_PHASE) {
    SET_OPT_PHASE("Mainopt Lowering");
    WN_Simplifier_Enable(TRUE);
    // check if last time through PU, if so lower region exits
    INT32 lower_region_exits_flag = ((PU_has_region(Get_Current_PU()) &&
				      WN_opcode(wn_orig) == OPC_FUNC_ENTRY) ?
				     LOWER_REGION_EXITS : 0);
    WN_Simp_Fold_ILOAD = TRUE;
    WN_Simp_Fold_LDA = TRUE;
    LOWER_ACTIONS actions =
	LOWER_COMPLEX |
	LOWER_BASE_INDEX |
	LOWER_ARRAY |
	LOWER_ALL_MAPS |
	LOWER_INLINE_INTRINSIC |
	LOWER_IO_STATEMENT |
	LOWER_ENTRY_EXIT |
	LOWER_SHORTCIRCUIT |
#ifdef KEY
	LOWER_UPLEVEL |
#endif
	lower_region_exits_flag;	// this is a variable
    
    if (WOPT_Enable_Bits_Load_Store)
	actions |= LOWER_BIT_FIELD_ID;
    else
	actions |= LOWER_BITS_OP;
                                                                                                                                                             
    actions |= LOWER_TO_MEMLIB; // add memlib transformation
 
    wn_tree = WN_Lower(wn_orig, actions, alias_mgr, "Pre_Opt");

#ifdef TARG_X8664
    BOOL target_64bit = Is_Target_64bit();
#else
    BOOL target_64bit = TRUE;
#endif

#ifdef KEY
    if (target_64bit && WOPT_Enable_Retype_Expr)
      WN_retype_expr(wn_tree);
#endif

#if defined(KEY) && !defined(TARG_IA64)
    WN_unroll(wn_tree);
#endif

    if (Cur_PU_Feedback)
      Cur_PU_Feedback->Reset_Root_WN(wn_tree);
    if (Only_Unsigned_64_Bit_Ops && ! Delay_U64_Lowering)
      U64_lower_wn(wn_tree, FALSE); 	 // lowering for unsigned 64-bit ISA
    Is_True(REGION_consistency_check(wn_tree),
	    ("Pre_Optimizer REGION inconsistency")); // lowerer maintains RID
    wn_orig = wn_tree; // new orig tree

    // return if we should not optimize this function
    if (dont_opt) return wn_tree;

    WN_Simplifier_Enable(FALSE);
    
    if ( Get_Trace( TP_GLOBOPT, OPT_LOWER_FLAG ) ) {
      fprintf( TFile, "%sAfter Mainopt Lowering\n%s",DBar,DBar );
      fdump_tree(TFile, wn_tree);
    }
    
    if (phase == MAINOPT_PHASE && Current_Dep_Graph != NULL &&
	Get_Trace(TP_LNOPT, 1)) {
      /* Trace LNO graph for CG again, since WN addresses have changed */
      fprintf(TFile, "%sLNO dep graph for CG, before WOPT\n%s", DBar, DBar);
      Current_Dep_Graph->Print(TFile);
      fprintf(TFile, "%s", DBar);
    }
  } // if (phase == MAINOPT_PHASE)
  else {
    if ( Get_Trace( TP_GLOBOPT, OPT_LOWER_FLAG ) ) {
      fprintf( TFile, "%sAfter Vho Lowering\n%s",DBar,DBar );
      fdump_tree(TFile, wn_tree);
    }

    // Workaround for 440589 for v7.1.   Lower IO-statements in preopt if
    // the PU contains NAMELIST because the NAMELIST side-effect
    // is only represented in the lowered IOs.

    LOWER_ACTIONS lower_flags = LOWER_NULL;

    if (PU_has_namelist(Get_Current_PU())) 
      lower_flags |= LOWER_IO_STATEMENT;

    if (WOPT_Enable_Lower_Short_Circuit ||
	(Cur_PU_Feedback && !WOPT_Enable_Lower_Short_Circuit_Set)) 
      lower_flags |= LOWER_SHORTCIRCUIT;

    if (! WOPT_Enable_Bits_Load_Store)
      lower_flags |= LOWER_BITS_OP;
    
    if (lower_flags != LOWER_NULL) {
      wn_tree = WN_Lower(wn_tree, lower_flags, alias_mgr, 
			 "Pre_opt: special lowering for NAMELIST");
      if (Cur_PU_Feedback)
	Cur_PU_Feedback->Reset_Root_WN(wn_tree);
    }

    // return if we should not optimize this function
    if (dont_opt) return wn_tree;

  }

  Opt_memory_init_pools();

  // goto conversion
  if (WOPT_Enable_Goto &&
      (phase == PREOPT_LNO_PHASE || phase == PREOPT_PHASE)) {
#ifdef KEY
    // goto_skip_equal, goto_skip_before, goto_skip_after PU count specified
    if ( Query_Skiplist ( Goto_Skip_List, Current_PU_Count() ) ) {
      if ( Show_Progress )
        ErrMsg(EC_Skip_PU, " goto conversion", Current_PU_Count(), Cur_PU_Name);
    }
    else {
#endif
    SET_OPT_PHASE("Goto conversion");
    OPT_POOL_Push( &Opt_local_pool, MEM_DUMP_FLAG+2 );
    {
      GOTO_TABLE goto_table( wn_tree, &Opt_local_pool );
      goto_table.Remove_Gotos();
      // goto_table gets destructed before we pop the pool
    }
    OPT_POOL_Pop( &Opt_local_pool, MEM_DUMP_FLAG+2 );

    if ( Get_Trace( TP_GLOBOPT, OPT_LOWER_FLAG ) ) {
      fprintf( TFile, "%sAfter Goto Conversion\n%s",DBar,DBar );
      fdump_tree(TFile, wn_tree);
    }
#ifdef KEY
    }
#endif
  }

  SET_OPT_PHASE("Preparation");

#ifdef SKIP
  // check for inadvertent increase in size of data structures
  Is_True(sizeof(CODEREP) == 48,
    ("Size of CODEREP has been changed (is now %d)!",sizeof(CODEREP)));
#ifdef linux
  Is_True(sizeof(STMTREP) == 60,
    ("Size of STMTREP has been changed (is now %d)!",sizeof(STMTREP)));
#else
  Is_True(sizeof(STMTREP) == 64,
    ("Size of STMTREP has been changed (is now %d)!",sizeof(STMTREP)));
#endif
#endif

  // allocate space for cfg, htable, and itable
  COMP_UNIT *comp_unit = CXX_NEW(COMP_UNIT(wn_tree, alias_mgr,
		(OPT_PHASE)phase, &Opt_global_pool, &Opt_local_pool),
				 &Opt_global_pool);

#ifdef Is_True_On
  g_comp_unit = comp_unit;
  // comp_unit->Verify_addr_taken();
#endif

  Is_True(comp_unit->Cfg()->Verify_tree(comp_unit->Input_tree()), 
	  ("Verifying CFG wrong"));

  // these flags tell the symbol table and cfg what to do
  BOOL lower_fully = (phase == MAINOPT_PHASE);
  // if lower_fully, we are definitely in mainopt
  // if we are preopt, need to see who caller is
  REGION_LEVEL rgn_level = (lower_fully) ? RL_MAINOPT :
  					   RID_preopt_level(phase);

  // create aux symbol table
  // cannot print WHIRL tree after this point, use dump_tree_no_st
  SET_OPT_PHASE("Create AUX Symbol table");
  WN_Simplifier_Enable(TRUE);	// so that I can fold ILOAD-LDA
  comp_unit->Opt_stab()->Create(comp_unit, rgn_level);
  if (WOPT_Enable_Pt_Summary) {
    comp_unit->Opt_stab()->Points_to_summarizer()->
       Bind_callee_points_to_summary (wn_tree);
  }

  MEM_POOL alias_class_pool;

  OPT_POOL_Initialize(&alias_class_pool, "Alias classification pool",
		      FALSE, MEM_DUMP_FLAG+20);

  ALIAS_CLASSIFICATION ac(comp_unit->Opt_stab(),
			  AC_DESTINATION_OPT_STAB,
			  &alias_class_pool);

  comp_unit->Opt_stab()->Set_alias_classification(ac);

  // Alias classification computation should move from here so that the
  // alias class finalization process can update the OCC_TAB_ENTRY for
  // each indirect memop. See comment below, after Compute_FFA().
  if (WOPT_Enable_Alias_Classification &&
      !REGION_has_black_regions(comp_unit->Rid())) {
    SET_OPT_PHASE("Compute alias classification");
    ac.Classify_memops(comp_unit->Input_tree());
    comp_unit->Opt_stab()->Incorporate_alias_class_info();
  }

#ifdef Is_True_On
  g_opt_stab = comp_unit->Opt_stab();
#endif
  WN_Simplifier_Enable(FALSE);
  WN_Simp_Fold_ILOAD = Fold_ILOAD_save;;
  WN_Simp_Fold_LDA = Fold_LDA_save;;

  // create control flow graph
  SET_OPT_PHASE("Create CFG");

  // tail recursion
  BOOL do_tail_rec = ((! IS_FORTRAN) && WOPT_Enable_Tail_Recur);

  comp_unit->Cfg()->Create(comp_unit->Input_tree(), lower_fully,
			   WOPT_Enable_Calls_Break_BB,
			   rgn_level/*context*/, 
			   comp_unit->Opt_stab(), do_tail_rec );

  // Transfer feedback data from Whirl annotation (at Cur_PU_Feedback)
  // to optimizer CFG annotation (at comp_unit->Cfg()->Feedback())
  if (Cur_PU_Feedback) {
    SET_OPT_PHASE("Annotate CFG with feedback from Whirl");
    OPT_FEEDBACK *feedback = CXX_NEW(OPT_FEEDBACK(comp_unit->Cfg(),
						  &Opt_global_pool),
				     &Opt_global_pool);
    comp_unit->Cfg()->Set_feedback( feedback );
    comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
					  "after CFG Annotation" );
    // TODO: Perhaps clear out Cur_PU_Feedback now?
  }

  SET_OPT_PHASE("Control Flow Analysis");
  comp_unit->Cfg()->Compute_dom_tree(TRUE); // create dominator tree
  comp_unit->Cfg()->Compute_dom_tree(FALSE); // create post-dominator tree
  comp_unit->Cfg()->Remove_fake_entryexit_arcs();
  comp_unit->Cfg()->Compute_dom_frontier(); // create dominance frontier
  comp_unit->Cfg()->Compute_control_dependence(); // create control-dependence set
  comp_unit->Cfg()->Analyze_loops();

  // Setup flow free alias information  --  CHI and MU list 
  SET_OPT_PHASE("Create MU and CHI list");
  comp_unit->Opt_stab()->Compute_FFA(comp_unit->Rid());

  // Now the OCC_TAB_ENTRY for each indirect memop is set up, and the
  // correspondence between memops and POINTS_TO's is finalized. We
  // should delay alias classification until now so it can fill in the
  // _alias_class field of each POINTS_TO as it finalizes the
  // equivalence class for each memop.
  //
  // For the sake of not changing too much at once, though, I'm
  // leaving it above for now.

  Is_True(comp_unit->Cfg()->Verify_cfg(),
	  ("Verify CFG wrong after MU and CHI"));

  SET_OPT_PHASE("Create SSA Representation");
  // create ssa representation
  comp_unit->Ssa()->Construct(comp_unit->Htable(),
			      comp_unit->Cfg(),
			      comp_unit->Opt_stab());

  // Why do we wait until now to free the alias class resources? It
  // seems to me we could do it after
  // comp_unit->Opt_stab()->Compute_FFA()
  // above. -- RK 980722
  //
  // Note that this line deletes the alias classification memory pool.
  comp_unit->Opt_stab()->Alias_classification()->Release_resources();
  if (WOPT_Enable_Pt_Summary) {
    SET_OPT_PHASE("Points-to Summary Annotation");
    comp_unit->Opt_stab()->Points_to_summarizer()->
       Annotate_points_to_summary();
  }

  SET_OPT_PHASE("SSA Pointer Alias Analysis");
  comp_unit->Ssa()->Pointer_Alias_Analysis();
  SET_OPT_PHASE("Dead Store Elimination");
  comp_unit->Ssa()->Dead_store_elim(comp_unit->Cfg(),
                                    comp_unit->Opt_stab(),
                                    comp_unit->Exc());

  comp_unit->Opt_stab()->Update_return_mu();
  Analyze_pu_attr (comp_unit->Opt_stab(), Opt_current_pu_st);
  
  if (WOPT_Enable_Zero_Version) {
    SET_OPT_PHASE("Find Zero Versions");
    comp_unit->Ssa()->Find_zero_versions();
  }

  SET_OPT_PHASE("Create CODEMAP Representation");
  comp_unit->Ssa()->Create_CODEMAP();

  if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
    SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
  } else {
    SET_OPT_PHASE("Verify Live-Range");
    comp_unit->Verify_version();
  }

  SET_OPT_PHASE("Verify DO-loop");
  Detect_invalid_doloops(comp_unit);

  Is_True(comp_unit->Verify_IR(comp_unit->Cfg(), comp_unit->Htable(), 1),
	  ("Verify CFG wrong after Htable"));

  // Do some redundancy elimination phases early, to expose second order
  // effects and deal with them in the subsequent phases (e.g. CVTLs).
  //
  Do_Pre_Before_Ivr(comp_unit);

  // do induction variable recognition
  if (WOPT_Enable_IVR) {
    SET_OPT_PHASE("Induction Variable Recognition");
    comp_unit->Do_iv_recognition();
  }

  // do flow free copy propagation
  if (WOPT_Enable_Copy_Propagate) {
    SET_OPT_PHASE("Copy Propagation");
    comp_unit->Do_copy_propagate();
  }

  if (WOPT_Enable_Bool_Simp) {
    SET_OPT_PHASE("Boolean simplification");
    Simplify_bool_expr(comp_unit); 
  }

  Is_True(comp_unit->Verify_IR(comp_unit->Cfg(), comp_unit->Htable(), 2),
	  ("Verify CFG wrong after copy prop"));

  // do dead-code elimination (both unreachable and dead-stores)
  if (WOPT_Enable_DCE) {
    SET_OPT_PHASE("Dead Code Elimination");
    BOOL dce_renumber_pregs = This_preopt_renumbers_pregs(phase);
    comp_unit->Do_dead_code_elim(TRUE, TRUE, TRUE, TRUE,
				 WOPT_Enable_Copy_Propagate,
				 dce_renumber_pregs,
				 NULL);

    if ( comp_unit->Cfg()->Feedback() )
	 comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
					       "after Dead Code Elimination" );
  }

#ifdef KEY
  if (WOPT_Enable_Warn_Uninit && phase == MAINOPT_PHASE)
    comp_unit->Find_uninitialized_locals();
#endif

#ifdef KEY // moved here because renaming causes bad code when there is
    	   // overlapped live ranges, which can be created by copy propagation
  if ( WOPT_Enable_Fold_Lda_Iload_Istore ) {
    SET_OPT_PHASE("LDA-ILOAD/ISTORE folding in coderep");
    comp_unit->Fold_lda_iload_istore();
  }
#endif

  for (INT i = 0; i < WOPT_Enable_Extra_Rename_Pass; ++i) {

    if (Get_Trace(TP_WOPT2, SECOND_RENAME_FLAG)) 
      fprintf(TFile, "%sEXTRA RENAME PASS %d:\n%s", DBar, i+1, DBar);

    // only enable during MAINOPT_PHASE because the update of high level
    // structure is not implemented.  -Raymond 5/29/98.
    //
    if (WOPT_Enable_CFG_Opt && phase == MAINOPT_PHASE) {
      SET_OPT_PHASE("CFG optimization");
      CFG_transformation(comp_unit,
			 WOPT_Enable_CFG_Opt2 && i == 0, // first pass
			 Get_Trace(TP_WOPT2, CFG_OPT_FLAG),
			 WOPT_Enable_CFG_Display);

      if ( comp_unit->Cfg()->Feedback() )
	comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
					      "after CFG Optimization" );
    }

    SET_OPT_PHASE("Second rename");
    Rename_CODEMAP(comp_unit);

    if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
      SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
    } else {
      SET_OPT_PHASE("Verify Live-Range");
      comp_unit->Verify_version();
    }

    // do flow free copy propagation
    if (WOPT_Enable_Copy_Propagate) {
      SET_OPT_PHASE("Copy Propagation");
      comp_unit->Do_copy_propagate();
    }

    if (WOPT_Enable_DCE) {
      SET_OPT_PHASE("Dead Code Elimination");
      BOOL paths_removed;
      BOOL dce_renumber_pregs = This_preopt_renumbers_pregs(phase);
      comp_unit->Do_dead_code_elim(TRUE, TRUE, TRUE, TRUE,
				   WOPT_Enable_Copy_Propagate,
				   dce_renumber_pregs,
				   &paths_removed);

      if ( comp_unit->Cfg()->Feedback() )
	   comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
						 "Dead Code Elimination" );

      if (!paths_removed) break;
    }

#ifdef KEY // moved here because renaming causes bad code when there is
    	   // overlapped live ranges, which can be created by copy propagation
    if ( WOPT_Enable_Fold_Lda_Iload_Istore ) {
      SET_OPT_PHASE("LDA-ILOAD/ISTORE folding in coderep");
      comp_unit->Fold_lda_iload_istore();
    }
#endif

    // synchronize CFG and feedback info
    // comp_unit->Cfg()->Feedback().make_coherent();

    if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
      SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
    } else {
      SET_OPT_PHASE("Verify Live-Range");
      comp_unit->Verify_version();
    }
  }

  Is_True(comp_unit->Verify_IR(comp_unit->Cfg(), comp_unit->Htable(), 3),
	  ("Verify CFG wrong after extra passes"));

  if (WOPT_Enable_Edge_Placement && phase == MAINOPT_PHASE) {
    SET_OPT_PHASE("Remove Critical Edge");
    Is_Trace( Get_Trace(TP_GLOBOPT, EPRE_DUMP_FLAG), 
	     ( TFile, "-------CFG before edge placement---------\n" ) );
    Is_Trace_cmd( Get_Trace(TP_GLOBOPT, EPRE_DUMP_FLAG), 
		 comp_unit->Cfg()->Print(TFile) );
    INT count = comp_unit->Cfg()->Remove_critical_edge();
    Is_Trace( Get_Trace(TP_GLOBOPT, EPRE_DUMP_FLAG), 
	     ( TFile, "After edge Placement: BBs are placed on %d edges\n",
	       count ) );
    Is_Trace_cmd( (count>0 && Get_Trace(TP_GLOBOPT, EPRE_DUMP_FLAG)), 
		  comp_unit->Cfg()->Print(TFile) );

    if ( comp_unit->Cfg()->Feedback() )
      comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
					    "after Edge Placement" );
  }

  if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
    SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
  } else {
    SET_OPT_PHASE("Verify Live-Range");
    comp_unit->Verify_version();
  }

#ifdef Is_True_On  
  SET_OPT_PHASE("Verify CODEMAP");
  Is_True(comp_unit->Verify_IR(comp_unit->Cfg(),comp_unit->Htable(),4),
	  ("Verify CFG wrong after dce"));
  if (Get_Trace(TKIND_INFO, TINFO_TIME)) 
    SET_OPT_PHASE("Skip verify CODEMAP because timing trace is on");
  else {
    Is_True(comp_unit->Verify_CODEMAP(), ("CODEMAP corrupted."));
    comp_unit->Htable()->Verify_hashing();
  }
#endif // Is_True_On

  if(WOPT_Enable_WOVP){
     WOVP wovp(comp_unit->Cfg(), comp_unit->Opt_stab());
     wovp.Do_wovp();
  }

  // If this is the optimizer phase, we have more work to do
  WN *opt_wn;
  if ( phase == MAINOPT_PHASE ) {
#ifdef TARG_IA64
    if (WHIRL_Mtype_B_On)
      comp_unit->Introduce_mtype_bool();
#endif

    if (WOPT_Enable_Bits_Load_Store) {
      SET_OPT_PHASE("{I,}{LD,ST}BITS lowering in coderep");
      comp_unit->Lower_to_extract_compose();
      // so that LPRE/SPRE will only work on scalars, not bit-fields
    }

    if (WOPT_Enable_SSA_PRE) {
      if (WOPT_Enable_Exp_PRE) {

	if ( phase == MAINOPT_PHASE ) {
	  comp_unit->Do_vnfre(TRUE/*before_epre*/);
	}

        SET_OPT_PHASE("SSA PRE");
        comp_unit->Do_new_pre();

        if (Get_Trace(TP_GLOBOPT, CR_DUMP_FLAG)) {
          fprintf(TFile, "%sAfter Do_new_pre\n%s", DBar, DBar);
          comp_unit->Htable()->Print(TFile);
        }

	comp_unit->Do_vnfre(FALSE/*before_epre*/);

#ifdef Is_True_On  
        SET_OPT_PHASE("Verify CODEMAP");
        Is_True(comp_unit->Verify_IR(comp_unit->Cfg(),comp_unit->Htable(),5),
                ("Verify CFG wrong after dce"));
        if (Get_Trace(TKIND_INFO, TINFO_TIME)) 
          SET_OPT_PHASE("Skip verify CODEMAP because timing trace is on");
        else
          Is_True(comp_unit->Verify_CODEMAP(), ("CODEMAP corrupted."));
#endif // Is_True_On
        if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
          SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
        } else {
          SET_OPT_PHASE("Verify Live-Range");
          comp_unit->Verify_version();
        }
      }

      if (WOPT_Enable_DCE) {
	SET_OPT_PHASE("Dead Code Elimination 2");
	comp_unit->Do_dead_code_elim(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE,
				     NULL);

	if ( comp_unit->Cfg()->Feedback() )
	  comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
						"after Dead Code"
						" Elimination 2" );
      }
	
      if (Only_Unsigned_64_Bit_Ops && Delay_U64_Lowering) {
        SET_OPT_PHASE("U64 lowering in coderep");
        comp_unit->U64_lower_cr(FALSE);  // lowering for unsigned 64-bit ISA
      }

      if (WOPT_Enable_Local_Rvi) {
	SET_OPT_PHASE("Local RVI");
	comp_unit->Do_local_rvi();

        if (Get_Trace(TP_GLOBOPT, CR_DUMP_FLAG)) {
	  fprintf(TFile,"%sAfter Do_local_rvi\n%s", DBar, DBar);
          comp_unit->Htable()->Print(TFile);
	  comp_unit->Cfg()->Print(TFile);
        }

#ifdef Is_True_On  
        SET_OPT_PHASE("Verify CODEMAP");

        if (!Get_Trace(TKIND_INFO, TINFO_TIME)) 
          Is_True(comp_unit->Verify_CODEMAP(), ("CODEMAP corrupted."));
#endif // Is_True_On

        if (!Get_Trace(TKIND_INFO, TINFO_TIME)) {
          SET_OPT_PHASE("Verify Live-Range");
          comp_unit->Verify_version();
        }
      }
      else comp_unit->Find_lr_shrink_cand();

      if (WOPT_Enable_Load_PRE) {
        SET_OPT_PHASE("Load PRE");
	comp_unit->Htable()->Verify_var_phi_hash();
	comp_unit->Do_load_pre(WOPT_Enable_Const_PRE /*do_consts*/,
			       !WOPT_Enable_Lpre_Before_Ivr /*do_loads*/);

        if (Get_Trace(TP_GLOBOPT, CR_DUMP_FLAG)) {
          fprintf(TFile, "%sAfter Load PRE\n%s", DBar, DBar);
          comp_unit->Htable()->Print(TFile);
        }

#ifdef Is_True_On  
        SET_OPT_PHASE("Verify CODEMAP");

        if (Get_Trace(TKIND_INFO, TINFO_TIME)) 
          SET_OPT_PHASE("Skip verify CODEMAP because timing trace is on");
        else
          Is_True(comp_unit->Verify_CODEMAP(), ("CODEMAP corrupted."));
#endif // Is_True_On
        if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
          SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
        } else {
          SET_OPT_PHASE("Verify Live-Range");
          comp_unit->Verify_version();
        }
      }

      if (WOPT_Enable_Store_PRE && !WOPT_Enable_Spre_Before_Ivr) {
        SET_OPT_PHASE("Store PRE");
	comp_unit->Htable()->Verify_var_phi_hash();
        comp_unit->Do_store_pre();

        if (Get_Trace(TP_GLOBOPT, CR_DUMP_FLAG)) {
          fprintf(TFile, "%sAfter Store PRE\n%s", DBar, DBar);
          comp_unit->Htable()->Print(TFile);
        }

#ifdef Is_True_On  
        SET_OPT_PHASE("Verify CODEMAP");

        if (Get_Trace(TKIND_INFO, TINFO_TIME)) 
          SET_OPT_PHASE("Skip verify CODEMAP because timing trace is on");
        else {
          Is_True(comp_unit->Verify_CODEMAP(), ("CODEMAP corrupted."));
	  comp_unit->Htable()->Verify_hashing();
	}
#endif // Is_True_On
        if (Get_Trace(TKIND_INFO, TINFO_TIME)) {
          SET_OPT_PHASE("Skip verify Live-Range because timing trace is on");
        } else {
          SET_OPT_PHASE("Verify Live-Range");
          comp_unit->Verify_version();
        }
      }

      if (WOPT_Enable_Bitwise_DCE) {
        SET_OPT_PHASE("Bitwise DCE");
        comp_unit->Do_bitwise_dce(TRUE /* copy propatage on */);
      }

      if (WOPT_Enable_RVI) {
	// Hacky invocation of new PRE RVI hooks for testing. TODO:
	// Clean this up.
	SET_OPT_PHASE("RVI hooks for SSA PRE");
	comp_unit->
	  Set_pre_rvi_hooks(CXX_NEW(PRE_RVI_HOOKS(comp_unit->Opt_stab(),
						  comp_unit->Cfg(),
						  &Opt_local_pool,
						  Get_Trace(TP_GLOBOPT,
							    EPRE_DUMP_FLAG)),
				    &Opt_local_pool));
#if 0
	// Screen out the variables with multiple signess from RVI
	comp_unit->Opt_stab()->Screen_rvi_candidates();
#endif
      }

      // create RVI instance before emitting anything
      RVI rvi(WOPT_Enable_RVI, comp_unit->Opt_stab(), 
	      WOPT_Enable_RVI ? comp_unit->Pre_rvi_hooks()->Nbits() : 0,
	      alias_mgr );

      Is_True(comp_unit->Verify_IR(comp_unit->Cfg(),comp_unit->Htable(),6),
              ("Verify CFG wrong after creating RVI instance"));

      if (Get_Trace(TP_GLOBOPT, ENABLE_STAT)) {
      	comp_unit->Collect_statistics();
      }

      SET_OPT_PHASE("MainOpt emitter");

      if ( comp_unit->Cfg()->Feedback() )
	comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
					      "before MainOpt emitter" );
      if (comp_unit->Cfg()->Feedback() &&
	  comp_unit->Cfg()->Feedback()->Trace())
	comp_unit->Cfg()->Feedback()->Print( TFile );

      opt_wn = comp_unit->Emit_ML_WHIRL(&rvi);
      if (Cur_PU_Feedback)
	Cur_PU_Feedback->Reset_Root_WN(opt_wn);

      Is_True(REGION_consistency_check(opt_wn),(""));
      Is_True(Verify_alias(alias_mgr,opt_wn),(""));

#if !defined(TARG_IA32) && !defined(TARG_X8664)
      if ( WOPT_Enable_RVI ) {
        SET_OPT_PHASE("RVI");
        opt_wn = rvi.Perform_RVI( opt_wn, alias_mgr );
	if (Cur_PU_Feedback)
	  Cur_PU_Feedback->Reset_Root_WN(opt_wn);
        Is_True(REGION_consistency_check(opt_wn),(""));
        Is_True(Verify_alias(alias_mgr,opt_wn),(""));
      }
#endif

      // free up optimizer's pools
      // NOTE that the rvi phase uses its own
      CXX_DELETE(comp_unit, &Opt_global_pool);
      Opt_memory_terminate_pools();

    }

  } /* if ( phase == MAINOPT_PHASE ) */
  else { 
    SET_OPT_PHASE("Emitter");

    if ( comp_unit->Cfg()->Feedback() )
      comp_unit->Cfg()->Feedback()->Verify( comp_unit->Cfg(),
					    "before emitter" );

    if (This_preopt_renumbers_pregs(phase)) {
      comp_unit->Emitter()->Preg_renumbering_map().Init();
    }
    opt_wn = comp_unit->Emitter()->Emit(comp_unit, du_mgr, alias_mgr);
    if (Cur_PU_Feedback)
      Cur_PU_Feedback->Reset_Root_WN(opt_wn);

    // *****************************************************************
    //    Invoke IPA summary phase
    //      access to comp_unit->Emitter()
    //      and du_mgr.
    // *****************************************************************

    if (Run_ipl) {
      Set_Error_Phase ( "IPA Summary" );
      WB_IPL_Save(); 
      WB_IPL_Initialize(opt_wn, du_mgr, alias_mgr);
      Perform_Procedure_Summary_Phase (opt_wn, du_mgr, alias_mgr,
				       comp_unit->Emitter());
      WB_IPL_Terminate();
      WB_IPL_Restore(); 
    }

    // If we are running preopt for LNO (usually this will be -O3) and
    // we aren't going to run IPA, we re-run alias classification now
    // that we've had the opportunity to renumber PREGs. We don't
    // re-run alias classification here in the IPA case because
    // renumbering will have taken place in IPL's preopt so we
    // (probably?) don't benefit (much?) from redoing it. This second
    // pass of alias classification will (hopefully) let LNO see
    // better (and sometimes far better) alias information, especially
    // for malloc()'ed arrays and other constructs that whose alias
    // behavior was hazy because of the front end's reuse of PREGs.

    if (phase == PREOPT_LNO_PHASE &&
	This_preopt_renumbers_pregs(phase) &&
	WOPT_Enable_Second_Alias_Class &&
	!REGION_has_black_regions(comp_unit->Rid())) {
      SET_OPT_PHASE("Repeat alias classification for LNO");
      alias_mgr->Forget_alias_class_info();
      OPT_POOL_Initialize(&alias_class_pool, "Alias classification pool",
			  FALSE, MEM_DUMP_FLAG+20);
      ALIAS_CLASSIFICATION ac(comp_unit->Opt_stab(),
			      AC_DESTINATION_ALIAS_MANAGER,
			      &alias_class_pool);
      ac.Classify_memops(opt_wn);
      // Now transfer the new alias class information into the alias
      // manager's array of POINTS_TO's, cloning where needed to
      // distinguish things that weren't distinguished before.
      alias_mgr->Transfer_alias_class_to_alias_manager(ac, opt_wn);
      ac.Release_resources();
    }

    if (This_preopt_renumbers_pregs(phase)) {
      Set_PU_Info_flags(Current_PU_Info, PU_PREGS_RENUMBERED);
    }

    CXX_DELETE(comp_unit, &Opt_global_pool);
    Opt_memory_terminate_pools();

    if (WN_opcode(opt_wn) == OPC_FUNC_ENTRY)
      Verify_SYMTAB (CURRENT_SYMTAB);
  }

  /* opt_wn now has result, set the RID level */
  RID *rid = REGION_get_rid(opt_wn);
  Is_True(rid != NULL, ("Pre_Optimizer, NULL RID after processing"));
  RID_level(rid) = RID_preopt_level(phase);

  SET_OPT_PHASE("Finalize");

  REPORT_STATISTICS();

  if (phase == MAINOPT_PHASE &&
      Current_Dep_Graph != NULL && Get_Trace(TP_LNOPT, 1)) {
    /* Trace LNO graph for CG again, since WN addresses have changed */
    fprintf(TFile, "%sLNO dep graph for CG, after WOPT\n%s", DBar, DBar);
    Current_Dep_Graph->Print(TFile);
    fprintf(TFile, "%s", DBar);
  }

  Is_True(REGION_consistency_check(opt_wn),(""));

  if (Get_Trace( TP_GLOBOPT, ALIAS_DUMP_FLAG)){
    Dump_alias_mgr(alias_mgr, opt_wn, TFile);
  }

  disable_tree_freq_display();  // disable WHIRL tree frequency display

  WN_verifier(opt_wn);

  if (WN_opcode(opt_wn) == OPC_FUNC_ENTRY)
    Set_PU_Info_tree_ptr (Current_PU_Info, opt_wn);
  return opt_wn;
}
