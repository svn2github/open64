/* Generated by gen_s_set  */
/* Generated from ../../common/util/x_set_interface Rev 1.1.1.1 */


/* ====================================================================
 * ====================================================================
 *
 *  This package implements sets of TN*'s.  These can be
 *  manipulated with a fairly complete repertoire of set functions.
 *  The sets are represented with bit strings for efficiency of both
 *  space and run time.  The vector that represents these sets is
 *  grown as necessary to accommodate the results of the various
 *  operations.  In spite of this, the client of the package retains
 *  control over storage allocation by providing memory allocation
 *  pools (MEM_POOLs).  The representations are never automatically
 *  trimmed, so that the representation of any given bit set will be
 *  large enough to hold the element with the greatest number that it
 *  ever held.
 *
 *
 *  Destructive Operations Conventions
 *  ==================================
 *
 *  This package contains a number of functions that implement
 *  destructive operations.  The purpose of these operations is
 *  efficiency both of the operations themselves and of memory usage.
 *  Some of the destructive operations may still need to expand the
 *  storage allocated to the set.  When this happens, the set may need
 *  to be copied.  Thus you can not count on the side effects of these
 *  operations, only on the correctness of their returned values.
 *  Functions in this package that can have a destructive effect on a
 *  one of their arguments always have a name that ends with the
 *  letter D.  Only the first argument of such functions is ever
 *  destructively modified.  All destructive operations return a
 *  pointer to the set.  In the normal case this will be the same as
 *  their first argument, but sometimes the set will have to be copied
 *  in order to perform the operation.  So the client should not rely
 *  on the side effects of destructive operations.  Instead, one
 *  should use their returned values.  For now, destructive operations
 *  only expand storage, and never shrink it.
 *
 *
 *  Storage Allocation
 *  ==================
 *
 *  The client of this package has full control over storage
 *  allocation for TN_SET's.  This is achieved by passing storage
 *  allocation pools (MEM_POOLs) to the functions that may need to use
 *  them.  All storage allocated for a set is "flat", which is to say
 *  that from the point of view of storage allocation, each BS may be
 *  seen as a single array containing no pointers to additional
 *  storage.  This allows the client to free this storage directly if
 *  its allocation pool supports freeing (See the discussion under
 *  BS_Create below).
 *
 *
 *  Types
 *  =====
 *
 *
 *  TYPE struct tn_set TN_SET
 *
 *      This is the client visible type of a set of TN* objects.
 *      It has no client visible fields.
 *
 *
 *  TYPE TN*
 *
 *      This is the type of an element of a TN_SET.  It can be mapped
 *      to a numeric type with the range 0..BS_ELT_MAX by the function
 *      TN_number.  Numbers can be mapped to TN*'s with the
 *      function TNvec.  It is a requirement of this mapping that
 *      TNvec(-1) == TN_SET_CHOOSE_FAILURE.
 *
 *
 *  Creation, Clearing, and Freeing
 *  ===============================
 *
 *
 *  TN_SET *TN_SET_Create(
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *
 *      Creates and returns a new TN_SET capable of holding (without
 *      expansion) any set of TN*'s with TN_number values in
 *      the range 0 through size - 1.  'Size' must be nonnegative or
 *      an error is caused.  The newly created TN_SET is
 *      uninitialized, and may contain any of the possible sets.
 *      'Pool' is used to allocate the space for the set.  Storage for
 *      the space is "flat", that is the set is allocated as a single
 *      array and contains no pointers to any additionally allocated
 *      memory.  The client is thus free to free the TN_SET directly
 *      (if 'pool' supports this.)  (the allocated size may be
 *      obtained from TN_SET_AllocSize).
 *
 *
 *  size_t TN_SET_Size_Alloc_Size(
 *    size_t    size
 *  )
 *
 *      Returns the number of bytes which would be required to
 *      allocate a set of 'size' size, i.e., the minimum number of
 *      bytes required to hold a set containing the elements that map
 *      to 0 through size - 1.
 *
 *
 *  size_t TN_SET_Alloc_Size(
 *    TN_SET *set
 *  )
 *
 *      Returns the number of bytes used to allocate the 'set'.
 *
 *
 *  TN_SET *TN_SET_ClearD(
 *    TN_SET *set
 *  )
 *
 *      Destructive clear operation.  After this 'set' will be empty.
 *      However, this does not change the allocated size of the set
 *      (it will still be able to contain the same members that it
 *      could before it was cleared without expansion.)
 *
 *
 *  TN_SET *TN_SET_Create_Empty(
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *
 *      Create an empty set large enough to hold the TN* whose
 *      TN_number value is 'size' - 1 without expansion.  Equivalent
 *      to TN_SET_ClearD( TN_SET_Create( size ), pool )
 *
 *
 *  TN_SET *TN_SET_Range(
 *    BS_ELT      low,
 *    BS_ELT      high,
 *    MEM_POOL   *pool
 *  )
 *  TN_SET *TN_SET_RangeD(
 *    TN_SET     *set,
 *    BS_ELT      low,
 *    BS_ELT      high,
 *    MEM_POOL   *pool
 *  )
 *
 *      Returns a set whose members are the TNvec values of the
 *      numbers 'low' ... 'high'.  Both 'low' and the size of the
 *      range must be nonnegative or an error is caused.  I.e., 'low'
 *      >= 0 and ('high' - 'low' + 1) >= 0.  Note that 'high' may be
 *      -1 if 'low' is 0.
 *
 *
 *  TN_SET *TN_SET_Singleton(
 *    TN* element,
 *    MEM_POOL   *pool
 *  )
 *  TN_SET *TN_SET_SingletonD(
 *    TN_SET     *set,
 *    TN* element,
 *    MEM_POOL   *pool
 *  )
 *
 *      Returns a set with 'element' as its sole member.
 *
 *
 *  TN_SET *TN_SET_Universe(
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *  TN_SET *TN_SET_UniverseD(
 *    TN_SET   *set,
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *
 *      Returns a set containing the TNvec values of the numbers
 *      0...'size' - 1.  'Size' must be nonnegative or an error is
 *      caused.
 *
 *
 *
 *  Copying
 *  =======
 *
 *
 *  TN_SET *TN_SET_Copy(
 *    TN_SET   *set,
 *    MEM_POOL *pool
 *  )
 *  TN_SET *TN_SET_CopyD(
 *    TN_SET   *set1,
 *    TN_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *
 *      Returns an exact copy of set.  Note that for BS_CopyD, if
 *      storage is allocated it will be the same as the storage
 *      actually allocated to set2, regardless of the current size of
 *      set2.  Thus the following sequence:
 *
 *          TN_SET *set1, set2;
 *          set1 = TN_SET_Create( 32, pool );
 *          set2 = TN_SET_Create( 1024, pool );
 *          set2 = TN_SET_ClearD( set2 );
 *          set1 = TN_SET_CopyD( set1, set2, pool );
 *
 *      will result in set1 being grown to be large enough to contain
 *      the TN* whose TN_number value is 1023, even though it
 *      will be empty.
 *
 *
 *  Set Operations
 *  ==============
 *
 *
 *  TN* TN_SET_Choose(
 *    TN_SET *set
 *  )
 *
 *      Returns some element of 'set', if 'set' is nonempty.  Else
 *      returns TN_SET_CHOOSE_FAILURE.  In fact, this is defined so
 *      that it always returns the least element of the set.
 *
 *
 *  TN* TN_SET_Choose_Next(
 *    TN_SET     *set,
 *    TN* x
 *  )
 *
 *      Returns the "next" element of 'set', starting after 'x', if
 *	'set' is nonempty.  Else returns TN_SET_CHOOSE_FAILURE.
 *	This is used for looping over the elements of a set.
 *
 *
 *  TN* TN_SET_Choose_Range(
 *    TN_SET   *set,
 *    BS_ELT    low,
 *    BS_ELT    high
 *  )
 *
 *      Returns some element of 'set' whose TN_number value is in the
 *      range low..high if there is one.  Else returns
 *      TN_SET_CHOOSE_FAILURE.  Both 'low' and the size of the range
 *	must be nonnegative or an error is caused.  I.e., 'low' >= 0 and
 *      ('high' - 'low' + 1) >= 0.  Note that 'high' may be -1 if
 *      'low' is 0.  As with the _Choose function, always returns the
 *      last element of the set that's in range.
 *
 *
 *  CONST TN* TN_SET_CHOOSE_FAILURE
 *
 *      A special value that TN_SET_Choose and TN_SET_ChooseRange
 *      return when they are unable to choose an element.
 *
 *
 *  TN_SET *TN_SET_Difference(
 *    TN_SET   *set1,
 *    TN_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *  TN_SET *TN_SET_DifferenceD(
 *    TN_SET *set1,
 *    TN_SET *set2
 *  )
 *
 *      Returns { x : member( x, 'set1' ) & ~ member( x, 'set2' ) }.
 *
 *
 *  TN_SET *TN_SET_Difference1(
 *    TN_SET     *set,
 *    TN* x,
 *    MEM_POOL   *pool
 *  )
 *  TN_SET *TN_SET_Difference1D(
 *    TN_SET     *set,
 *    TN* x
 *  )
 *
 *      Returns { y : member( y , set ) & ~ ( y = x ) }.  X must be
 *      nonnegative or an error is caused.
 *
 *
 *  TN_SET *TN_SET_Intersection(
 *    TN_SET   *set1,
 *    TN_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *  TN_SET *TN_SET_IntersectionD(
 *    TN_SET *set1,
 *    TN_SET *set2
 *  )
 *
 *      Returns the intersection of 'set1' and 'set2'.
 *
 *
 *  size_t TN_SET_Size(
 *    TN_SET *set
 *  )
 *
 *
 *  TN_SET *TN_SET_Union(
 *    TN_SET   *set1,
 *    TN_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *  TN_SET *TN_SET_UnionD(
 *    TN_SET   *set1,
 *    TN_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *
 *      Returns the union of set1 and set2.
 *
 *
 *  TN_SET *TN_SET_Union1(
 *    TN_SET     *set,
 *    TN* x,
 *    MEM_POOL   *pool
 *  )
 *  TN_SET *TN_SET_Union1D(
 *    TN_SET     *set,
 *    TN* x,
 *    MEM_POOL   *pool
 *  )
 *
 *      Returns set union { x }.  X must be nonnegative or an error is
 *      caused.
 *
 *
 *  TN_SET *TN_SET_UnionD_Intersection(
 *      TN_SET    *set1,
 *      TN_SET    *set2,
 *      TN_SET    *set3,
 *      MEM_POOL   *pool
 *  )
 *
 *      Returns set1 | (set2 & set3).
 *      
 *
 *  Testing Sets
 *  ============
 *
 *
 *  BOOL TN_SET_ContainsP(
 *    TN_SET *set1,
 *    TN_SET *set2
 *  )
 *
 *      Returns TRUE iff every element of 'set2' is in 'set1'.  Else
 *      FALSE.
 *
 *
 *  BOOL TN_SET_EmptyP(
 *    TN_SET *set
 *  )
 *
 *      Returns TRUE iff 'set' is empty.  Else FALSE.
 *
 *
 *  BOOL TN_SET_EqualP(
 *    TN_SET *set1,
 *    TN_SET *set2
 *  )
 *
 *      Returns TRUE iff 'set1' has exactly the same members as
 *      'set2'.  Else FALSE.
 *
 *
 *  BOOL TN_SET_IntersectsP(
 *    TN_SET *set1,
 *    TN_SET *set2
 *  )
 *
 *      Returns TRUE iff 'set1' and 'set2' have at least one member in
 *      common.  Else FALSE.
 *
 *
 *  BOOL TN_SET_MemberP(
 *    TN_SET     *set,
 *    TN* x
 *  )
 * 
 *      Returns TRUE iff 'x' is a member of 'set'.  Else FALSE.  'X'
 *      must be nonnegative or an error is caused.
 *
 *
 *
 *  Looping Over Members
 *  ====================
 *
 *
 *  This is done using TN_SET_Choose and TN_SET_Choose_Next.  Here is an
 *  example:
 *
 *	TN* x;
 *
 *	for ( x = TN_SET_Choose( set );
 *	      x != TN_SET_CHOOSE_FAILURE;
 *            x = TN_SET_Choose_Next( set, x )
 *      ) {
 *        x is a member of the set
 *      }
 *
 *
 *  FOR_ALL_TN_SET_members(set,x)
 *
 *      This macro can be used instead of the above 'for' loop. It expands
 *      into the same code.
 *
 *  Handling Intersections Effeciently
 *  ===================================
 *
 *
 *  Often, once wants to perform operations on the intersection of two
 *  sets without having to create the intersection.  This can be thought
 *  of as an "operation with a mask".  Anyway, a set of functions is
 *  provided to support this:
 *
 *
 *  BOOL TN_SET_Intersection_MemberP(
 *    TN_SET     *set1,
 *    TN_SET     *set2,
 *    TN* x
 *  )
 *
 *      Returns TRUE iff 'x' is a member of the intersection of 'set1' and
 *      'set2' .  Else FALSE.  'X' must be nonnegative or an error is
 *      caused.
 *
 *
 *  TN* TN_SET_Intersection_Choose(
 *    TN_SET *set1,
 *    TN_SET *set2
 *  )
 *
 *      Returns some element of of the intersection of 'set1' and 'set2',
 *      if the intersection is nonempty.  Else returns
 *      TN_SET_CHOOSE_FAILURE.  In fact, this is defined so that it always
 *      returns the least element of the set.
 *
 *
 *  TN* TN_SET_Intersection_Choose_Next(
 *    TN_SET     *set1,
 *    TN_SET     *set2,
 *    TN* x
 *  )
 *
 *      Returns the "next" element of the intersection of 'set1' and
 *      'set2', starting after 'x', if there is such a member.  Else
 *      returns TN_SET_CHOOSE_FAILURE.  This is very useful for looping
 *	over the elements of a set.
 *
 *
 *  Printing Sets
 *  =============
 *
 *
 *  void TN_SET_Print(
 *    TN_SET *set,
 *    FILE   *f
 *  )
 *
 *      Prints 'set' on 'f'.  The type FILE is as defined in stdio.h.
 *
 * ====================================================================
 * ====================================================================
 */
/* Generated from ../../common/util/x_set_macro.h Rev 1.1 */

#ifndef TN_SET_INCLUDED
#define TN_SET_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif


#include "bitset.h"	/* our clients do not need to know about it */

typedef BS TN_SET;


#define TN_SET_CHOOSE_FAILURE ((TN*)BS_CHOOSE_FAILURE)

/* This macro will maps BS_ELTs to their corresponding base_type elements,
 * allowing for the possibility that TNvec may not be defined on
 * BS_CHOOSE_FAILURE and maintaining the mapping from BS_CHOOSE_FAILURE to
 * TN_SET_CHOOSE_FAILURE.   In other words:
 *
 *      TN_SET_bs_elt_bas_type(x) ==>
 *              TN_SET_CHOOSE_FAILURE if x == BS_CHOOSE_FAILURE
 *              TNvec(x)          otherwise
 *
 * The complexity arises from the possibility that x may be an expression,
 * instead of a simple variable.  In that case we can't evaluate it twice,
 * since it may have side effects or be expensive to evaluate.  So we'll
 * assign it to a file scoped static and select the result depending on
 * whether it's a choose failure.  Not so great, huh?
 *
 * TODO: Allow an optional straightforward implementation for mappings that
 * map BS_CHOOSE_FAILURE to TN_SET_CHOOSE_FAILURE.
 */
inline TN*
TN_SET_bs_elt_base_type( BS_ELT x )
{
  if ( x == BS_CHOOSE_FAILURE )
    return TN_SET_CHOOSE_FAILURE;
  else
    return TNvec(x);
}


/* A subuniverse version as well. */

#define TN_SET_Create BS_Create
#define TN_SET_Size_Alloc_Size BS_Size_Alloc_Size
#define TN_SET_Alloc_Size BS_Alloc_Size
#define TN_SET_ClearD BS_ClearD
#define TN_SET_Create_Empty BS_Create_Empty
#define TN_SET_Range BS_Range
#define TN_SET_RangeD BS_RangeD

#define TN_SET_Singleton(e,p)                                           \
    BS_Singleton(TN_number(e),(p))


#define TN_SET_SingletonD(s,e,p)                                        \
    BS_SingletonD((s),TN_number(e),(p))


#define TN_SET_Universe BS_Universe
#define TN_SET_UniverseD BS_UniverseD
#define TN_SET_Copy BS_Copy
#define TN_SET_CopyD BS_CopyD

#define TN_SET_Choose(x)                                                \
  TN_SET_bs_elt_base_type(BS_Choose(x))

#define TN_SET_ChooseS(x,s)                                             \
  TN_SET_bs_elt_base_type_sub(BS_Choose(x),s)

#define TN_SET_Intersection_Choose(x1,x2)                               \
  TN_SET_bs_elt_base_type(BS_Intersection_Choose((x1),(x2)))

#define TN_SET_Intersection_ChooseS(x1,x2,s)                            \
  TN_SET_bs_elt_base_type_sub(BS_Intersection_Choose((x1),(x2)),(s))

#define TN_SET_Choose_Next(x,e)                                         \
  TN_SET_bs_elt_base_type(BS_Choose_Next((x),TN_number(e)))


#define TN_SET_Intersection_Choose_Next(x1,x2,e)                        \
  TN_SET_bs_elt_base_type(BS_Intersection_Choose_Next((x1),(x2),TN_number(e)))


#define TN_SET_Choose_Range(x,l,h)                                      \
  TN_SET_bs_elt_base_type(BS_Choose_Range((x),(l),(h)))

#define TN_SET_Choose_RangeS(x,l,h,s)                                   \
  TN_SET_bs_elt_base_type_sub(BS_Choose_Range((x),(l),(h)),(s))

#define TN_SET_Difference BS_Difference
#define TN_SET_DifferenceD BS_DifferenceD

#define TN_SET_Difference1(s,e,p)                                       \
    BS_Difference1(s,TN_number(e),(p))


#define TN_SET_Difference1D(s,e)                                        \
    BS_Difference1D(s,TN_number(e))


#define TN_SET_Intersection BS_Intersection
#define TN_SET_IntersectionD BS_IntersectionD
#define TN_SET_Size BS_Size
#define TN_SET_Union BS_Union
#define TN_SET_UnionD BS_UnionD

#define TN_SET_Union1(s,x,p)                                            \
    BS_Union1((s),TN_number(x),(p))

#define TN_SET_UnionD_Intersection(s1,s2,s3,p)                          \
    BS_UnionD_Intersection((s1),(s2),(s3),(p))


#define TN_SET_Union1D(s,x,p)                                           \
    BS_Union1D((s),TN_number(x),(p))


#define TN_SET_ContainsP BS_ContainsP
#define TN_SET_EmptyP BS_EmptyP
#define TN_SET_EqualP BS_EqualP
#define TN_SET_IntersectsP BS_IntersectsP

#define TN_SET_MemberP(set,x) BS_MemberP((set),TN_number(x))


#define TN_SET_Intersection_MemberP(set1,set2,x)                        \
    BS_Intersection_MemberP((set1),(set2),TN_number(x))


#define TN_SET_Print BS_Print

#define FOR_ALL_TN_SET_members(set,x)	\
    for (x = TN_SET_Choose(set);	\
	 x != TN_SET_CHOOSE_FAILURE;	\
	 x = TN_SET_Choose_Next(set,x))

#ifdef __cplusplus
}
#endif
#endif /* TN_SET_INCLUDED */
