/* Generated by gen_s_set  */
/* Generated from ../../common/util/x_set_interface Rev 1.1.1.1 */


/* ====================================================================
 * ====================================================================
 *
 *  This package implements sets of LRANGE*'s.  These can be
 *  manipulated with a fairly complete repertoire of set functions.
 *  The sets are represented with bit strings for efficiency of both
 *  space and run time.  The vector that represents these sets is
 *  grown as necessary to accommodate the results of the various
 *  operations.  In spite of this, the client of the package retains
 *  control over storage allocation by providing memory allocation
 *  pools (MEM_POOLs).  The representations are never automatically
 *  trimmed, so that the representation of any given bit set will be
 *  large enough to hold the element with the greatest number that it
 *  ever held.
 *
 *
 *  Destructive Operations Conventions
 *  ==================================
 *
 *  This package contains a number of functions that implement
 *  destructive operations.  The purpose of these operations is
 *  efficiency both of the operations themselves and of memory usage.
 *  Some of the destructive operations may still need to expand the
 *  storage allocated to the set.  When this happens, the set may need
 *  to be copied.  Thus you can not count on the side effects of these
 *  operations, only on the correctness of their returned values.
 *  Functions in this package that can have a destructive effect on a
 *  one of their arguments always have a name that ends with the
 *  letter D.  Only the first argument of such functions is ever
 *  destructively modified.  All destructive operations return a
 *  pointer to the set.  In the normal case this will be the same as
 *  their first argument, but sometimes the set will have to be copied
 *  in order to perform the operation.  So the client should not rely
 *  on the side effects of destructive operations.  Instead, one
 *  should use their returned values.  For now, destructive operations
 *  only expand storage, and never shrink it.
 *
 *
 *  Storage Allocation
 *  ==================
 *
 *  The client of this package has full control over storage
 *  allocation for LRANGE_SET's.  This is achieved by passing storage
 *  allocation pools (MEM_POOLs) to the functions that may need to use
 *  them.  All storage allocated for a set is "flat", which is to say
 *  that from the point of view of storage allocation, each BS may be
 *  seen as a single array containing no pointers to additional
 *  storage.  This allows the client to free this storage directly if
 *  its allocation pool supports freeing (See the discussion under
 *  BS_Create below).
 *
 *
 *  Subuniverses
 *  ============
 *
 *  Sometimes it is desirable to have sets over one or more
 *  subuniverses.  For example, we may want to have sets only over
 *  those TNs that are global or which are referenced in a particular
 *  block.  The advantage is that the bit numbering space may be much
 *  denser once it is relativized this way.
 *
 *  Every function that relies on the elt<->num mapping also has a from
 *  that is relativized to a subuniverse.  The names of these functions
 *  all end in "S" and take a "LRANGE_SET_SUBUNIVERSE*" (see below) as
 *  a final argument.
 *
 *
 *  Types
 *  =====
 *
 *
 *  TYPE struct lrange_set LRANGE_SET
 *
 *      This is the client visible type of a set of LRANGE* objects.
 *      It has no client visible fields.
 *
 *
 *  TYPE LRANGE*
 *
 *      This is the type of an element of a LRANGE_SET.  It can be mapped
 *      to a numeric type with the range 0..BS_ELT_MAX by the function
 *      LRANGE_INT.  Numbers can be mapped to LRANGE*'s with the
 *      function INT_LRANGE.  It is a requirement of this mapping that
 *      INT_LRANGE(-1) == LRANGE_SET_CHOOSE_FAILURE.
 *
 *
 *  class LRANGE_SET_SUBUNIVERSE
 *
 *      This is a client defined type that defines a subuniverse mapping.
 *      The client must also have supplied subuniverse relative mapping
 *      functions: LRANGE_Universe_ID_S and INT_LRANGE_Sub just like LRANGE_INT and
 *      INT_LRANGE, respectively, except they take a second argument that
 *      specifies the subuniverse as a LRANGE_SET_SUBUNIVERSE*.
 *
 *      
 *  Creation, Clearing, and Freeing
 *  ===============================
 *
 *
 *  LRANGE_SET *LRANGE_SET_Create(
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *
 *      Creates and returns a new LRANGE_SET capable of holding (without
 *      expansion) any set of LRANGE*'s with LRANGE_INT values in
 *      the range 0 through size - 1.  'Size' must be nonnegative or
 *      an error is caused.  The newly created LRANGE_SET is
 *      uninitialized, and may contain any of the possible sets.
 *      'Pool' is used to allocate the space for the set.  Storage for
 *      the space is "flat", that is the set is allocated as a single
 *      array and contains no pointers to any additionally allocated
 *      memory.  The client is thus free to free the LRANGE_SET directly
 *      (if 'pool' supports this.)  (the allocated size may be
 *      obtained from LRANGE_SET_AllocSize).
 *
 *
 *  size_t LRANGE_SET_Size_Alloc_Size(
 *    size_t    size
 *  )
 *
 *      Returns the number of bytes which would be required to
 *      allocate a set of 'size' size, i.e., the minimum number of
 *      bytes required to hold a set containing the elements that map
 *      to 0 through size - 1.
 *
 *
 *  size_t LRANGE_SET_Alloc_Size(
 *    LRANGE_SET *set
 *  )
 *
 *      Returns the number of bytes used to allocate the 'set'.
 *
 *
 *  LRANGE_SET *LRANGE_SET_ClearD(
 *    LRANGE_SET *set
 *  )
 *
 *      Destructive clear operation.  After this 'set' will be empty.
 *      However, this does not change the allocated size of the set
 *      (it will still be able to contain the same members that it
 *      could before it was cleared without expansion.)
 *
 *
 *  LRANGE_SET *LRANGE_SET_Create_Empty(
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *
 *      Create an empty set large enough to hold the LRANGE* whose
 *      LRANGE_INT value is 'size' - 1 without expansion.  Equivalent
 *      to LRANGE_SET_ClearD( LRANGE_SET_Create( size ), pool )
 *
 *
 *  LRANGE_SET *LRANGE_SET_Range(
 *    BS_ELT      low,
 *    BS_ELT      high,
 *    MEM_POOL   *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_RangeD(
 *    LRANGE_SET     *set,
 *    BS_ELT      low,
 *    BS_ELT      high,
 *    MEM_POOL   *pool
 *  )
 *
 *      Returns a set whose members are the INT_LRANGE values of the
 *      numbers 'low' ... 'high'.  Both 'low' and the size of the
 *      range must be nonnegative or an error is caused.  I.e., 'low'
 *      >= 0 and ('high' - 'low' + 1) >= 0.  Note that 'high' may be
 *      -1 if 'low' is 0.
 *
 *
 *  LRANGE_SET *LRANGE_SET_Singleton(
 *    LRANGE* element,
 *    MEM_POOL   *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_SingletonS(
 *    LRANGE* element,
 *    MEM_POOL   *pool,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *  LRANGE_SET *LRANGE_SET_SingletonD(
 *    LRANGE_SET     *set,
 *    LRANGE* element,
 *    MEM_POOL   *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_SingletonDS(
 *    LRANGE_SET     *set,
 *    LRANGE* element,
 *    MEM_POOL   *pool,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns a set with 'element' as its sole member.
 *
 *
 *  LRANGE_SET *LRANGE_SET_Universe(
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_UniverseD(
 *    LRANGE_SET   *set,
 *    size_t    size,
 *    MEM_POOL *pool
 *  )
 *
 *      Returns a set containing the INT_LRANGE values of the numbers
 *      0...'size' - 1.  'Size' must be nonnegative or an error is
 *      caused.
 *
 *
 *
 *  Copying
 *  =======
 *
 *
 *  LRANGE_SET *LRANGE_SET_Copy(
 *    LRANGE_SET   *set,
 *    MEM_POOL *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_CopyD(
 *    LRANGE_SET   *set1,
 *    LRANGE_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *
 *      Returns an exact copy of set.  Note that for BS_CopyD, if
 *      storage is allocated it will be the same as the storage
 *      actually allocated to set2, regardless of the current size of
 *      set2.  Thus the following sequence:
 *
 *          LRANGE_SET *set1, set2;
 *          set1 = LRANGE_SET_Create( 32, pool );
 *          set2 = LRANGE_SET_Create( 1024, pool );
 *          set2 = LRANGE_SET_ClearD( set2 );
 *          set1 = LRANGE_SET_CopyD( set1, set2, pool );
 *
 *      will result in set1 being grown to be large enough to contain
 *      the LRANGE* whose LRANGE_INT value is 1023, even though it
 *      will be empty.
 *
 *
 *  Set Operations
 *  ==============
 *
 *
 *  LRANGE* LRANGE_SET_Choose(
 *    LRANGE_SET *set
 *  )
 *  LRANGE* LRANGE_SET_ChooseS(
 *    LRANGE_SET *set,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns some element of 'set', if 'set' is nonempty.  Else
 *      returns LRANGE_SET_CHOOSE_FAILURE.  In fact, this is defined so
 *      that it always returns the least element of the set.
 *
 *
 *  LRANGE* LRANGE_SET_Choose_Next(
 *    LRANGE_SET     *set,
 *    LRANGE* x
 *  )
 *  LRANGE* LRANGE_SET_Choose_NextS(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns the "next" element of 'set', starting after 'x', if
 *	'set' is nonempty.  Else returns LRANGE_SET_CHOOSE_FAILURE.
 *	This is used for looping over the elements of a set.
 *
 *
 *  LRANGE* LRANGE_SET_Choose_Range(
 *    LRANGE_SET   *set,
 *    BS_ELT    low,
 *    BS_ELT    high
 *  )
 *  LRANGE* LRANGE_SET_Choose_RangeS(
 *    LRANGE_SET   *set,
 *    BS_ELT    low,
 *    BS_ELT    high,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns some element of 'set' whose LRANGE_INT value is in the
 *      range low..high if there is one.  Else returns
 *      LRANGE_SET_CHOOSE_FAILURE.  Both 'low' and the size of the range
 *	must be nonnegative or an error is caused.  I.e., 'low' >= 0 and
 *      ('high' - 'low' + 1) >= 0.  Note that 'high' may be -1 if
 *      'low' is 0.  As with the _Choose function, always returns the
 *      last element of the set that's in range.
 *
 *
 *  CONST LRANGE* LRANGE_SET_CHOOSE_FAILURE
 *
 *      A special value that LRANGE_SET_Choose and LRANGE_SET_ChooseRange
 *      return when they are unable to choose an element.
 *
 *
 *  LRANGE_SET *LRANGE_SET_Difference(
 *    LRANGE_SET   *set1,
 *    LRANGE_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_DifferenceD(
 *    LRANGE_SET *set1,
 *    LRANGE_SET *set2
 *  )
 *
 *      Returns { x : member( x, 'set1' ) & ~ member( x, 'set2' ) }.
 *
 *
 *  LRANGE_SET *LRANGE_SET_Difference1(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    MEM_POOL   *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_Difference1D(
 *    LRANGE_SET     *set,
 *    LRANGE* x
 *  )
 *  LRANGE_SET *LRANGE_SET_Difference1S(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    MEM_POOL   *pool,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *  LRANGE_SET *LRANGE_SET_Difference1DS(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns { y : member( y , set ) & ~ ( y = x ) }.  X must be
 *      nonnegative or an error is caused.
 *
 *
 *  LRANGE_SET *LRANGE_SET_Intersection(
 *    LRANGE_SET   *set1,
 *    LRANGE_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_IntersectionD(
 *    LRANGE_SET *set1,
 *    LRANGE_SET *set2
 *  )
 *
 *      Returns the intersection of 'set1' and 'set2'.
 *
 *
 *  size_t LRANGE_SET_Size(
 *    LRANGE_SET *set
 *  )
 *
 *
 *  LRANGE_SET *LRANGE_SET_Union(
 *    LRANGE_SET   *set1,
 *    LRANGE_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_UnionD(
 *    LRANGE_SET   *set1,
 *    LRANGE_SET   *set2,
 *    MEM_POOL *pool
 *  )
 *
 *      Returns the union of set1 and set2.
 *
 *
 *  LRANGE_SET *LRANGE_SET_Union1(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    MEM_POOL   *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_Union1D(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    MEM_POOL   *pool
 *  )
 *  LRANGE_SET *LRANGE_SET_Union1S(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    MEM_POOL   *pool,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *  LRANGE_SET *LRANGE_SET_Union1DS(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    MEM_POOL   *pool,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns set union { x }.  X must be nonnegative or an error is
 *      caused.
 *
 *
 *  LRANGE_SET *LRANGE_SET_UnionD_Intersection(
 *      LRANGE_SET    *set1,
 *      LRANGE_SET    *set2,
 *      LRANGE_SET    *set3,
 *      MEM_POOL   *pool
 *  )
 *
 *      Returns set1 | (set2 & set3).
 *      
 *
 *  Testing Sets
 *  ============
 *
 *
 *  BOOL LRANGE_SET_ContainsP(
 *    LRANGE_SET *set1,
 *    LRANGE_SET *set2
 *  )
 *
 *      Returns TRUE iff every element of 'set2' is in 'set1'.  Else
 *      FALSE.
 *
 *
 *  BOOL LRANGE_SET_EmptyP(
 *    LRANGE_SET *set
 *  )
 *
 *      Returns TRUE iff 'set' is empty.  Else FALSE.
 *
 *
 *  BOOL LRANGE_SET_EqualP(
 *    LRANGE_SET *set1,
 *    LRANGE_SET *set2
 *  )
 *
 *      Returns TRUE iff 'set1' has exactly the same members as
 *      'set2'.  Else FALSE.
 *
 *
 *  BOOL LRANGE_SET_IntersectsP(
 *    LRANGE_SET *set1,
 *    LRANGE_SET *set2
 *  )
 *
 *      Returns TRUE iff 'set1' and 'set2' have at least one member in
 *      common.  Else FALSE.
 *
 *
 *  BOOL LRANGE_SET_MemberP(
 *    LRANGE_SET     *set,
 *    LRANGE* x
 *  )
 *  BOOL LRANGE_SET_MemberPS(
 *    LRANGE_SET     *set,
 *    LRANGE* x,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 * 
 *      Returns TRUE iff 'x' is a member of 'set'.  Else FALSE.  'X'
 *      must be nonnegative or an error is caused.
 *
 *
 *
 *  Looping Over Members
 *  ====================
 *
 *
 *  This is done using LRANGE_SET_Choose and LRANGE_SET_Choose_Next.  Here is an
 *  example:
 *
 *	LRANGE* x;
 *
 *	for ( x = LRANGE_SET_Choose( set );
 *	      x != LRANGE_SET_CHOOSE_FAILURE;
 *            x = LRANGE_SET_Choose_Next( set, x )
 *      ) {
 *        x is a member of the set
 *      }
 *
*   Note that the subuniverse forms are also available.
 *
 *  FOR_ALL_LRANGE_SET_members(set,x)
 *
 *      This macro can be used instead of the above 'for' loop. It expands
 *      into the same code.
 *
 *  Handling Intersections Effeciently
 *  ===================================
 *
 *
 *  Often, once wants to perform operations on the intersection of two
 *  sets without having to create the intersection.  This can be thought
 *  of as an "operation with a mask".  Anyway, a set of functions is
 *  provided to support this:
 *
 *
 *  BOOL LRANGE_SET_Intersection_MemberP(
 *    LRANGE_SET     *set1,
 *    LRANGE_SET     *set2,
 *    LRANGE* x
 *  )
 *  BOOL LRANGE_SET_Intersection_MemberPS(
 *    LRANGE_SET     *set1,
 *    LRANGE_SET     *set2,
 *    LRANGE* x,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns TRUE iff 'x' is a member of the intersection of 'set1' and
 *      'set2' .  Else FALSE.  'X' must be nonnegative or an error is
 *      caused.
 *
 *
 *  LRANGE* LRANGE_SET_Intersection_Choose(
 *    LRANGE_SET *set1,
 *    LRANGE_SET *set2
 *  )
 *  LRANGE* LRANGE_SET_Intersection_ChooseS(
 *    LRANGE_SET *set1,
 *    LRANGE_SET *set2,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns some element of of the intersection of 'set1' and 'set2',
 *      if the intersection is nonempty.  Else returns
 *      LRANGE_SET_CHOOSE_FAILURE.  In fact, this is defined so that it always
 *      returns the least element of the set.
 *
 *
 *  LRANGE* LRANGE_SET_Intersection_Choose_Next(
 *    LRANGE_SET     *set1,
 *    LRANGE_SET     *set2,
 *    LRANGE* x
 *  )
 *  LRANGE* LRANGE_SET_Intersection_Choose_NextS(
 *    LRANGE_SET     *set1,
 *    LRANGE_SET     *set2,
 *    LRANGE* x,
 *    LRANGE_SET_SUBUNIVERSE *sub
 *  )
 *
 *      Returns the "next" element of the intersection of 'set1' and
 *      'set2', starting after 'x', if there is such a member.  Else
 *      returns LRANGE_SET_CHOOSE_FAILURE.  This is very useful for looping
 *	over the elements of a set.
 *
 *
 *  Printing Sets
 *  =============
 *
 *
 *  void LRANGE_SET_Print(
 *    LRANGE_SET *set,
 *    FILE   *f
 *  )
 *
 *      Prints 'set' on 'f'.  The type FILE is as defined in stdio.h.
 *
 * ====================================================================
 * ====================================================================
 */
/* Generated from ../../common/util/x_set_macro.h Rev 1.1 */

#ifndef LRANGE_SET_INCLUDED
#define LRANGE_SET_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif


#include "bitset.h"	/* our clients do not need to know about it */

typedef BS LRANGE_SET;

class LRANGE_SET_SUBUNIVERSE;

#define LRANGE_SET_CHOOSE_FAILURE ((LRANGE*)BS_CHOOSE_FAILURE)

/* This macro will maps BS_ELTs to their corresponding base_type elements,
 * allowing for the possibility that INT_LRANGE may not be defined on
 * BS_CHOOSE_FAILURE and maintaining the mapping from BS_CHOOSE_FAILURE to
 * LRANGE_SET_CHOOSE_FAILURE.   In other words:
 *
 *      LRANGE_SET_bs_elt_bas_type(x) ==>
 *              LRANGE_SET_CHOOSE_FAILURE if x == BS_CHOOSE_FAILURE
 *              INT_LRANGE(x)          otherwise
 *
 * The complexity arises from the possibility that x may be an expression,
 * instead of a simple variable.  In that case we can't evaluate it twice,
 * since it may have side effects or be expensive to evaluate.  So we'll
 * assign it to a file scoped static and select the result depending on
 * whether it's a choose failure.  Not so great, huh?
 *
 * TODO: Allow an optional straightforward implementation for mappings that
 * map BS_CHOOSE_FAILURE to LRANGE_SET_CHOOSE_FAILURE.
 */
inline LRANGE*
LRANGE_SET_bs_elt_base_type( BS_ELT x )
{
  if ( x == BS_CHOOSE_FAILURE )
    return LRANGE_SET_CHOOSE_FAILURE;
  else
    return INT_LRANGE(x);
}


/* A subuniverse version as well. */
inline LRANGE*
LRANGE_SET_bs_elt_base_type_sub( BS_ELT x, LRANGE_SET_SUBUNIVERSE* sub )
{
  if ( x == BS_CHOOSE_FAILURE )
    return LRANGE_SET_CHOOSE_FAILURE;
  else
    return INT_LRANGE_Sub(x,sub);
}

#define LRANGE_SET_Create BS_Create
#define LRANGE_SET_Size_Alloc_Size BS_Size_Alloc_Size
#define LRANGE_SET_Alloc_Size BS_Alloc_Size
#define LRANGE_SET_ClearD BS_ClearD
#define LRANGE_SET_Create_Empty BS_Create_Empty
#define LRANGE_SET_Range BS_Range
#define LRANGE_SET_RangeD BS_RangeD

#define LRANGE_SET_Singleton(e,p)                                           \
    BS_Singleton(LRANGE_INT(e),(p))

#define LRANGE_SET_SingletonS(e,p,s)                                        \
    BS_Singleton(LRANGE_Universe_ID_S((e),(s)),(p))

#define LRANGE_SET_SingletonD(s,e,p)                                        \
    BS_SingletonD((s),LRANGE_INT(e),(p))

#define LRANGE_SET_SingletonDS(s,e,p,sub)                                   \
    BS_SingletonD((s),LRANGE_Universe_ID_S((e),(sub)),(p))

#define LRANGE_SET_Universe BS_Universe
#define LRANGE_SET_UniverseD BS_UniverseD
#define LRANGE_SET_Copy BS_Copy
#define LRANGE_SET_CopyD BS_CopyD

#define LRANGE_SET_Choose(x)                                                \
  LRANGE_SET_bs_elt_base_type(BS_Choose(x))

#define LRANGE_SET_ChooseS(x,s)                                             \
  LRANGE_SET_bs_elt_base_type_sub(BS_Choose(x),s)

#define LRANGE_SET_Intersection_Choose(x1,x2)                               \
  LRANGE_SET_bs_elt_base_type(BS_Intersection_Choose((x1),(x2)))

#define LRANGE_SET_Intersection_ChooseS(x1,x2,s)                            \
  LRANGE_SET_bs_elt_base_type_sub(BS_Intersection_Choose((x1),(x2)),(s))

#define LRANGE_SET_Choose_Next(x,e)                                         \
  LRANGE_SET_bs_elt_base_type(BS_Choose_Next((x),LRANGE_INT(e)))

/* Needs to evaluate "sub" twice, so it has to be a function:
 */
extern LRANGE* LRANGE_SET_Choose_NextS(
  LRANGE_SET*,
  LRANGE*,
  LRANGE_SET_SUBUNIVERSE*
);

#define LRANGE_SET_Intersection_Choose_Next(x1,x2,e)                        \
  LRANGE_SET_bs_elt_base_type(BS_Intersection_Choose_Next((x1),(x2),LRANGE_INT(e)))

/* Needs to evaluate "sub" twice, so it has to be a function:
 */
extern LRANGE* LRANGE_SET_Intersection_Choose_NextS(
  LRANGE_SET*,
  LRANGE_SET*,
  LRANGE*,
  LRANGE_SET_SUBUNIVERSE*
);

#define LRANGE_SET_Choose_Range(x,l,h)                                      \
  LRANGE_SET_bs_elt_base_type(BS_Choose_Range((x),(l),(h)))

#define LRANGE_SET_Choose_RangeS(x,l,h,s)                                   \
  LRANGE_SET_bs_elt_base_type_sub(BS_Choose_Range((x),(l),(h)),(s))

#define LRANGE_SET_Difference BS_Difference
#define LRANGE_SET_DifferenceD BS_DifferenceD

#define LRANGE_SET_Difference1(s,e,p)                                       \
    BS_Difference1(s,LRANGE_INT(e),(p))

#define LRANGE_SET_Difference1S(s,e,p,sub)                                  \
    BS_Difference1(s,LRANGE_Universe_ID_S((e),(sub)),(p))

#define LRANGE_SET_Difference1D(s,e)                                        \
    BS_Difference1D(s,LRANGE_INT(e))

#define LRANGE_SET_Difference1DS(s,e,sub)                                   \
    BS_Difference1D(s,LRANGE_Universe_ID_S((e),(sub)))

#define LRANGE_SET_Intersection BS_Intersection
#define LRANGE_SET_IntersectionD BS_IntersectionD
#define LRANGE_SET_Size BS_Size
#define LRANGE_SET_Union BS_Union
#define LRANGE_SET_UnionD BS_UnionD

#define LRANGE_SET_Union1(s,x,p)                                            \
    BS_Union1((s),LRANGE_INT(x),(p))

#define LRANGE_SET_UnionD_Intersection(s1,s2,s3,p)                          \
    BS_UnionD_Intersection((s1),(s2),(s3),(p))

#define LRANGE_SET_Union1S(s,x,p,sub)                                       \
    BS_Union1((s),LRANGE_Universe_ID_S((x),(sub)),(p))

#define LRANGE_SET_Union1D(s,x,p)                                           \
    BS_Union1D((s),LRANGE_INT(x),(p))

#define LRANGE_SET_Union1DS(s,x,p,sub)                                      \
    BS_Union1D((s),LRANGE_Universe_ID_S((x),(sub)),(p))

#define LRANGE_SET_ContainsP BS_ContainsP
#define LRANGE_SET_EmptyP BS_EmptyP
#define LRANGE_SET_EqualP BS_EqualP
#define LRANGE_SET_IntersectsP BS_IntersectsP

#define LRANGE_SET_MemberP(set,x) BS_MemberP((set),LRANGE_INT(x))

#define LRANGE_SET_MemberPS(set,x,s) BS_MemberP((set),LRANGE_Universe_ID_S((x),(s)))

#define LRANGE_SET_Intersection_MemberP(set1,set2,x)                        \
    BS_Intersection_MemberP((set1),(set2),LRANGE_INT(x))

#define LRANGE_SET_Intersection_MemberPS(set1,set2,x,s)                     \
    BS_Intersection_MemberP((set1),(set2),LRANGE_Universe_ID_S((x),(s)))

#define LRANGE_SET_Print BS_Print

#define FOR_ALL_LRANGE_SET_members(set,x)	\
    for (x = LRANGE_SET_Choose(set);	\
	 x != LRANGE_SET_CHOOSE_FAILURE;	\
	 x = LRANGE_SET_Choose_Next(set,x))

#ifdef __cplusplus
}
#endif
#endif /* LRANGE_SET_INCLUDED */
