%{
#include "olive_convert_wn.h"
%}

%term I4INTCONST
%term I4ABS
%term I4NEG
%term I4ADD
%term I4SUB
%term I4MPY
%term I4HIGHMPY
%term I4DIV
%term I4REM
%term I4MOD

%term U4INTCONST
%term U4NEG
%term U4ADD
%term U4SUB
%term U4MPY
%term U4HIGHMPY
%term U4DIV
%term U4REM
%term U4MOD

%term BINTCONST
%term BLNOT
%term BLAND
%term BLIOR

%term I4LNOT
%term I4LIOR
%term I4LAND
%term I4BIOR
%term I4BNOT
%term I4BAND
%term I4BXOR
%term I4BNOR

%term U4BNOT
%term U4BIOR
%term U4BAND
%term U4BXOR
%term U4BNOR

%term BBEQ
%term BBNE

%term BI4LT
%term BI4LE
%term BI4EQ
%term BI4NE
%term BI4GE
%term BI4GT

%term I4I4LT
%term I4I4LE
%term I4I4EQ
%term I4I4NE
%term I4I4GE
%term I4I4GT

%term U4I4LT
%term U4I4LE
%term U4I4EQ
%term U4I4NE
%term U4I4GE
%term U4I4GT

%term I4MAX
%term I4MIN

%term I4SHL
%term I4ASHR
%term I4LSHR

%term BU4LT
%term BU4LE
%term BU4EQ
%term BU4NE
%term BU4GE
%term BU4GT

%term I4U4LT
%term I4U4LE
%term I4U4EQ
%term I4U4NE
%term I4U4GE
%term I4U4GT

%term U4U4LT
%term U4U4LE
%term U4U4EQ
%term U4U4NE
%term U4U4GE
%term U4U4GT

%term U4MAX
%term U4MIN

%term U4SHL
%term U4ASHR
%term U4LSHR

%term F4CONST
%term F4ADD
%term F4SUB
%term F4MPY
%term F4DIV
%term F4MADD
%term F4NMADD
%term F4MSUB
%term F4NMSUB
%term F4NEG
%term F4ABS
%term F4RECIP
%term F4SQRT
%term F4RSQRT

%term F8CONST
%term F8ADD
%term F8SUB
%term F8MPY
%term F8DIV
%term F8MADD
%term F8NMADD
%term F8MSUB
%term F8NMSUB
%term F8NEG
%term F8ABS
%term F8RECIP
%term F8SQRT
%term F8RSQRT

%term BF4LT
%term BF4LE
%term BF4EQ
%term BF4NE
%term BF4GE
%term BF4GT

%term I4F4LT
%term I4F4LE
%term I4F4EQ
%term I4F4NE
%term I4F4GE
%term I4F4GT

%term U4F4LT
%term U4F4LE
%term U4F4EQ
%term U4F4NE
%term U4F4GE
%term U4F4GT

%term F4MAX
%term F4MIN

%term BF8LT
%term BF8LE
%term BF8EQ
%term BF8NE
%term BF8GE
%term BF8GT

%term I4F8LT
%term I4F8LE
%term I4F8EQ
%term I4F8NE
%term I4F8GE
%term I4F8GT

%term U4F8LT
%term U4F8LE
%term U4F8EQ
%term U4F8NE
%term U4F8GE
%term U4F8GT

%term F8MAX
%term F8MIN

%term I1STID
%term I2STID
%term U1STID
%term U2STID

%term I4I1LDID
%term I4I2LDID
%term I4I4LDID
%term I4I8LDID
%term I4BSLDID

%term I4STID

%term U4U1LDID
%term U4U2LDID
%term U4U4LDID
%term U4U8LDID
%term U4BSLDID

%term U4STID

%term F4F4LDID
%term F4STID

%term F8F8LDID
%term F8STID

%term I4BCVT
%term I4U4CVT
%term I4F4CVT
%term I4F8CVT

%term I4F4RND
%term I4F4TRUNC
%term I4F4CEIL
%term I4F4FLOOR

%term I4F8RND
%term I4F8TRUNC
%term I4F8CEIL
%term I4F8FLOOR

%term U4BCVT
%term U4I4CVT
%term U4F4CVT
%term U4F8CVT

%term U4F4RND
%term U4F4TRUNC
%term U4F4CEIL
%term U4F4FLOOR

%term U4F8RND
%term U4F8TRUNC
%term U4F8CEIL
%term U4F8FLOOR

%term F4I4CVT
%term F4U4CVT
%term F4F8CVT

%term F8I4CVT
%term F8U4CVT
%term F8F4CVT

%term I8I1LDID
%term I8I2LDID
%term I8I4LDID
%term I8I8LDID
%term I8BSLDID

%term I8STID

%term U8U1LDID
%term U8U2LDID
%term U8U4LDID
%term U8U8LDID
%term U8BSLDID

%term U8STID

%term I8INTCONST
%term I8ABS
%term I8NEG
%term I8ADD
%term I8SUB
%term I8MPY
%term I8HIGHMPY
%term I8DIV
%term I8REM
%term I8MOD

%term U8INTCONST
%term U8NEG
%term U8ADD
%term U8SUB
%term U8MPY
%term U8HIGHMPY
%term U8DIV
%term U8REM
%term U8MOD

%term I8BIOR
%term I8BNOT
%term I8BAND
%term I8BXOR
%term I8BNOR

%term U8BNOT
%term U8BIOR
%term U8BAND
%term U8BXOR
%term U8BNOR

%term BI8LT
%term BI8LE
%term BI8EQ
%term BI8NE
%term BI8GE
%term BI8GT

%term I4I8LT
%term I4I8LE
%term I4I8EQ
%term I4I8NE
%term I4I8GE
%term I4I8GT

%term U4I8LT
%term U4I8LE
%term U4I8EQ
%term U4I8NE
%term U4I8GE
%term U4I8GT

%term I8I8LT
%term I8I8LE
%term I8I8EQ
%term I8I8NE
%term I8I8GE
%term I8I8GT

%term U8I8LT
%term U8I8LE
%term U8I8EQ
%term U8I8NE
%term U8I8GE
%term U8I8GT

%term I8MAX
%term I8MIN

%term BU8LT
%term BU8LE
%term BU8EQ
%term BU8NE
%term BU8GE
%term BU8GT

%term I4U8LT
%term I4U8LE
%term I4U8EQ
%term I4U8NE
%term I4U8GE
%term I4U8GT

%term U4U8LT
%term U4U8LE
%term U4U8EQ
%term U4U8NE
%term U4U8GE
%term U4U8GT

%term I8U8LT
%term I8U8LE
%term I8U8EQ
%term I8U8NE
%term I8U8GE
%term I8U8GT

%term U8U8LT
%term U8U8LE
%term U8U8EQ
%term U8U8NE
%term U8U8GE
%term U8U8GT

%term U8MAX
%term U8MIN

%term I8I4LT
%term I8I4LE
%term I8I4EQ
%term I8I4NE
%term I8I4GE
%term I8I4GT

%term U8I4LT
%term U8I4LE
%term U8I4EQ
%term U8I4NE
%term U8I4GE
%term U8I4GT

%term I8U4LT
%term I8U4LE
%term I8U4EQ
%term I8U4NE
%term I8U4GE
%term I8U4GT

%term U8U4LT
%term U8U4LE
%term U8U4EQ
%term U8U4NE
%term U8U4GE
%term U8U4GT

%term I8SHL
%term I8ASHR
%term I8LSHR

%term U8SHL
%term U8ASHR
%term U8LSHR

%term I8F4LT
%term I8F4LE
%term I8F4EQ
%term I8F4NE
%term I8F4GE
%term I8F4GT

%term U8F4LT
%term U8F4LE
%term U8F4EQ
%term U8F4NE
%term U8F4GE
%term U8F4GT

%term I8F8LT
%term I8F8LE
%term I8F8EQ
%term I8F8NE
%term I8F8GE
%term I8F8GT

%term U8F8LT
%term U8F8LE
%term U8F8EQ
%term U8F8NE
%term U8F8GE
%term U8F8GT

%term I4I8CVT
%term U4U8CVT
%term I8I4CVT
%term U8U4CVT
%term I8U8CVT
%term U8I8CVT

%term I4CVTL
%term I8CVTL
%term U4CVTL
%term U8CVTL

%term F8U8CVT
%term F4U8CVT

%term I4PARM
%term U4PARM
%term I8PARM
%term U8PARM
%term F4PARM
%term F8PARM

%term CALL


%declare<void> expr<pOPS ops>;
%declare<void> null<pOPS ops>;
%declare<void> reg<pOPS ops>;
%declare<void> simm16<pOPS ops>;
%declare<void> uimm16<pOPS ops>;
%declare<void> f4reg<pOPS ops>;
%declare<void> f8reg<pOPS ops>;
%declare<void> reg64<pOPS ops>;

%%

expr    : reg
        {
            $cost[0].cost = $cost[1].cost;
        }
        = {
            $action[1](ops);
        };

expr    : null
        {
            $cost[0].cost = $cost[1].cost;
        }    
        = {
            $action[1](ops);
        };

expr    : f4reg
        {
            $cost[0].cost = $cost[1].cost;
        }    
        = {
            $action[1](ops);
        };

expr    : f8reg
        {
            $cost[0].cost = $cost[1].cost;
        }    
        = {
            $action[1](ops);
        };

expr    : reg64
        {
            $cost[0].cost = $cost[1].cost;
        }    
        = {
            $action[1](ops);
        };

expr    : simm16
        {
            $cost[0].cost = 0;
        }
        = {
            $0->result = Gen_Literal_TN(WN_const_val($1->wn),  4);
        };

expr    : uimm16
        {
            $cost[0].cost = 0;
        }
        = {
            $0->result = Gen_Literal_TN(WN_const_val($1->wn), 4);
        };

expr    : I8INTCONST, U8INTCONST
        {
            $cost[0].cost = 0;
        }
        = {
            /* let upper functions handle the literals */
	     /* the TN_Map only support Register TN, so we can't separate it here */
            $0->result = Gen_Literal_TN(WN_const_val($1->wn), 8);
        };


simm16  : I4INTCONST
        {
            CHECK(IN_RANGE(WN_const_val($1->wn), SIMM16));
            $cost[0].cost = 0;
        }
        = {
            $0 = $1;
        };

uimm16  : U4INTCONST
        {
            CHECK(IN_RANGE(WN_const_val($1->wn), UIMM16));
            $cost[0].cost = 0;
        }
        = {
            $0 = $1;
        };



reg     : I4ABS(reg)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            TN* tmp_tn1 = Build_TN_Of_Mtype(MTYPE_I4);
            Build_OP(TOP_srawi, tmp_tn1, $2->result, Gen_Literal_TN(31, 4), ops);
            TN* tmp_tn2 = Build_TN_Of_Mtype(MTYPE_I4);
            Build_OP(TOP_xor, tmp_tn2, tmp_tn1, $2->result, ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_subf, $0->result, tmp_tn1, tmp_tn2, ops);
        };

reg     : I4NEG(reg), U4NEG(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_neg, $0->result, $2->result, ops);
        };




reg     : I4ADD(reg, reg), U4ADD(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_add, $0->result, $2->result, $3->result, ops);
        };

reg     : I4ADD(reg, I4INTCONST), U4ADD(reg, U4INTCONST)
        {
            if (IN_RANGE(WN_const_val($3->wn), SIMM16))
                $cost[0].cost = 1 + $cost[2].cost;
            else
                $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Add_Imm($0->result, $2->result, WN_const_val($3->wn), ops);
        };

reg     : I4SUB(reg, reg), U4SUB(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_subf, $0->result, $3->result, $2->result, ops);
        };
        
reg     : I4SUB(I4INTCONST, reg), U4SUB(U4INTCONST, reg)
        {
            CHECK(IN_RANGE(WN_const_val($2->wn), SIMM16));
            $cost[0].cost = 1 + $cost[3].cost;
        }
        = {
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_subfic, $0->result, $3->result, Gen_Literal_TN(WN_const_val($2->wn), 4), ops);
        };

reg     : I4MPY(reg, I4INTCONST), U4MPY(reg, U4INTCONST)
        {
            CHECK(IN_RANGE(WN_const_val($3->wn), SIMM16));
            $cost[0].cost = 3 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_mulli, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : I4MPY(reg, reg), U4MPY(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_mullw, $0->result, $2->result, $3->result, ops);
        };

reg     : I4HIGHMPY(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_mulhw, $0->result, $2->result, $3->result, ops);
        };

reg     : I4DIV(reg, reg)
        {
            $cost[0].cost = 23 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_divw, $0->result, $2->result, $3->result, ops);
        };

reg     : I4REM(reg, reg)
        {
            $cost[0].cost = 28 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_divw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_mullw, $0->result, $0->result, $3->result, ops);
            Build_OP(TOP_subf, $0->result, $0->result, $2->result, ops);
        };

reg     : I4MOD(reg, reg)
        {
            $cost[0].cost = 33 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_divw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_mullw, $0->result, $0->result, $3->result, ops);
            Build_OP(TOP_subf, $0->result, $0->result, $2->result, ops);
            TN* tmp_tn = Build_TN_Of_Mtype(MTYPE_I4);
            Build_OP(TOP_xor, tmp_tn, $2->result, $3->result, ops);
            Build_OP(TOP_neg, tmp_tn, tmp_tn, ops);
            Build_OP(TOP_srawi, tmp_tn, tmp_tn, Gen_Literal_TN(31, 4), ops);
            Build_OP(TOP_and, tmp_tn, tmp_tn, $3->result, ops);
            Build_OP(TOP_add, $0->result, $0->result, tmp_tn, ops);
        };



reg     : U4SUB(reg, U4INTCONST)
        {
            if (IN_RANGE(WN_const_val($3->wn), SIMM16))
                $cost[0].cost = 1 + $cost[2].cost;
            else
                $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            //treat as signed
            Handle_Add_Imm($0->result, $2->result, -WN_const_val($3->wn), ops);
        };

reg     : U4HIGHMPY(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_mulhwu, $0->result, $2->result, $3->result, ops);
        };

reg     : U4DIV(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_divwu, $0->result, $2->result, $3->result, ops);
        };

reg     : U4REM(reg, reg), U4MOD(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));  
            Build_OP(TOP_divwu, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_mullw, $0->result, $0->result, $3->result, ops);
            Build_OP(TOP_subf, $0->result, $0->result, $2->result, ops);
        };



reg     : I4I1LDID
        {
            $cost[0].cost = 2;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Load($0->wn, $0->result, TOP_lbz, ops);
            // lbz will not extend the sign bit, we need to do it ourselves
            Build_OP(TOP_extsb, $0->result, $0->result, ops);
        };

reg     : I4I2LDID
        {
            $cost[0].cost = 2;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Load($0->wn, $0->result, TOP_lha, ops);
        };

reg     : I4I4LDID, U4U4LDID
        {
            $cost[0].cost = 2;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Load($0->wn, $0->result, TOP_lwz, ops);
        };

null    : I1STID(reg), U1STID(reg), I1STID(reg64), U1STID(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            Handle_Store($0->wn, $2->result, TOP_stb, ops);            
        };

null    : I2STID(reg), U2STID(reg), I2STID(reg64), U2STID(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            Handle_Store($0->wn, $2->result, TOP_sth, ops);            
        };

null    : I4STID(reg), U4STID(reg), I4STID(reg64), U4STID(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            Handle_Store($0->wn, $2->result, TOP_stw, ops);            
        };


reg     : I4INTCONST
        {
            CHECK(IN_RANGE(WN_const_val($1->wn), SIMM16));
            $cost[0].cost = 1;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_li, $0->result, Gen_Literal_TN(WN_const_val($1->wn), 4), ops);
        };

reg     : I4INTCONST, U4INTCONST
        {
            $cost[0].cost = 2;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Imm32($0->result, WN_const_val($1->wn), ops);
        };

reg     : U4INTCONST
        {
            // li will extend the sign bit, so it can not work for uimm16 larger than 32767
            CHECK(IN_RANGE(WN_const_val($1->wn), UIMM16A));
            $cost[0].cost = 1;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_li, $0->result, Gen_Literal_TN(WN_const_val($1->wn), 4), ops);
        };

reg     : U4U1LDID
        {
            $cost[0].cost = 2;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Load($0->wn, $0->result, TOP_lbz, ops);
        };

reg     : U4U2LDID
        {
            $cost[0].cost = 2;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Load($0->wn, $0->result, TOP_lhz, ops);                      
        };



reg     : BLNOT(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_subfic, $0->result, $2->result, Gen_Literal_TN(1, 4), ops);
        };

reg     : BLAND(reg, BINTCONST)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_andi_, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BLAND(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_and, $0->result, $2->result, $3->result, ops);
        };

reg     : BLIOR(reg, BINTCONST)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_ori, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BLIOR(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_or, $0->result, $2->result, $3->result, ops);
        };

reg     : I4BNOT(reg), U4BNOT(reg), I4LNOT(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_nand, $0->result, $2->result, $2->result, ops);
        };

reg     : I4BAND(reg, I4INTCONST), U4BAND(reg, U4INTCONST), I4LAND(reg, I4INTCONST)
        {
            INT64 imm = WN_const_val($3->wn);
            if (IN_RANGE(imm, UIMM16))
                $cost[0].cost = 1 + $cost[2].cost;
            else
            {
                unsigned short low = (unsigned short)imm;
                unsigned short high = (unsigned short)(imm >> 16);
		  if (low == 0)
		  {
		      $cost[0].cost = 2 + $cost[2].cost;
		  }
		  else
		  	return 0;
            }
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Logic_Imm(TOP_andi_, TOP_andis_, $0->result, $2->result, WN_const_val($3->wn), ops);
        };

reg     : I4BAND(reg, reg), U4BAND(reg, reg), I4LAND(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_and, $0->result, $2->result, $3->result, ops);
        };

reg     : I4BIOR(reg, I4INTCONST), U4BIOR(reg, U4INTCONST), I4LIOR(reg, I4INTCONST)
        {
            INT64 imm = WN_const_val($3->wn);
            if (IN_RANGE(imm, UIMM16))
                $cost[0].cost = 1 + $cost[2].cost;
            else
            {
                unsigned short low = (unsigned short)imm;
                unsigned short high = (unsigned short)(imm >> 16);
		  if (low == 0)
		  {
		      $cost[0].cost = 2 + $cost[2].cost;
		  }
		  else
		  	return 0;
            }
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Logic_Imm(TOP_ori, TOP_oris, $0->result, $2->result, WN_const_val($3->wn), ops);
        };

reg     : I4BIOR(reg, reg), U4BIOR(reg, reg), I4LIOR(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_or, $0->result, $2->result, $3->result, ops);
        };

reg     : I4BXOR(reg, I4INTCONST), U4BXOR(reg, U4INTCONST)
        {
            INT64 imm = WN_const_val($3->wn);
            if (IN_RANGE(imm, UIMM16))
                $cost[0].cost = 1 + $cost[2].cost;
            else
            {
                unsigned short low = (unsigned short)imm;
                unsigned short high = (unsigned short)(imm >> 16);
		  if (low == 0)
		  {
		      $cost[0].cost = 2 + $cost[2].cost;
		  }
		  else
		  	return 0;
            }
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Logic_Imm(TOP_xori, TOP_xoris, $0->result, $2->result, WN_const_val($3->wn), ops);
        };

reg     : I4BXOR(reg, reg), U4BXOR(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_xor, $0->result, $2->result, $3->result, ops);
        };

reg     : I4BNOR(reg, reg), U4BNOR(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_nor, $0->result, $2->result, $3->result, ops);
        };

reg     : I4BNOT(I4BAND(reg, reg)), U4BNOT(U4BAND(reg, reg))
        {
            $cost[0].cost = 1 + $cost[3].cost + $cost[4].cost;
        }
        = {
            $action[3](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_nand, $0->result, $3->result, $4->result, ops);
        };

reg     : I4BNOT(I4BIOR(reg, reg)), U4BNOT(U4BIOR(reg, reg))
        {
            $cost[0].cost = 1 + $cost[3].cost + $cost[4].cost;
        }
        = {
            $action[3](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_nor, $0->result, $3->result, $4->result, ops);
        };

reg     : I4BNOT(I4BXOR(reg, reg)), U4BNOT(U4BXOR(reg, reg))
        {
            $cost[0].cost = 1 + $cost[3].cost + $cost[4].cost;
        }
        = {
            $action[3](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_eqv, $0->result, $3->result, $4->result, ops);
        };

reg     : I4BAND(reg, I4BNOT(reg)), U4BAND(reg, U4BNOT(reg))
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[4].cost;
        }
        = {
            $action[2](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_andc, $0->result, $2->result, $4->result, ops);
        };

reg     : I4BIOR(reg, I4BNOT(reg)), U4BIOR(reg, U4BNOT(reg))
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[4].cost;
        }
        = {
            $action[2](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_orc, $0->result, $2->result, $4->result, ops);
        };



reg     : BBEQ(reg, BINTCONST)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_xori, $0->result, $2->result, Gen_Literal_TN(1 - WN_const_val($3->wn), 4), ops);
        };

reg     : BBEQ(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_eqv, $0->result, $2->result, $3->result, ops);
        };

reg     : BBNE(reg, BINTCONST)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_xori, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BBNE(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_xor, $0->result, $2->result, $3->result, ops);
        };



reg     : BI4LT(reg, simm16), I4I4LT(reg, simm16), U4I4LT(reg, simm16)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LT, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BI4LT(reg, reg), I4I4LT(reg, reg), U4I4LT(reg, reg)
        {
            $cost[0].cost = 3 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LT, TOP_cmpw, $0->result, $2->result, $3->result, ops);
        };

reg     : BI4LE(reg, simm16), I4I4LE(reg, simm16), U4I4LE(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LE, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BI4LE(reg, reg), I4I4LE(reg, reg), U4I4LE(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LE, TOP_cmpw, $0->result, $2->result, $3->result, ops);
        };

reg     : BI4EQ(reg, simm16), I4I4EQ(reg, simm16), U4I4EQ(reg, simm16)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BI4EQ(reg, reg), I4I4EQ(reg, reg), U4I4EQ(reg, reg)
        {
            $cost[0].cost = 3 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmpw, $0->result, $2->result, $3->result, ops);
        };

reg     : BI4NE(reg, simm16), I4I4NE(reg, simm16), U4I4NE(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_NE, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BI4NE(reg, reg), I4I4NE(reg, reg), U4I4NE(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_NE, TOP_cmpw, $0->result, $2->result, $3->result, ops);
        };

reg     : BI4GE(reg, simm16), I4I4GE(reg, simm16), U4I4GE(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GE, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BI4GE(reg, reg), I4I4GE(reg, reg), U4I4GE(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GE, TOP_cmpw, $0->result, $2->result, $3->result, ops);
        };

reg     : BI4GT(reg, simm16), I4I4GT(reg, simm16), U4I4GT(reg, simm16)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GT, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BI4GT(reg, reg), I4I4GT(reg, reg), U4I4GT(reg, reg)
        {
            $cost[0].cost = 3 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GT, TOP_cmpw, $0->result, $2->result, $3->result, ops);
        };



reg     : I4MAX(reg, reg)
        {
            $cost[0].cost = 6 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Int(true, $0->result, $2->result, $3->result, ops);
        };

reg     : I4MIN(reg, reg)
        {
            $cost[0].cost = 6 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Int(false, $0->result, $2->result, $3->result, ops);
        };



reg     : I4SHL(reg, reg), U4SHL(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_slw, $0->result, $2->result, $3->result, ops);
        };

reg     : I4ASHR(reg, I4INTCONST)
        {
            CHECK(IN_RANGE(WN_const_val($3->wn), 0, 31));
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_srawi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : I4ASHR(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_sraw, $0->result, $2->result, $3->result, ops);
        };

reg     : I4LSHR(reg, reg), U4LSHR(reg, reg), U4ASHR(reg, reg)
        {
            $cost[0].cost = 1 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_srw, $0->result, $2->result, $3->result, ops);
        };



reg     : BU4LT(reg, uimm16), I4U4LT(reg, uimm16), U4U4LT(reg, uimm16)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LT, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BU4LT(reg, reg), I4U4LT(reg, reg), U4U4LT(reg, reg)
        {
            $cost[0].cost = 3 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LT, TOP_cmplw, $0->result, $2->result, $3->result, ops);
        };

reg     : BU4LE(reg, uimm16), I4U4LE(reg, uimm16), U4U4LE(reg, uimm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LE, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BU4LE(reg, reg), I4U4LE(reg, reg), U4U4LE(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_LE, TOP_cmplw, $0->result, $2->result, $3->result, ops);
        };

reg     : BU4EQ(reg, uimm16), I4U4EQ(reg, uimm16), U4U4EQ(reg, uimm16)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BU4EQ(reg, reg), I4U4EQ(reg, reg), U4U4EQ(reg, reg)
        {
            $cost[0].cost = 3 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmplw, $0->result, $2->result, $3->result, ops);
        };

reg     : BU4NE(reg, uimm16), I4U4NE(reg, uimm16), U4U4NE(reg, uimm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_NE, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BU4NE(reg, reg), I4U4NE(reg, reg), U4U4NE(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_NE, TOP_cmplw, $0->result, $2->result, $3->result, ops);
        };

reg     : BU4GE(reg, uimm16), I4U4GE(reg, uimm16), U4U4GE(reg, uimm16)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GE, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BU4GE(reg, reg), I4U4GE(reg, reg), U4U4GE(reg, reg)
        {
            $cost[0].cost = $cost[2].cost + $cost[3].cost + 3;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GE, TOP_cmplw, $0->result, $2->result, $3->result, ops);
        };

reg     : BU4GT(reg, uimm16), I4U4GT(reg, uimm16), U4U4GT(reg, uimm16)
        {
            $cost[0].cost = $cost[2].cost + $cost[3].cost + 3;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GT, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
        };

reg     : BU4GT(reg, reg), I4U4GT(reg, reg), U4U4GT(reg, reg)
        {
            $cost[0].cost = $cost[2].cost + $cost[3].cost + 3;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Int(OPR_GT, TOP_cmplw, $0->result, $2->result, $3->result, ops);
        };



reg     : U4MAX(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Uint(true, $0->result, $2->result, $3->result, ops);
        };

reg     : U4MIN(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Uint(false, $0->result, $2->result, $3->result, ops);
        };



f4reg    : F4CONST
        {            
            $cost[0].cost = 4;
        }
        = {
            ST * base_sym;
            INT64 base_ofst;
            TN * base_tn;
            TN * ofst_tn;
            
            ST * sym   = WN_st($0->wn);
            INT64 ofst = WN_store_offset($0->wn);
        
            Allocate_Object(sym);         /* make sure sym is allocated */
            Base_Symbol_And_Offset_For_Addressing(sym, ofst, &base_sym, &base_ofst);
                        
            base_tn = Build_TN_Of_Mtype(Pointer_Mtype);
            Build_OP(TOP_lis, base_tn, Gen_Symbol_TN(base_sym, base_ofst, TN_RELOC_HIGH16), ops);
            ofst_tn = Gen_Symbol_TN(base_sym, base_ofst, TN_RELOC_LOW16);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_lfs, $0->result, base_tn, ofst_tn, ops);
        };

f4reg   : F4ADD(f4reg, f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fadds, $0->result, $2->result, $3->result, ops);
        };

f4reg   : F4SUB(f4reg, f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fsubs, $0->result, $2->result, $3->result, ops);
        };

f4reg   : F4MPY(f4reg, f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fmuls, $0->result, $2->result, $3->result, ops);
        };

f4reg   : F4DIV(f4reg, f4reg)
        {
            $cost[0].cost = 21 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fdivs, $0->result, $2->result, $3->result, ops);
        };

f4reg   : F4MADD(f4reg, f4reg, f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
                $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fmadds, $0->result, $2->result, $3->result, $4->result, ops);
        };

f4reg   : F4NMADD(f4reg, f4reg, f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
                $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmadds, $0->result, $2->result, $3->result, $4->result, ops);
        };

f4reg   : F4NEG(F4MADD(f4reg, f4reg, f4reg))
        {
            $cost[0].cost = 5 + $cost[3].cost + $cost[4].cost + $cost[5].cost;
        }
        = {
                $action[3](ops);
        	  $action[4](ops);
        	  $action[5](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmadds, $0->result, $3->result, $4->result, $5->result, ops);
        };

f4reg    : F4MSUB(f4reg, f4reg, f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
                $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fmsubs, $0->result, $2->result, $3->result, $4->result, ops);
        };

f4reg   : F4NMSUB(f4reg, f4reg, f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
                $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmsubs, $0->result, $2->result, $3->result, $4->result, ops);
        };

f4reg   : F4NEG(F4MSUB(f4reg, f4reg, f4reg))
        {
            $cost[0].cost = 5 + $cost[3].cost + $cost[4].cost + $cost[5].cost;
        }
        = {
                $action[3](ops);
        	  $action[4](ops);
        	  $action[5](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmsubs, $0->result, $3->result, $4->result, $5->result, ops);
        };

f4reg   : F4NEG(f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fneg, $0->result, $2->result, ops);
        };

f4reg   : F4ABS(f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fabs, $0->result, $2->result, ops);
        };

f4reg   : F4NEG(F4ABS(f4reg))
        {
            $cost[0].cost = 5 + $cost[3].cost;
        }
        = {
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fnabs, $0->result, $3->result, ops);
        };



f4reg   : F4F4LDID
        {
            $cost[0].cost = 4;
        }
        = {
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Load($0->wn, $0->result, TOP_lfs, ops);         
        };

null    : F4STID(f4reg)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            Handle_Float_Store($0->wn, $2->result, TOP_stfs, ops);
        };



f8reg   : F8CONST
        {
            $cost[0].cost = 4;
        }
        = {
            ST * base_sym;
            INT64 base_ofst;
            TN * base_tn;
            TN * ofst_tn;
            
            ST * sym   = WN_st($0->wn);
            INT64 ofst = WN_store_offset($0->wn);
        
            Allocate_Object(sym);         /* make sure sym is allocated */
            Base_Symbol_And_Offset_For_Addressing(sym, ofst, &base_sym, &base_ofst);
            
            
            base_tn = Build_TN_Of_Mtype(Pointer_Mtype);
            Build_OP(TOP_lis, base_tn, Gen_Symbol_TN(base_sym, base_ofst, TN_RELOC_HIGH16), ops);
            ofst_tn = Gen_Symbol_TN(base_sym, base_ofst, TN_RELOC_LOW16);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_lfd, $0->result, base_tn, ofst_tn, ops);
        };

f8reg   : F8NEG(f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fneg, $0->result, $2->result, ops);
        };

f8reg   : F8ABS(f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fabs, $0->result, $2->result, ops);
        };

f8reg   : F8NEG(F8ABS(f8reg))
        {
            $cost[0].cost = 5 + $cost[3].cost;
        }
        = {
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fnabs, $0->result, $3->result, ops);
        };

f8reg   : F8ADD(f8reg, f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fadd, $0->result, $2->result, $3->result, ops);
        };

f8reg   : F8SUB(f8reg, f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fsub, $0->result, $2->result, $3->result, ops);
        };

f8reg   : F8MPY(f8reg, f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fmul, $0->result, $2->result, $3->result, ops);
        };

f8reg   : F8DIV(f8reg, f8reg)
        {
            $cost[0].cost = 35 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_fdiv, $0->result, $2->result, $3->result, ops);
        };

f8reg   : F8MADD(f8reg, f8reg, f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
                $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fmadd, $0->result, $2->result, $3->result, $4->result, ops);
        };

f8reg   : F8NMADD(f8reg, f8reg, f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
            $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmadd, $0->result, $2->result, $3->result, $4->result, ops);
        };

f8reg   : F8NEG(F8MADD(f8reg, f8reg, f8reg))
        {
            $cost[0].cost = 5 + $cost[3].cost + $cost[4].cost + $cost[5].cost;
        }
        = {
                $action[3](ops);
        	  $action[4](ops);
        	  $action[5](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmadd, $0->result, $3->result, $4->result, $5->result, ops);
        };

f8reg    : F8MSUB(f8reg, f8reg, f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
                $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fmsub, $0->result, $2->result, $3->result, $4->result, ops);
        };

f8reg   : F8NMSUB(f8reg, f8reg, f8reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost + $cost[4].cost;
        }
        = {
                $action[2](ops);
        	  $action[3](ops);
        	  $action[4](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmsub, $0->result, $2->result, $3->result, $4->result, ops);
        };

f8reg   : F8NEG(F8MSUB(f8reg, f8reg, f8reg))
        {
            $cost[0].cost = 5 + $cost[3].cost + $cost[4].cost + $cost[5].cost;
        }
        = {
                $action[3](ops);
        	  $action[4](ops);
        	  $action[5](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
        	  Build_OP(TOP_fnmsub, $0->result, $3->result, $4->result, $5->result, ops);
        };



f8reg   : F8F8LDID
        {
            $cost[0].cost = 4;
        }
        = {
            TN * base_tn;
            TN * ofst_tn;
            OPS newops;
            OP *op;
            OPS_Init(&newops);
        
            Expand_Load_Address($0->wn, &base_tn, &ofst_tn, &newops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_lfd, $0->result, base_tn, ofst_tn, &newops);
            
            ST * sym   = WN_st($0->wn);
            
            FOR_ALL_OPS_OPs (&newops, op) {
                if (ST_is_constant(sym) && OP_load(op)) {
                    Set_OP_no_alias(op);
                }        
            }
        
            /* Add the new OPs to the end of the list passed in */
            OPS_Append_Ops(ops, &newops);  
        };

null    : F8STID(f8reg)
        {
            $cost[0].cost = 3 + $cost[2].cost;
        }
        = {
            $action[2](ops);

            TN * base_tn;
            TN * ofst_tn;
            OPS newops;
            OPS_Init(&newops);
            
            Expand_Load_Address($0->wn, &base_tn, &ofst_tn, &newops);
            
            Build_OP(TOP_stfd, $2->result, base_tn, ofst_tn, &newops);    
            OPS_Append_Ops(ops, &newops);
            
        };



reg     : BF4LT(f4reg, f4reg), I4F4LT(f4reg, f4reg), U4F4LT(f4reg, f4reg), BF8LT(f8reg, f8reg), I4F8LT(f8reg, f8reg), U4F8LT(f8reg, f8reg)
        {
            $cost[0].cost = 8 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Float(OPR_LT, $0->result, $2->result, $3->result, ops);
        };

reg     : BF4LE(f4reg, f4reg), I4F4LE(f4reg, f4reg), U4F4LE(f4reg, f4reg), BF8LE(f8reg, f8reg), I4F8LE(f8reg, f8reg), U4F8LE(f8reg, f8reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Float(OPR_LE, $0->result, $2->result, $3->result, ops);
        };

reg     : BF4EQ(f4reg, f4reg), I4F4EQ(f4reg, f4reg), U4F4EQ(f4reg, f4reg), BF8EQ(f8reg, f8reg), I4F8EQ(f8reg, f8reg), U4F8EQ(f8reg, f8reg)
        {
            $cost[0].cost = 8 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Float(OPR_EQ, $0->result, $2->result, $3->result, ops);
        };

reg     : BF4NE(f4reg, f4reg), I4F4NE(f4reg, f4reg), U4F4NE(f4reg, f4reg), BF8NE(f8reg, f8reg), I4F8NE(f8reg, f8reg), U4F8NE(f8reg, f8reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Float(OPR_NE, $0->result, $2->result, $3->result, ops);
        };

reg     : BF4GE(f4reg, f4reg), I4F4GE(f4reg, f4reg), U4F4GE(f4reg, f4reg), BF8GE(f8reg, f8reg), I4F8GE(f8reg, f8reg), U4F8GE(f8reg, f8reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Float(OPR_GE, $0->result, $2->result, $3->result, ops);
        };

reg     : BF4GT(f4reg, f4reg), I4F4GT(f4reg, f4reg), U4F4GT(f4reg, f4reg), BF8GT(f8reg, f8reg), I4F8GT(f8reg, f8reg), U4F8GT(f8reg, f8reg)
        {
            $cost[0].cost = 8 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Move_Float(OPR_GT, $0->result, $2->result, $3->result, ops);
        };

f4reg   : F4MAX(f4reg, f4reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Float(true, MTYPE_F4, $0->result, $2->result, $3->result, ops);
        };

f4reg   : F4MIN(f4reg, f4reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Float(false, MTYPE_F4, $0->result, $2->result, $3->result, ops);
        };

f8reg   : F8MAX(f8reg, f8reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Float(true, MTYPE_F8, $0->result, $2->result, $3->result, ops);
        };

f8reg   : F8MIN(f8reg, f8reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_MaxMin_Float(false, MTYPE_F8, $0->result, $2->result, $3->result, ops);
        };




reg     : I4BCVT(reg), I4U4CVT(reg), U4BCVT(reg), U4I4CVT(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = $2->result;
        };

reg     : I4F4RND(f4reg), I4F8RND(f8reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Int_Cvt(RND, WN_rtype($2->wn), $0->result, $2->result, ops);
        };

reg     : I4F4CVT(f4reg), I4F8CVT(f8reg), I4F4TRUNC(f4reg), I4F8TRUNC(f8reg)
        {
            $cost[0].cost = 11 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Int_Cvt(TRUNC, WN_rtype($2->wn), $0->result, $2->result, ops);
        };

reg     : I4F4CEIL(f4reg), I4F8CEIL(f8reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Int_Cvt(CEIL, WN_rtype($2->wn), $0->result, $2->result, ops);
        };

reg     : I4F4FLOOR(f4reg), I4F8FLOOR(f8reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Int_Cvt(FLOOR, WN_rtype($2->wn), $0->result, $2->result, ops);
        };



reg     : U4F4RND(f4reg), U4F8RND(f8reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Uint_Cvt(RND, WN_rtype($2->wn), $0->result, $2->result, ops);
        };

reg     : U4F4CVT(f4reg), U4F8CVT(f8reg), U4F4TRUNC(f4reg), U4F8TRUNC(f8reg)
        {
            $cost[0].cost = 11 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Uint_Cvt(TRUNC, WN_rtype($2->wn), $0->result, $2->result, ops);
        };

reg     : U4F4CEIL(f4reg), U4F8CEIL(f8reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Uint_Cvt(CEIL, WN_rtype($2->wn), $0->result, $2->result, ops);
        };

reg     : U4F4FLOOR(f4reg), U4F8FLOOR(f8reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Float_Uint_Cvt(FLOOR, WN_rtype($2->wn), $0->result, $2->result, ops);
        };



f4reg   : F4I4CVT(reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Int_Float_Cvt($0->result, $2->result, ops, false, false);
        };

f4reg   : F4U4CVT(reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Int_Float_Cvt($0->result, $2->result, ops, true, false);
        };


f4reg   : F4F8CVT(f8reg)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Build_OP(TOP_mtfsb0, Gen_Literal_TN(30, 4), ops);
            Build_OP(TOP_mtfsb1, Gen_Literal_TN(31, 4), ops);
            Build_OP(TOP_frsp, $0->result, $2->result, ops);
        };

f8reg   : F8I4CVT(reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Int_Float_Cvt($0->result, $2->result, ops, false, true);
        };

f8reg   : F8U4CVT(reg)
        {
            $cost[0].cost = 13 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Int_Float_Cvt($0->result, $2->result, ops, true, true);
        };


f8reg   : F8F4CVT(f4reg)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = $2->result;
        };

reg     : I4CVTL(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            INT16 bits = WN_cvtl_bits($0->wn);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            switch (bits)
            {
                case 8:
                    Build_OP(TOP_extsb, $0->result, $2->result, ops);
                    break;
                case 16:
                    Build_OP(TOP_extsh, $0->result, $2->result, ops);
                    break;
                default:
                    FmtAssert(false, ("invalid cvtl bits"));
            }
            
        };

reg     : U4CVTL(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            INT16 bits = WN_cvtl_bits($0->wn);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            switch (bits)
            {
                case 8:
                    Build_OP(TOP_andi_, $0->result, $2->result, Gen_Literal_TN(0xff, 4), ops);
                    break;
                case 16:
                    Build_OP(TOP_andi_, $0->result, $2->result, Gen_Literal_TN(0xffff, 4), ops);
                    break;
                default:
                    FmtAssert(false, ("invalid cvtl bits"));
            }
            
        };

reg64   : I8CVTL(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            INT16 bits = WN_cvtl_bits($0->wn);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            switch (bits)
            {
                case 1:
                    Build_OP(TOP_andi_, $0->result, $2->result, Gen_Literal_TN(1, 4), ops); // do we need to extend sign bits?
                    break;
                case 8:
                    Build_OP(TOP_extsb, $0->result, $2->result, ops);
                    break;
                case 16:
                    Build_OP(TOP_extsh, $0->result, $2->result, ops);
                    break;
                case 32:
                    $0->result = $2->result;
                    break;
                default:
                    FmtAssert(false, ("invalid cvtl bits"));
            }
            Build_OP(TOP_srawi, $0->result_high, $0->result, Gen_Literal_TN(31, 4), ops);
        };

reg64   : U8CVTL(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            INT16 bits = WN_cvtl_bits($0->wn);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
            switch (bits)
            {
                case 1:
                    Build_OP(TOP_andi_, $0->result, $2->result, Gen_Literal_TN(1, 4), ops);
                    break;
                case 8:
                    Build_OP(TOP_andi_, $0->result, $2->result, Gen_Literal_TN(0xff, 4), ops);
                    break;
                case 16:
                    Build_OP(TOP_andi_, $0->result, $2->result, Gen_Literal_TN(0xffff, 4), ops);
                    break;
                case 32:
                    $0->result = $2->result;
                    break;
                default:
                    FmtAssert(false, ("invalid cvtl bits"));
            }
        };

reg     : I4I8CVT(reg64), U4U8CVT(reg64)
        {
            $cost[0].cost = $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = $2->result;
        };

reg64   : I8I4CVT(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_srawi, $0->result_high, $2->result, Gen_Literal_TN(31, 4), ops);
            $0->result = $2->result;
        };

reg64   : U8U4CVT(reg)
        {
            $cost[0].cost = 1 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
            $0->result = $2->result;
        };

reg64   : I8U8CVT(reg64), U8I8CVT(reg64)
        {
            $cost[0].cost = $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = $2->result;
            $0->result_high = $2->result_high;
        };

f4reg   : F4U8CVT(reg64)
        {
            $cost[0].cost = 10 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_F4);
            Handle_ULonglong_Float_Cvt($0->result, $2->result_high, $2->result, ops, false);
        };

f8reg   : F8U8CVT(reg64)
        {
            $cost[0].cost = 10 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_F8);
            Handle_ULonglong_Float_Cvt($0->result, $2->result_high, $2->result, ops, true);
        };



reg64   : I8ABS(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            TN* mask = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_srawi, mask, $2->result_high, Gen_Literal_TN(31, 4), ops);
            Build_OP(TOP_xor, $0->result_high, $2->result_high, mask, ops);
            Build_OP(TOP_xor, $0->result, $2->result, mask, ops);
            Build_OP(TOP_subfc, $0->result, mask, $0->result, ops);
            Build_OP(TOP_subfe, $0->result_high, mask, $0->result_high, ops);
        };

reg64   : I8NEG(reg64), U8NEG(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_subfic, $0->result, $2->result, Gen_Literal_TN(0, 4), ops);
            Build_OP(TOP_subfze, $0->result_high, $2->result_high, ops);
        };

reg64   : I8ADD(reg64, I8INTCONST), U8ADD(reg64, U8INTCONST)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            INT64 val = WN_const_val($3->wn);
            short low_low = (short)val;
            short low_high = (short)(val >> 16);
            short high_low = (short)(val >> 32);
            short high_high = (short)(val >> 48);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            if (low_low == 0)
            {
                if (low_high != 0)
                {
                    Build_OP(TOP_lis, $0->result, Gen_Literal_TN(low_high, 4), ops);
                    Build_OP(TOP_addc, $0->result, $2->result, $0->result, ops);
                }
                    
            }
            else {
                low_high += low_low < 0 ? 1 : 0;
                if (low_high == 0)
                    Build_OP(TOP_addic, $0->result, $2->result, Gen_Literal_TN(low_low, 4), ops);
                else
                {
                    Build_OP(TOP_li, $0->result, Gen_Literal_TN(low_low, 4), ops);
                    Build_OP(TOP_addis, $0->result, Gen_Literal_TN(low_high, 4), ops);
                    Build_OP(TOP_addc, $0->result, $2->result, $0->result, ops);
                }
            }
            if (low_low != 0 || low_high != 0)
            {
                if (high_low == 0)
                {
                    if (high_high != 0)
                    {
                        Build_OP(TOP_lis, $0->result_high, Gen_Literal_TN(high_high, 4), ops);
                        Build_OP(TOP_adde, $0->result_high, $2->result_high, $0->result_high, ops);
                    }
                    else
                    {
                        Build_OP(TOP_addze, $0->result_high, $2->result_high, ops);
                    }
                }
                else
                {
                    high_high += high_low < 0 ? 1 : 0;
                    Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(high_low, 4), ops);
                    if (high_high != 0)
                        Build_OP(TOP_addis, $0->result_high, Gen_Literal_TN(high_high, 4), ops);
                    Build_OP(TOP_adde, $0->result_high, $2->result_high, $0->result_high, ops);
                }
            }
            else
            {
                if (high_low == 0)
                    Build_OP(TOP_addis, $0->result_high, $2->result_high, Gen_Literal_TN(high_high, 4), ops);
                else
                {
                    high_high += high_low < 0 ? 1 : 0;
                    Build_OP(TOP_addi, $0->result_high, $2->result_high, Gen_Literal_TN(high_low, 4), ops);
                    if (high_high != 0)
                        Build_OP(TOP_addis, $0->result_high, $2->result_high, Gen_Literal_TN(high_high, 4), ops);
                }
            }
            
        };

reg64   : I8ADD(reg64, reg64), U8ADD(reg64, reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_addc, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_adde, $0->result_high, $2->result_high, $3->result_high, ops);
        };

reg64   : I8SUB(reg64, reg64), U8SUB(reg64, reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_subfc, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_subfe, $0->result_high, $2->result_high, $3->result_high, ops);
        };

reg64   : I8MPY(reg64, reg64), U8MPY(reg64, reg64)
        {
            $cost[0].cost = 20 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_mullw, $0->result_high, $2->result_high, $3->result, ops);
            Build_OP(TOP_mullw, $0->result, $2->result, $3->result_high, ops);
            Build_OP(TOP_add, $0->result_high, $0->result_high, $0->result, ops);
            Build_OP(TOP_mulhwu, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_add, $0->result_high, $0->result_high, $0->result, ops);
            Build_OP(TOP_mullw, $0->result, $2->result, $3->result, ops);
        };

reg64   : I8HIGHMPY(reg64, reg64)
        {
            $cost[0].cost = 20 + $cost[2].cost + $cost[3].cost;
        }
        = {
            FmtAssert(false, ("Not Implemented"));
        };

reg64   : I8DIV(reg64, reg64)
        {
            $cost[0].cost = 64 + $cost[2].cost + $cost[3].cost;
        }
        = {
            FmtAssert(false, ("call build-in lib"));
        };

reg64   : I8REM(reg64, reg64)
        {
            $cost[0].cost = 64 + $cost[2].cost + $cost[3].cost;
        }
        = {
            FmtAssert(false, ("Not Implemented"));
        };

reg64   : I8MOD(reg64, reg64)
        {
            $cost[0].cost = 64 + $cost[2].cost + $cost[3].cost;
        }
        = {
            FmtAssert(false, ("Not Implemented"));
        };



reg64   : U8HIGHMPY(reg64, reg64)
        {
            $cost[0].cost = 20 + $cost[2].cost + $cost[3].cost;
        }
        = {
            FmtAssert(false, ("Not Implemented"));
        };

reg64   : U8REM(reg64, reg64), U8MOD(reg64, reg64)
        {
            $cost[0].cost = 64 + $cost[2].cost + $cost[3].cost;
        }
        = {
            FmtAssert(false, ("Not Implemented"));
        };



reg64   : I8I1LDID
        {
            $cost[0].cost = 8;
        }
        = {
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Load($0->wn, $0->result, TOP_lbz, ops);
            // lbz will not extend the sign bit, we need to do it ourselves
            Build_OP(TOP_extsb, $0->result, $0->result, ops);
            // FIXME
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I2LDID
        {
            $cost[0].cost = 8;
        }
        = {
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Load($0->wn, $0->result, TOP_lha, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4LDID, U8U4LDID
        {
            $cost[0].cost = 8;
        }
        = {
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Load($0->wn, $0->result, TOP_lwz, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I8LDID, U8U8LDID
        {
            $cost[0].cost = 8;
        }
        = {
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Longlong_Ldst($0->wn, TOP_lwz, $0->result, $0->result_high, ops);
        };

null    : I8STID(reg64), U8STID(reg64)
        {
            $cost[0].cost = 6;
        }
        = {
            $action[2](ops);
            Handle_Longlong_Ldst($0->wn, TOP_stw, $2->result, $2->result_high, ops);
        };
        
reg64   : I8INTCONST, U8INTCONST
        {
            $cost[0].cost = 4;
        }
        = {
            INT64 val = WN_const_val($1->wn);
            short low_low = (short)val;
            short low_high = (short)(val >> 16);
            short high_low = (short)(val >> 32);
            short high_high = (short)(val >> 48);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            if (low_low == 0)
                Build_OP(TOP_lis, $0->result, Gen_Literal_TN(low_high, 4), ops);
            else
            {
                low_high += low_low < 0 ? 1 : 0;
                Build_OP(TOP_li, $0->result, Gen_Literal_TN(low_low, 4), ops);
                if (low_high != 0)
                    Build_OP(TOP_addis, $0->result, $0->result, Gen_Literal_TN(low_high, 4), ops);
            }
            if (high_low == 0)
                Build_OP(TOP_lis, $0->result_high, Gen_Literal_TN(high_high, 4), ops);
            else
            {
                high_high += high_low < 0 ? 1 : 0;
                Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(high_low, 4), ops);
                if (low_high != 0)
                    Build_OP(TOP_addis, $0->result_high, $0->result_high, Gen_Literal_TN(high_high, 4), ops);
            }
        };

reg64   : U8U1LDID
        {
            $cost[0].cost = 8;
        }
        = {
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Load($0->wn, $0->result, TOP_lbz, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : U8U2LDID
        {
            $cost[0].cost = 8;
        }
        = {
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Load($0->wn, $0->result, TOP_lhz, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };



reg64   : I8BNOT(reg64), U8BNOT(reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost;
        }
        = {
            $action[2](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_nand, $0->result, $2->result, $2->result, ops);
            Build_OP(TOP_nand, $0->result_high, $2->result_high, $2->result_high, ops);
        };

reg64   : I8BAND(reg64, reg64), U8BAND(reg64, reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_and, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_and, $0->result_high, $2->result_high, $3->result_high, ops);
        };

reg64   : I8BIOR(reg64, reg64), U8BIOR(reg64, reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_or, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_or, $0->result_high, $2->result_high, $3->result_high, ops);
        };

reg64   : I8BXOR(reg64, reg64), U8BXOR(reg64, reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_xor, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_xor, $0->result_high, $2->result_high, $3->result_high, ops);
        };

reg64   : I8BNOR(reg64, reg64), U8BNOR(reg64, reg64)
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_nor, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_nor, $0->result_high, $2->result_high, $3->result_high, ops);
        };

reg64   : I8BNOT(I8BAND(reg64, reg64)), U8BNOT(U8BAND(reg64, reg64))
        {
            $cost[0].cost = 2 + $cost[3].cost + $cost[4].cost;
        }
        = {
            $action[3](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_nand, $0->result, $3->result, $4->result, ops);
            Build_OP(TOP_nand, $0->result_high, $3->result_high, $4->result_high, ops);
        };

reg64   : I8BNOT(I8BIOR(reg64, reg64)), U8BNOT(U8BIOR(reg64, reg64))
        {
            $cost[0].cost = 2 + $cost[3].cost + $cost[4].cost;
        }
        = {
            $action[3](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_nor, $0->result, $3->result, $4->result, ops);
            Build_OP(TOP_nor, $0->result_high, $3->result_high, $4->result_high, ops);
        };

reg64   : I8BNOT(I8BXOR(reg64, reg64)), U8BNOT(U8BXOR(reg64, reg64))
        {
            $cost[0].cost = 2 + $cost[3].cost + $cost[4].cost;
        }
        = {
            $action[3](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_eqv, $0->result, $3->result, $4->result, ops);
            Build_OP(TOP_eqv, $0->result_high, $3->result_high, $4->result_high, ops);
        };

reg64   : I8BAND(reg64, I8BNOT(reg64)), U8BAND(reg64, U8BNOT(reg64))
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[4].cost;
        }
        = {
            $action[2](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_andc, $0->result, $2->result, $4->result, ops);
            Build_OP(TOP_andc, $0->result_high, $2->result_high, $4->result_high, ops);
        };

reg64   : I8BIOR(reg64, I8BNOT(reg64)), U8BIOR(reg64, U8BNOT(reg64))
        {
            $cost[0].cost = 2 + $cost[2].cost + $cost[4].cost;
        }
        = {
            $action[2](ops);
            $action[4](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_orc, $0->result, $2->result, $4->result, ops);
            Build_OP(TOP_orc, $0->result_high, $2->result_high, $4->result_high, ops);
        };



reg     : BI8LT(reg64, reg64), I4I8LT(reg64, reg64), U4I8LT(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_LT, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BI8LE(reg64, reg64), I4I8LE(reg64, reg64), U4I8LE(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_LE, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BI8EQ(reg64, reg64), I4I8EQ(reg64, reg64), U4I8EQ(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_EQ, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BI8NE(reg64, reg64), I4I8NE(reg64, reg64), U4I8NE(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_NE, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BI8GE(reg64, reg64), I4I8GE(reg64, reg64), U4I8GE(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_GE, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BI8GT(reg64, reg64), I4I8GT(reg64, reg64), U4I8GT(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_GT, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };



reg64   : I8MAX(reg64, reg64)
        {
            $cost[0].cost = 20 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_MaxMin_Longlong(true, TOP_cmpw, $0->result_high, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg64   : I8MIN(reg64, reg64)
        {
            $cost[0].cost = 20 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_MaxMin_Longlong(false, TOP_cmpw, $0->result_high, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };



reg     : BU8LT(reg64, reg64), I4U8LT(reg64, reg64), U4U8LT(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Longlong(OPR_LT, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BU8LE(reg64, reg64), I4U8LE(reg64, reg64), U4U8LE(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Longlong(OPR_LE, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BU8EQ(reg64, reg64), I4U8EQ(reg64, reg64), U4U8EQ(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Longlong(OPR_EQ, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BU8NE(reg64, reg64), I4U8NE(reg64, reg64), U4U8NE(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Longlong(OPR_NE, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BU8GE(reg64, reg64), I4U8GE(reg64, reg64), U4U8GE(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Longlong(OPR_GE, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg     : BU8GT(reg64, reg64), I4U8GT(reg64, reg64), U4U8GT(reg64, reg64)
        {
            $cost[0].cost = 6 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (WN_rtype($0->wn));
            Handle_Cond_Longlong(OPR_GT, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };



reg64   : U8MAX(reg64, reg64)
        {
            $cost[0].cost = 20 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_MaxMin_Longlong(true, TOP_cmplw, $0->result_high, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };

reg64   : U8MIN(reg64, reg64)
        {
            $cost[0].cost = 20 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_MaxMin_Longlong(false, TOP_cmplw, $0->result_high, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
        };


reg64   : I8I4LT(reg, simm16), U8I4LT(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LT, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4LT(reg, reg), U8I4LT(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LT, TOP_cmpw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4LE(reg, simm16), U8I4LE(reg, simm16)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LE, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4LE(reg, reg), U8I4LE(reg, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LE, TOP_cmpw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4EQ(reg, simm16), U8I4EQ(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4EQ(reg, reg), U8I4EQ(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmpw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4NE(reg, simm16), U8I4NE(reg, simm16)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_NE, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4NE(reg, reg), U8I4NE(reg, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_NE, TOP_cmpw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4GE(reg, simm16), U8I4GE(reg, simm16)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GE, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4GE(reg, reg), U8I4GE(reg, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GE, TOP_cmpw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4GT(reg, simm16), U8I4GT(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GT, TOP_cmpwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I4GT(reg, reg), U8I4GT(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GT, TOP_cmpw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };



reg64   : I8U4LT(reg, simm16), U8U4LT(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LT, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4LT(reg, reg), U8U4LT(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LT, TOP_cmplw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4LE(reg, simm16), U8U4LE(reg, simm16)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LE, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4LE(reg, reg), U8U4LE(reg, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_LE, TOP_cmplw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4EQ(reg, simm16), U8U4EQ(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4EQ(reg, reg), U8U4EQ(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_EQ, TOP_cmplw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4NE(reg, simm16), U8U4NE(reg, simm16)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_NE, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4NE(reg, reg), U8U4NE(reg, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_NE, TOP_cmplw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4GE(reg, simm16), U8U4GE(reg, simm16)
        {
            $cost[0].cost = 5 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GE, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4GE(reg, reg), U8U4GE(reg, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GE, TOP_cmplw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4GT(reg, simm16), U8U4GT(reg, simm16)
        {
            $cost[0].cost = 4 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GT, TOP_cmplwi, $0->result, $2->result, Gen_Literal_TN(WN_const_val($3->wn), 4), ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U4GT(reg, reg), U8U4GT(reg, reg)
        {
            $cost[0].cost = 4 + $cost[2].cost + $cost[3].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Int(OPR_GT, TOP_cmplw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };



reg64   : I8F4LT(f4reg, f4reg), U8F4LT(f4reg, f4reg), I8F8LT(f8reg, f8reg), U8F8LT(f8reg, f8reg)
        {
            $cost[0].cost = 9 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (MTYPE_I4);
        	  $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Float(OPR_LT, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8F4LE(f4reg, f4reg), U8F4LE(f4reg, f4reg), I8F8LE(f8reg, f8reg), U8F8LE(f8reg, f8reg)
        {
            $cost[0].cost = 11 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (MTYPE_I4);
        	  $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Float(OPR_LE, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8F4EQ(f4reg, f4reg), U8F4EQ(f4reg, f4reg), I8F8EQ(f8reg, f8reg), U8F8EQ(f8reg, f8reg)
        {
            $cost[0].cost = 9 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (MTYPE_I4);
        	  $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Float(OPR_EQ, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8F4NE(f4reg, f4reg), U8F4NE(f4reg, f4reg), I8F8NE(f8reg, f8reg), U8F8NE(f8reg, f8reg)
        {
            $cost[0].cost = 11 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (MTYPE_I4);
        	  $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
        	  Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
            Handle_Cond_Move_Float(OPR_NE, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8F4GE(f4reg, f4reg), U8F4GE(f4reg, f4reg), I8F8GE(f8reg, f8reg), U8F8GE(f8reg, f8reg)
        {
            $cost[0].cost = 10 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (MTYPE_I4);
        	  $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Float(OPR_GE, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
            
        };

reg64   : I8F4GT(f4reg, f4reg), U8F4GT(f4reg, f4reg), I8F8GT(f8reg, f8reg), U8F8GT(f8reg, f8reg)
        {
            $cost[0].cost = 8 + $cost[2].cost + $cost[3].cost;
        }
        = {
        	  $action[2](ops);
        	  $action[3](ops);
        	  $0->result = Build_TN_Of_Mtype (MTYPE_I4);
        	  $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Move_Float(OPR_GT, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };



reg64   : I8I8LT(reg64, reg64), U8I8LT(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_LT, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I8LE(reg64, reg64), U8I8LE(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_LE, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I8EQ(reg64, reg64), U8I8EQ(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_EQ, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I8NE(reg64, reg64), U8I8NE(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_NE, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I8GE(reg64, reg64), U8I8GE(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_GE, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8I8GT(reg64, reg64), U8I8GT(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_GT, TOP_cmpw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };



reg64   : I8U8LT(reg64, reg64), U8U8LT(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_LT, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U8LE(reg64, reg64), U8U8LE(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_LE, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U8EQ(reg64, reg64), U8U8EQ(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_EQ, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U8NE(reg64, reg64), U8U8NE(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_NE, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U8GE(reg64, reg64), U8U8GE(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_GE, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };

reg64   : I8U8GT(reg64, reg64), U8U8GT(reg64, reg64)
        {
            $cost[0].cost = 7 + $cost[2].cost;
        }    
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            Handle_Cond_Longlong(OPR_GT, TOP_cmplw, $0->result, $2->result_high, $2->result, $3->result_high, $3->result, ops);
            Build_OP(TOP_li, $0->result_high, Gen_Literal_TN(0, 4), ops);
        };



reg64   : I8SHL(reg64, reg), U8SHL(reg64, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            
            TN* shr = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_subfic, shr, $3->result, Gen_Literal_TN(32, 4), ops);
            TN* tn = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_srw, tn, $2->result, shr, ops);            
            Build_OP(TOP_slw, $0->result, $2->result, $3->result, ops);           
            Build_OP(TOP_slw, $0->result_high, $2->result_high, $3->result, ops);
            Build_OP(TOP_or, $0->result_high, $0->result_high, tn, ops);
        };

reg64   : I8LSHR(reg64, reg), U8LSHR(reg64, reg), U8ASHR(reg64, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            
            TN* shl = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_subfic, shl, $3->result, Gen_Literal_TN(32, 4), ops);
            TN* tn = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_slw, tn, $2->result_high, shl, ops);
            Build_OP(TOP_srw, $0->result_high, $2->result_high, $3->result, ops);
            Build_OP(TOP_srw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_or, $0->result, $0->result, tn, ops);
        };

reg64   : I8ASHR(reg64, reg)
        {
            $cost[0].cost = 5 + $cost[2].cost + $cost[3].cost;
        }
        = {
            $action[2](ops);
            $action[3](ops);
            $0->result = Build_TN_Of_Mtype (MTYPE_I4);
            $0->result_high = Build_TN_Of_Mtype (MTYPE_I4);
            TN* shl = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_subfic, shl, $3->result, Gen_Literal_TN(32, 4), ops);
            TN* tn = Build_TN_Of_Mtype (MTYPE_I4);
            Build_OP(TOP_slw, tn, $2->result_high, shl, ops);
            Build_OP(TOP_sraw, $0->result_high, $2->result_high, $3->result, ops);
            Build_OP(TOP_srw, $0->result, $2->result, $3->result, ops);
            Build_OP(TOP_or, $0->result, $0->result, tn, ops);
        };



null    : I4PARM(reg), U4PARM(reg), I8PARM(reg64), U8PARM(reg64), F4PARM(f4reg), F8PARM(f8reg)
        {
            $cost[0].cost = $cost[2].cost;
        }
        = {
            $action[2](ops);
        };
    
null    : CALL
        {
            $cost[0].cost = 2;
        }
        = {        
            Handle_Call($0->wn, $0->opr);
        };

%%

extern void Add_TN_Pair(TN* key, TN* pair);
extern TN* Get_TN_Pair(TN* key);

TN * Burm_Expand_Expr (WN *expr, WN *parent, TN *result, INTRINSIC intrn_id)
{
    TREE  ptree = new olive_node(expr, parent, result, intrn_id);
    STATE state = new burm_state;
    
    SET_STATE(ptree, state);    
    if (burm_label(ptree) == 0) {
        printf("\n\nERROR: olive no cover\n\n\n");
        dump_tree(expr);
    } else {
        expr_action(ptree->state_label(), &New_OPs);
    }
    if (result == NULL) {  
        result = ptree->result;  
    }
    if (ptree->result_high != NULL && Get_TN_Pair(result) == NULL) {
        Add_TN_Pair(result, ptree->result_high);
    }
    delete ptree;   // ptree->result is still valid  
    delete state;
    Set_OP_To_WN_Map(expr);
    return result;    
}

