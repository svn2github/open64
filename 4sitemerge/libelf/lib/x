32.fsize.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2001 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
28c24
< static const char rcsid[] = "@(#) $Id: 32.fsize.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 32.fsize.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
50,54d45
< 	    { 0, 0 },	/* there is no Elf32_Sxword */
< 	    { 0, 0 },	/* there is no Elf32_Xword */
< 	    /* XXX: check Solaris values */
< 	    { 0, 0 },	/* Elf32_Verdef/Verdaux size varies */
< 	    { 0, 0 },	/* Elf32_Verneed/Vernaux size varies */
77,79d67
< 	    /* XXX: check Solaris values */
< 	    { 0, 0 },	/* Elf64_Verdef/Verdaux size varies */
< 	    { 0, 0 },	/* Elf64_Verneed/Vernaux size varies */
113,158d100
< size_t
< gelf_fsize(Elf *elf, Elf_Type type, size_t count, unsigned ver) {
<     if (elf) {
< 	if (elf->e_kind != ELF_K_ELF) {
< 	    seterr(ERROR_NOTELF);
< 	}
< 	else if (valid_class(elf->e_class)) {
< 	    return count * _elf_fsize(elf->e_class, type, ver);
< 	}
< 	else {
< 	    seterr(ERROR_UNKNOWN_CLASS);
< 	}
<     }
<     return 0;
< }
< 
< /*
<  * Extension: report memory size
<  */
< size_t
< gelf_msize(Elf *elf, Elf_Type type, size_t count, unsigned ver) {
<     size_t n;
< 
<     if (elf) {
< 	if (elf->e_kind != ELF_K_ELF) {
< 	    seterr(ERROR_NOTELF);
< 	}
< 	else if (!valid_class(elf->e_class)) {
< 	    seterr(ERROR_UNKNOWN_CLASS);
< 	}
< 	else if (!valid_version(ver)) {
< 	    seterr(ERROR_UNKNOWN_VERSION);
< 	}
< 	else if (!valid_type(type)) {
< 	    seterr(ERROR_UNKNOWN_TYPE);
< 	}
< 	else if (!(n = _msize(elf->e_class, ver, type))) {
< 	    seterr(ERROR_UNKNOWN_TYPE);
< 	}
< 	else {
< 	    return count * n;
< 	}
<     }
<     return 0;
< }
< 
32.fsize.c
32.getehdr.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: 32.getehdr.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 32.getehdr.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
32.getehdr.c
32.getphdr.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2000 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: 32.getphdr.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 32.getphdr.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
30c26
< char*
---
> static char*
32.getphdr.c
32.getshdr.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: 32.getshdr.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 32.getshdr.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
32.getshdr.c
32.newehdr.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2000 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: 32.newehdr.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 32.newehdr.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
76,87d71
< unsigned long
< gelf_newehdr(Elf *elf, int cls) {
<     if (!valid_class(cls) || !_msize(cls, _elf_version, ELF_T_EHDR)) {
< 	seterr(ERROR_UNKNOWN_CLASS);
< 	return 0;
<     }
<     if (!_elf_newehdr(elf, cls)) {
< 	return 0;
<     }
<     return 1;	/* really? */
< }
< 
32.newehdr.c
32.newphdr.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2000 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: 32.newphdr.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 32.newphdr.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
99,110d94
< unsigned long
< gelf_newphdr(Elf *elf, size_t phnum) {
<     if (!valid_class(elf->e_class)) {
< 	seterr(ERROR_UNKNOWN_CLASS);
< 	return 0;
<     }
<     if (!_elf_newphdr(elf, phnum, elf->e_class)) {
< 	return 0;
<     }
<     return 1;	/* really? */
< }
< 
32.newphdr.c
32.xlatetof.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2002 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
29c25
< static const char rcsid[] = "@(#) $Id: 32.xlatetof.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 32.xlatetof.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
59c55
<     static size_t						\
---
>     static void							\
61,74c57,65
< 	n /= sizeof(tfrom);					\
< 	if (n && dst) {						\
< 	    const tfrom *from = (const tfrom*)src;		\
< 	    tto *to = (tto*)dst;				\
< 	    size_t i;						\
< 								\
< 	    if (sizeof(tfrom) < sizeof(tto)) {			\
< 		from += n;					\
< 		to += n;					\
< 		for (i = 0; i < n; i++) {			\
< 		    --from;					\
< 		    --to;					\
< 		    copy(e,io,seq_back)				\
< 		}						\
---
> 	const tfrom *from = (const tfrom*)src;			\
> 	tto *to = (tto*)dst;					\
> 	if (sizeof(tfrom) < sizeof(tto)) {			\
> 	    from += n;						\
> 	    to += n;						\
> 	    while (n-- > 0) {					\
> 		--from;						\
> 		--to;						\
> 		copy(e,io,seq_back)				\
76,81c67,72
< 	    else {						\
< 		for (i = 0; i < n; i++) {			\
< 		    copy(e,io,seq_forw)				\
< 		    from++;					\
< 		    to++;					\
< 		}						\
---
> 	}							\
> 	else {							\
> 	    while (n-- > 0) {					\
> 		copy(e,io,seq_forw)				\
> 		from++;						\
> 		to++;						\
84d74
< 	return n * sizeof(tto);					\
139c129
<     nullcopy))
---
>     /**/))
155c145
<     nullcopy))))))))))))))
---
>     /**/))))))))))))))
165c155
<     nullcopy))))))))
---
>     /**/))))))))
170c160
<     nullcopy)))
---
>     /**/)))
174c164
<     nullcopy))
---
>     /**/))
186c176
<     nullcopy))))))))))
---
>     /**/))))))))))
194c184
<     nullcopy))))))
---
>     /**/))))))
196,198c186
< #define nullcopy /**/
< 
< static size_t
---
> static void
200c188,190
<     if (n && dst && dst != src) {
---
>     if (dst == src || !n) {
> 	return;
>     }
202,214c192,196
< 	size_t i;
< 
< 	if (dst >= src + n || dst + n <= src) {
< 	    memcpy(dst, src, n);
< 	}
< 	else if (dst < src) {
< 	    for (i = 0; i < n; i++) {
< 		dst[i] = src[i];
< 	    }
< 	}
< 	else {
< 	    for (i = n; --i; ) {
< 		dst[i] = src[i];
---
>     while (dst > src && dst < &src[n]) {
> 	if (n <= 16) {
> 	    /* copy `manually' */
> 	    while (n--) {
> 		dst[n] = src[n];
215a198
> 	    return;
217,219c200,203
< #else /* HAVE_BROKEN_MEMMOVE */
< 	memmove(dst, src, n);
< #endif /* HAVE_BROKEN_MEMMOVE */
---
> 	/* copy upper half */
> 	byte_copy(&dst[n / 2], &src[n / 2], n - n / 2);
> 	/* continue with lower half */
> 	n /= 2;
221c205,206
<     return n;
---
> #endif /* HAVE_BROKEN_MEMMOVE */
>     memmove(dst, src, n);
248c233
< typedef size_t (*xlator)(unsigned char*, const unsigned char*, size_t);
---
> typedef void (*xlator)(unsigned char*, const unsigned char*, size_t);
254,256d238
< #if PIC
< static xltab
< #else /* PIC */
258d239
< #endif /* PIC */
261c242
< 	{ byte_copy,        byte_copy       },
---
> 	{ byte_copy,	    byte_copy	    },
274,282d254
< 	{ NULL,             NULL            },	/* there is no Sxword */
< 	{ NULL,             NULL            },	/* there is no Xword */
< #if __LIBELF_SYMBOL_VERSIONS
< 	{ _elf_verdef_32L11_tom,  _elf_verdef_32L11_tof  },
< 	{ _elf_verneed_32L11_tom, _elf_verneed_32L11_tof },
< #else /* __LIBELF_SYMBOL_VERSIONS */
< 	{ NULL,             NULL            },
< 	{ NULL,             NULL            },
< #endif /* __LIBELF_SYMBOL_VERSIONS */
285c257
< 	{ byte_copy,        byte_copy       },
---
> 	{ byte_copy,	    byte_copy	    },
298,306d269
< 	{ NULL,             NULL            },	/* there is no Sxword */
< 	{ NULL,             NULL            },	/* there is no Xword */
< #if __LIBELF_SYMBOL_VERSIONS
< 	{ _elf_verdef_32M11_tom,  _elf_verdef_32M11_tof  },
< 	{ _elf_verneed_32M11_tom, _elf_verneed_32M11_tof },
< #else /* __LIBELF_SYMBOL_VERSIONS */
< 	{ NULL,             NULL            },
< 	{ NULL,             NULL            },
< #endif /* __LIBELF_SYMBOL_VERSIONS */
313,315d275
< #if PIC
< static xltab*
< #else /* PIC */
317d276
< #endif /* PIC */
330,365d288
<  * destination buffer size
<  */
< size_t
< _elf32_xltsize(const Elf_Data *src, unsigned dv, unsigned encode, int tof) {
<     Elf_Type type = src->d_type;
<     unsigned sv = src->d_version;
<     xlator op;
< 
<     if (!valid_version(sv) || !valid_version(dv)) {
< 	seterr(ERROR_UNKNOWN_VERSION);
< 	return (size_t)-1;
<     }
<     if (tof) {
< 	/*
< 	 * Encoding doesn't really matter (the translator only looks at
< 	 * the source, which resides in memory), but we need a proper
< 	 * encoding to select a translator...
< 	 */
< 	encode = ELFDATA2LSB;
<     }
<     else if (!valid_encoding(encode)) {
< 	seterr(ERROR_UNKNOWN_ENCODING);
< 	return (size_t)-1;
<     }
<     if (!valid_type(type)) {
< 	seterr(ERROR_UNKNOWN_TYPE);
< 	return (size_t)-1;
<     }
<     if (!(op = translator(sv, dv, encode, type, tof))) {
< 	seterr(ERROR_UNKNOWN_TYPE);
< 	return (size_t)-1;
<     }
<     return (*op)(NULL, src->d_buf, src->d_size);
< }
< 
< /*
369a293
>     size_t ssize, dsize, count;
371,374c295
<     int dv;
<     int sv;
<     size_t dsize;
<     size_t tmp;
---
>     int sv, dv;
398a320,321
>     ssize = _fmsize(ELFCLASS32, sv, type, 1 - tof);
>     dsize = _fmsize(ELFCLASS32, dv, type, tof);
400c323
<     if (!op) {
---
>     if (!ssize || !dsize || !op) {
404,405c327,328
<     dsize = (*op)(NULL, src->d_buf, src->d_size);
<     if (dst->d_size < dsize) {
---
>     count = src->d_size / ssize;
>     if (dst->d_size < count * dsize) {
409,411c332,333
<     if (dsize) {
< 	tmp = (*op)(dst->d_buf, src->d_buf, src->d_size);
< 	elf_assert(tmp == dsize);
---
>     if (count) {
> 	(*op)(dst->d_buf, src->d_buf, count);
413c335
<     dst->d_size = dsize;
---
>     dst->d_size = count * dsize;
32.xlatetof.c
64.xlatetof.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2002 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
28,29d23
< #if __LIBELF64
< 
31c25
< static const char rcsid[] = "@(#) $Id: 64.xlatetof.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: 64.xlatetof.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
33a28,75
> static __libelf_u64_t
> __load_u64L(const unsigned char *from) {
>     return ((__libelf_u64_t)__load_u32L(from + 4) << 32) | (__libelf_u64_t)__load_u32L(from);
> }
> 
> static __libelf_u64_t
> __load_u64M(const unsigned char *from) {
>     return ((__libelf_u64_t)__load_u32M(from) << 32) | (__libelf_u64_t)__load_u32M(from + 4);
> }
> 
> static __libelf_i64_t
> __load_i64L(const unsigned char *from) {
>     return ((__libelf_i64_t)__load_i32L(from + 4) << 32) | (__libelf_u64_t)__load_u32L(from);
> }
> 
> static __libelf_i64_t
> __load_i64M(const unsigned char *from) {
>     return ((__libelf_u64_t)__load_u32M(from) << 32) | (__libelf_i64_t)__load_i32M(from + 4);
> }
> 
> static void
> __store_u64L(unsigned char *to, __libelf_u64_t v) {
>     __store_u32L(to, (unsigned long)v);
>     v >>= 32;
>     __store_u32L(to + 4, (unsigned long)v);
> }
> 
> static void
> __store_u64M(unsigned char *to, __libelf_u64_t v) {
>     __store_u32M(to + 4, (unsigned long)v);
>     v >>= 32;
>     __store_u32M(to, (unsigned long)v);
> }
> 
> static void
> __store_i64L(unsigned char *to, __libelf_u64_t v) {
>     __store_u32L(to, (unsigned long)v);
>     v >>= 32;
>     __store_i32L(to + 4, (unsigned long)v);
> }
> 
> static void
> __store_i64M(unsigned char *to, __libelf_u64_t v) {
>     __store_u32M(to + 4, (unsigned long)v);
>     v >>= 32;
>     __store_i32M(to, (unsigned long)v);
> }
> 
61c103
<     static size_t						\
---
>     static void							\
63,76c105,113
< 	n /= sizeof(tfrom);					\
< 	if (n && dst) {						\
< 	    const tfrom *from = (const tfrom*)src;		\
< 	    tto *to = (tto*)dst;				\
< 	    size_t i;						\
< 								\
< 	    if (sizeof(tfrom) < sizeof(tto)) {			\
< 		from += n;					\
< 		to += n;					\
< 		for (i = 0; i < n; i++) {			\
< 		    --from;					\
< 		    --to;					\
< 		    copy(e,io,seq_back)				\
< 		}						\
---
> 	const tfrom *from = (const tfrom*)src;			\
> 	tto *to = (tto*)dst;					\
> 	if (sizeof(tfrom) < sizeof(tto)) {			\
> 	    from += n;						\
> 	    to += n;						\
> 	    while (n-- > 0) {					\
> 		--from;						\
> 		--to;						\
> 		copy(e,io,seq_back)				\
78,83c115,120
< 	    else {						\
< 		for (i = 0; i < n; i++) {			\
< 		    copy(e,io,seq_forw)				\
< 		    from++;					\
< 		    to++;					\
< 		}						\
---
> 	}							\
> 	else {							\
> 	    while (n-- > 0) {					\
> 		copy(e,io,seq_forw)				\
> 		from++;						\
> 		to++;						\
86d122
< 	return n * sizeof(tto);					\
120d155
< #define copy_word(e,io,mb)	Ex2(copy_,io,mb,u32,e)
121a157
> #define copy_word(e,io,mb)	Ex2(copy_,io,mb,u32,e)
134d169
< #define copy_word_11(e,io,seq)	Ex1(copy_scalar_,io,u32,e)
135a171
> #define copy_word_11(e,io,seq)	Ex1(copy_scalar_,io,u32,e)
145c181
<     nullcopy))
---
>     /**/))
161c197
<     nullcopy))))))))))))))
---
>     /**/))))))))))))))
171c207
<     nullcopy))))))))
---
>     /**/))))))))
181c217
<     nullcopy)))))))
---
>     /**/)))))))
189c225
<     nullcopy))))))
---
>     /**/))))))
195c231
<     nullcopy)))
---
>     /**/)))
199c235
<     nullcopy))
---
>     /**/))
212c248
<     nullcopy))))))))))
---
>     /**/))))))))))
220,222c256
<     nullcopy))))))
< 
< #define nullcopy /**/
---
>     /**/))))))
224c258
< static size_t
---
> static void
226c260,262
<     if (n && dst && dst != src) {
---
>     if (dst == src || !n) {
> 	return;
>     }
228,240c264,268
< 	size_t i;
< 
< 	if (dst >= src + n || dst + n <= src) {
< 	    memcpy(dst, src, n);
< 	}
< 	else if (dst < src) {
< 	    for (i = 0; i < n; i++) {
< 		dst[i] = src[i];
< 	    }
< 	}
< 	else {
< 	    for (i = n; --i; ) {
< 		dst[i] = src[i];
---
>     while (dst > src && dst < &src[n]) {
> 	if (n <= 16) {
> 	    /* copy `manually' */
> 	    while (n--) {
> 		dst[n] = src[n];
241a270
> 	    return;
243,245c272,275
< #else /* HAVE_BROKEN_MEMMOVE */
< 	memmove(dst, src, n);
< #endif /* HAVE_BROKEN_MEMMOVE */
---
> 	/* copy upper half */
> 	byte_copy(&dst[n / 2], &src[n / 2], n - n / 2);
> 	/* continue with lower half */
> 	n /= 2;
247c277,278
<     return n;
---
> #endif
>     memmove(dst, src, n);
265d295
< copy_type(word_64,_,Elf64_Word,copy_word_11)
266a297
> copy_type(word_64,_,Elf64_Word,copy_word_11)
276c307
< typedef size_t (*xlator)(unsigned char*, const unsigned char*, size_t);
---
> typedef void (*xlator)(unsigned char*, const unsigned char*, size_t);
282,284d312
< #if PIC
< static xltab
< #else /* PIC */
286d313
< #endif /* PIC */
289c316
< 	{ byte_copy,        byte_copy       },
---
> 	{ byte_copy,	    byte_copy	    },
294c321
< 	{ off_64L__tom,     off_64L__tof    },
---
> 	{ off_64L__tom,	    off_64L__tof    },
304,310d330
< #if __LIBELF_SYMBOL_VERSIONS
< 	{ _elf_verdef_64L11_tom,  _elf_verdef_64L11_tof  },
< 	{ _elf_verneed_64L11_tom, _elf_verneed_64L11_tof },
< #else /* __LIBELF_SYMBOL_VERSIONS */
< 	{ NULL,             NULL            },
< 	{ NULL,             NULL            },
< #endif /* __LIBELF_SYMBOL_VERSIONS */
313c333
< 	{ byte_copy,        byte_copy       },
---
> 	{ byte_copy,	    byte_copy	    },
318c338
< 	{ off_64M__tom,     off_64M__tof    },
---
> 	{ off_64M__tom,	    off_64M__tof    },
328,334d347
< #if __LIBELF_SYMBOL_VERSIONS
< 	{ _elf_verdef_64M11_tom,  _elf_verdef_64M11_tof  },
< 	{ _elf_verneed_64M11_tom, _elf_verneed_64M11_tof },
< #else /* __LIBELF_SYMBOL_VERSIONS */
< 	{ NULL,             NULL            },
< 	{ NULL,             NULL            },
< #endif /* __LIBELF_SYMBOL_VERSIONS */
341,343d353
< #if PIC
< static xltab*
< #else /* PIC */
345d354
< #endif /* PIC */
358,393d366
<  * destination buffer size
<  */
< size_t
< _elf64_xltsize(const Elf_Data *src, unsigned dv, unsigned encode, int tof) {
<     Elf_Type type = src->d_type;
<     unsigned sv = src->d_version;
<     xlator op;
< 
<     if (!valid_version(sv) || !valid_version(dv)) {
< 	seterr(ERROR_UNKNOWN_VERSION);
< 	return (size_t)-1;
<     }
<     if (tof) {
< 	/*
< 	 * Encoding doesn't really matter (the translator only looks at
< 	 * the source, which resides in memory), but we need a proper
< 	 * encoding to select a translator...
< 	 */
< 	encode = ELFDATA2LSB;
<     }
<     else if (!valid_encoding(encode)) {
< 	seterr(ERROR_UNKNOWN_ENCODING);
< 	return (size_t)-1;
<     }
<     if (!valid_type(type)) {
< 	seterr(ERROR_UNKNOWN_TYPE);
< 	return (size_t)-1;
<     }
<     if (!(op = translator(sv, dv, encode, type, tof))) {
< 	seterr(ERROR_UNKNOWN_TYPE);
< 	return (size_t)-1;
<     }
<     return (*op)(NULL, src->d_buf, src->d_size);
< }
< 
< /*
397a371
>     size_t ssize, dsize, count;
399,402c373
<     int dv;
<     int sv;
<     size_t dsize;
<     size_t tmp;
---
>     int sv, dv;
426a398,399
>     ssize = _fmsize(ELFCLASS64, sv, type, 1 - tof);
>     dsize = _fmsize(ELFCLASS64, dv, type, tof);
428c401
<     if (!op) {
---
>     if (!ssize || !dsize || !op) {
432,433c405,406
<     dsize = (*op)(NULL, src->d_buf, src->d_size);
<     if (dst->d_size < dsize) {
---
>     count = src->d_size / ssize;
>     if (dst->d_size < count * dsize) {
437,439c410,411
<     if (dsize) {
< 	tmp = (*op)(dst->d_buf, src->d_buf, src->d_size);
< 	elf_assert(tmp == dsize);
---
>     if (count) {
> 	(*op)(dst->d_buf, src->d_buf, count);
441c413
<     dst->d_size = dsize;
---
>     dst->d_size = count * dsize;
459,503d430
< Elf_Data*
< gelf_xlatetom(Elf *elf, Elf_Data *dst, const Elf_Data *src, unsigned encode) {
<     if (elf) {
< 	if (elf->e_kind != ELF_K_ELF) {
< 	    seterr(ERROR_NOTELF);
< 	}
< 	else if (elf->e_class == ELFCLASS32) {
< 	    return elf32_xlatetom(dst, src, encode);
< 	}
< 	else if (elf->e_class == ELFCLASS64) {
< 	    return elf64_xlatetom(dst, src, encode);
< 	}
< 	else if (valid_class(elf->e_class)) {
< 	    seterr(ERROR_UNIMPLEMENTED);
< 	}
< 	else {
< 	    seterr(ERROR_UNKNOWN_CLASS);
< 	}
<     }
<     return NULL;
< }
< 
< Elf_Data*
< gelf_xlatetof(Elf *elf, Elf_Data *dst, const Elf_Data *src, unsigned encode) {
<     if (elf) {
< 	if (elf->e_kind != ELF_K_ELF) {
< 	    seterr(ERROR_NOTELF);
< 	}
< 	else if (elf->e_class == ELFCLASS32) {
< 	    return elf32_xlatetof(dst, src, encode);
< 	}
< 	else if (elf->e_class == ELFCLASS64) {
< 	    return elf64_xlatetof(dst, src, encode);
< 	}
< 	else if (valid_class(elf->e_class)) {
< 	    seterr(ERROR_UNIMPLEMENTED);
< 	}
< 	else {
< 	    seterr(ERROR_UNKNOWN_CLASS);
< 	}
<     }
<     return NULL;
< }
< 
< #endif /* __LIBELF64__ */
64.xlatetof.c
assert.c
assert.c
begin.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2003 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
24a21
> #include <ar.h>
27c24
< static const char rcsid[] = "@(#) $Id: begin.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: begin.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
30,50d26
< #if HAVE_AR_H
< #include <ar.h>
< #else /* HAVE_AR_H */
< 
< #define ARMAG	"!<arch>\n"
< #define SARMAG	8
< 
< struct ar_hdr {
<     char    ar_name[16];
<     char    ar_date[12];
<     char    ar_uid[6];
<     char    ar_gid[6];
<     char    ar_mode[8];
<     char    ar_size[10];
<     char    ar_fmag[2];
< };
< 
< #define ARFMAG	"`\n"
< 
< #endif /* HAVE_AR_H */
< 
246d221
<     off_t off;
290c265
<     else if ((off = lseek(fd, (off_t)0, SEEK_END)) == (off_t)-1 || (size = off) != off) {
---
>     else if ((off_t)(size = lseek(fd, (off_t)0, 2)) == (off_t)-1) {
424,435d398
< 
< #if __LIBELF64
< 
< int
< gelf_getclass(Elf *elf) {
<     if (elf && elf->e_kind == ELF_K_ELF && valid_class(elf->e_class)) {
< 	return elf->e_class;
<     }
<     return ELFCLASSNONE;
< }
< 
< #endif /* __LIBELF64 */
begin.c
checksum.c
checksum.c
cntl.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: cntl.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: cntl.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
cntl.c
cook.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2002 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: cook.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: cook.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
33,56c29,42
< Elf_Type
< _elf_scn_type(unsigned t) {
<     switch (t) {
< 	case SHT_DYNAMIC:       return ELF_T_DYN;
< 	case SHT_DYNSYM:        return ELF_T_SYM;
< 	case SHT_HASH:          return ELF_T_WORD;
< 	case SHT_REL:           return ELF_T_REL;
< 	case SHT_RELA:          return ELF_T_RELA;
< 	case SHT_SYMTAB:        return ELF_T_SYM;
< 	case SHT_SYMTAB_SHNDX:	return ELF_T_WORD;	/* XXX: really? */
< #if __LIBELF_SYMBOL_VERSIONS
< #if __LIBELF_SUN_SYMBOL_VERSIONS
< 	case SHT_SUNW_verdef:   return ELF_T_VDEF;
< 	case SHT_SUNW_verneed:  return ELF_T_VNEED;
< 	case SHT_SUNW_versym:   return ELF_T_HALF;
< #else /* __LIBELF_SUN_SYMBOL_VERSIONS */
< 	case SHT_GNU_verdef:    return ELF_T_VDEF;
< 	case SHT_GNU_verneed:   return ELF_T_VNEED;
< 	case SHT_GNU_versym:    return ELF_T_HALF;
< #endif /* __LIBELF_SUN_SYMBOL_VERSIONS */
< #endif /* __LIBELF_SYMBOL_VERSIONS */
<     }
<     return ELF_T_BYTE;
< }
---
> const Elf_Type _elf_scn_types[SHT_NUM] = {
>     /* SHT_NULL */	ELF_T_BYTE,
>     /* SHT_PROGBITS */	ELF_T_BYTE,
>     /* SHT_SYMTAB */	ELF_T_SYM,
>     /* SHT_STRTAB */	ELF_T_BYTE,
>     /* SHT_RELA */	ELF_T_RELA,
>     /* SHT_HASH */	ELF_T_WORD,
>     /* SHT_DYNAMIC */	ELF_T_DYN,
>     /* SHT_NOTE */	ELF_T_BYTE,
>     /* SHT_NOBITS */	ELF_T_BYTE,
>     /* SHT_REL */	ELF_T_REL,
>     /* SHT_SHLIB */	ELF_T_BYTE,
>     /* SHT_DYNSYM */	ELF_T_SYM
> };
100c86,87
<     if ((elf->e_size - off) < src.d_size) {
---
>     if (off + src.d_size < off /* modulo overflow */
>      || off + src.d_size > elf->e_size) {
147c134
<     size_t num, off, align_addr;
---
>     size_t num, off, align;
157,158d143
<     align_addr = _fsize(elf->e_class, elf->e_version, ELF_T_ADDR);
<     elf_assert(align_addr);
161a147
> 	align = _ELF32_ALIGN_PHDR;
166a153
> 	align = _ELF64_ALIGN_PHDR;
181c168
< 	if (off % align_addr) {
---
> 	if (off % align) {
196a184
> 	align = _ELF32_ALIGN_SHDR;
201a190
> 	align = _ELF64_ALIGN_SHDR;
217c206
<     if (off) {
---
>     if (num && off) {
227c216
< 	if (off % align_addr) {
---
> 	if (off % align) {
242,291c231,232
< 	if (num == 0) {
< 	    union {
< 		Elf32_Shdr sh32;
< 		Elf64_Shdr sh64;
< 	    } u;
< 
< 	    /*
< 	     * Overflow in ehdr->e_shnum.
< 	     * Get real value from first SHDR.
< 	     */
< 	    if (elf->e_size - off < src.d_size) {
< 		seterr(ERROR_TRUNC_SHDR);
< 		return 0;
< 	    }
< 	    if (elf->e_rawdata) {
< 		src.d_buf = elf->e_rawdata + off;
< 	    }
< 	    else {
< 		src.d_buf = elf->e_data + off;
< 	    }
< 	    dst.d_buf = &u;
< 	    dst.d_size = sizeof(u);
< 	    if (!(_elf_xlatetom(elf, &dst, &src))) {
< 		return 0;
< 	    }
< 	    elf_assert(dst.d_size == _msize(elf->e_class, EV_CURRENT, ELF_T_SHDR));
< 	    elf_assert(dst.d_type == ELF_T_SHDR);
< 	    if (elf->e_class == ELFCLASS32) {
< 		num = u.sh32.sh_size;
< 	    }
< #if __LIBELF64
< 	    else if (elf->e_class == ELFCLASS64) {
< 		num = u.sh64.sh_size;
< 		/*
< 		 * Check for overflow on 32-bit systems
< 		 */
< 		if (overflow(num, u.sh64.sh_size, Elf64_Xword)) {
< 		    seterr(ERROR_OUTSIDE);
< 		    return 0;
< 		}
< 	    }
< #endif /* __LIBELF64 */
< 	    if (num < SHN_LORESERVE) {
< 		/* XXX: shall we tolerate this? */
< 		seterr(ERROR_EHDR_SHNUM);
< 		return 0;
< 	    }
< 	}
< 
< 	if ((elf->e_size - off) / src.d_size < num) {
---
> 	if (off + num * src.d_size < off /* modulo overflow */
> 	 || off + num * src.d_size > elf->e_size) {
331,332d271
< 	    sd->sd_scn = scn;
< 
340d278
< 		sd->sd_data.d_type = _elf_scn_type(scn->s_type);
359,420d296
< 		sd->sd_data.d_type = _elf_scn_type(scn->s_type);
< 		/*
< 		 * QUIRKS MODE:
< 		 *
< 		 * Some 64-bit architectures use 64-bit entries in the
< 		 * .hash section. This violates the ELF standard, and
< 		 * should be fixed. It's mostly harmless as long as the
< 		 * binary and the machine running your program have the
< 		 * same byte order, but you're in trouble if they don't,
< 		 * and if the entry size is wrong.
< 		 *
< 		 * As a workaround, I let libelf guess the right size
< 		 * for the binary. This relies pretty much on the fact
< 		 * that the binary provides correct data in the section
< 		 * headers. If it doesn't, it's probably broken anyway.
< 		 * Therefore, libelf uses a standard conforming value
< 		 * when it's not absolutely sure.
< 		 */
< 		if (scn->s_type == SHT_HASH) {
< 		    int override = 0;
< 
< 		    /*
< 		     * sh_entsize must reflect the entry size
< 		     */
< 		    if (shdr->sh_entsize == ELF64_FSZ_ADDR) {
< 			override++;
< 		    }
< 		    /*
< 		     * sh_size must be a multiple of sh_entsize
< 		     */
< 		    if (shdr->sh_size % ELF64_FSZ_ADDR == 0) {
< 			override++;
< 		    }
< 		    /*
< 		     * There must be room for at least 2 entries
< 		     */
< 		    if (shdr->sh_size >= 2 * ELF64_FSZ_ADDR) {
< 			override++;
< 		    }
< 		    /*
< 		     * sh_addralign must be correctly set
< 		     */
< 		    if (shdr->sh_addralign == ELF64_FSZ_ADDR) {
< 			override++;
< 		    }
< 		    /*
< 		     * The section must be properly aligned
< 		     */
< 		    if (shdr->sh_offset % ELF64_FSZ_ADDR == 0) {
< 			override++;
< 		    }
< 		    /* XXX: also look at the data? */
< 		    /*
< 		     * Make a conservative decision...
< 		     */
< 		    if (override >= 5) {
< 			sd->sd_data.d_type = ELF_T_ADDR;
< 		    }
< 		}
< 		/*
< 		 * END QUIRKS MODE.
< 		 */
429a306,311
> 	    if (valid_scntype(scn->s_type)) {
> 		sd->sd_data.d_type = _elf_scn_types[scn->s_type];
> 	    }
> 	    else {
> 		sd->sd_data.d_type = ELF_T_BYTE;
> 	    }
cook.c
data.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: data.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: data.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
data.c
end.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2000 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: end.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: end.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
50,51d45
< 	    elf_assert(sd->sd_magic == DATA_MAGIC);
< 	    elf_assert(sd->sd_scn == scn);
61,62d54
< 	    elf_assert(sd->sd_magic == DATA_MAGIC);
< 	    elf_assert(sd->sd_scn == scn);
end.c
errmsg.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 1999 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: errmsg.c 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: errmsg.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
46,48d41
< #if PIC
< static const char *_messages[] = {
< #else /* PIC */
50d42
< #endif /* PIC */
errmsg.c
errno.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: errno.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: errno.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
errno.c
fill.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: fill.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: fill.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
fill.c
flag.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: flag.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: flag.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
flag.c
gelfehdr.c
gelfehdr.c
gelfphdr.c
gelfphdr.c
gelfshdr.c
gelfshdr.c
gelftrans.c
gelftrans.c
getarhdr.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: getarhdr.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: getarhdr.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
getarhdr.c
getarsym.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
28c24
< static const char rcsid[] = "@(#) $Id: getarsym.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: getarsym.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
getarsym.c
getbase.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: getbase.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: getbase.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
getbase.c
getdata.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2001 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: getdata.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: getdata.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
32,33c28,29
<     Elf_Data dst;
<     Elf_Data src;
---
>     Elf_Data src, dst;
>     size_t fsize, msize;
35,37d30
<     size_t dlen;
< 
<     elf_assert(elf->e_data);
39,42c32
<     /*
<      * Prepare source
<      */
<     src = sd->sd_data;
---
>     src = dst = sd->sd_data;
44,48c34,39
<     if (elf->e_rawdata) {
< 	src.d_buf = elf->e_rawdata + scn->s_offset;
<     }
<     else {
< 	src.d_buf = elf->e_data + scn->s_offset;
---
>     fsize = _fsize(elf->e_class, src.d_version, src.d_type);
>     msize = _msize(elf->e_class, dst.d_version, src.d_type);
>     elf_assert(fsize);
>     elf_assert(msize);
>     if (fsize != msize) {
> 	dst.d_size = (dst.d_size / fsize) * msize;
51,71c42
<     /*
<      * Prepare destination (needs prepared source!)
<      */
<     dst = sd->sd_data;
<     if (elf->e_class == ELFCLASS32) {
< 	dlen = _elf32_xltsize(&src, dst.d_version, elf->e_encoding, 0);
<     }
< #if __LIBELF64
<     else if (elf->e_class == ELFCLASS64) {
< 	dlen = _elf64_xltsize(&src, dst.d_version, elf->e_encoding, 0);
<     }
< #endif /* __LIBELF64 */
<     else {
< 	elf_assert(valid_class(elf->e_class));
< 	seterr(ERROR_UNIMPLEMENTED);
< 	return NULL;
<     }
<     if (dlen == (size_t)-1) {
< 	return NULL;
<     }
<     dst.d_size = dlen;
---
>     elf_assert(elf->e_data);
83,85c54,60
<     /*
<      * Translate data
<      */
---
>     if (elf->e_rawdata) {
> 	src.d_buf = elf->e_rawdata + scn->s_offset;
>     }
>     else {
> 	src.d_buf = elf->e_data + scn->s_offset;
>     }
> 
115,116d89
< 	    elf_assert(sd->sd_magic == DATA_MAGIC);
< 	    elf_assert(sd->sd_scn == scn);
127,128d99
< 	elf_assert(sd->sd_magic == DATA_MAGIC);
< 	elf_assert(sd->sd_scn == scn);
getdata.c
getident.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: getident.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: getident.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
getident.c
getscn.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: getscn.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: getscn.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
getscn.c
hash.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2002 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: hash.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: hash.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
31c27
< elf_hash(const unsigned char *name) {
---
> elf_hash(const char *name) {
33a30
>     unsigned char c;
35,36c32,33
<     while (*name) {
< 	hash = (hash << 4) + (unsigned char)*name++;
---
>     while ((c = *name++)) {
> 	hash = (hash << 4) + c;
hash.c
input.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2001 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: input.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: input.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
46c42
< 	if (lseek(elf->e_fd, (off_t)off, SEEK_SET) != (off_t)off) {
---
> 	if (lseek(elf->e_fd, (off_t)off, 0) != (off_t)off) {
input.c
kind.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: kind.c 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: kind.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
kind.c
memset.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
29c25
< static const char rcsid[] = "@(#) $Id: memset.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: memset.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
memset.c
ndxscn.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: ndxscn.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: ndxscn.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
ndxscn.c
newdata.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2000 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: newdata.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: newdata.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
46d41
< 	sd->sd_scn = scn;
newdata.c
newscn.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 1998, 2003 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: newscn.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: newscn.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
30,68d25
< int
< _elf_update_shnum(Elf *elf, size_t shnum) {
<     Elf_Scn *scn;
< 
<     if (elf->e_class == ELFCLASS32) {
< 	if (shnum >= SHN_LORESERVE) {
< 	    scn = elf->e_scn_1;
< 	    elf_assert(scn->s_index == 0);
< 	    scn->s_shdr_flags |= ELF_F_DIRTY;
< 	    scn->s_shdr32.sh_size = shnum;
< 	    shnum = 0;
< 	}
< 	elf->e_ehdr_flags |= ELF_F_DIRTY;
< 	((Elf32_Ehdr*)elf->e_ehdr)->e_shnum = shnum;
< 	return 0;
<     }
< #if __LIBELF64
<     else if (elf->e_class == ELFCLASS64) {
< 	if (shnum >= SHN_LORESERVE) {
< 	    scn = elf->e_scn_1;
< 	    elf_assert(scn->s_index == 0);
< 	    scn->s_shdr_flags |= ELF_F_DIRTY;
< 	    scn->s_shdr64.sh_size = shnum;
< 	    shnum = 0;
< 	}
< 	elf->e_ehdr_flags |= ELF_F_DIRTY;
< 	((Elf64_Ehdr*)elf->e_ehdr)->e_shnum = shnum;
< 	return 0;
<     }
< #endif /* __LIBELF64 */
<     else if (valid_class(elf->e_class)) {
< 	seterr(ERROR_UNIMPLEMENTED);
<     }
<     else {
< 	seterr(ERROR_UNKNOWN_CLASS);
<     }
<     return -1;
< }
< 
84,87d40
< 	    if (_elf_update_shnum(elf, scn->s_index + 1)) {
< 		free(scn);
< 		return NULL;
< 	    }
92,96c45
< 	scn->s_index = 0;
< 	if (_elf_update_shnum(elf, 1)) {
< 	    free(scn);
< 	    return NULL;
< 	}
---
> 	elf_assert(scn->s_index == SHN_UNDEF);
120c69,74
<     else if ((scn = _buildscn(elf))) {
---
>     else if (elf->e_class == ELFCLASS32) {
> 	if (!(scn = _buildscn(elf))) {
> 	    return NULL;
> 	}
> 	((Elf32_Ehdr*)elf->e_ehdr)->e_shnum = scn->s_index + 1;
> 	elf->e_ehdr_flags |= ELF_F_DIRTY;
122a77,92
> #if __LIBELF64
>     else if (elf->e_class == ELFCLASS64) {
> 	if (!(scn = _buildscn(elf))) {
> 	    return NULL;
> 	}
> 	((Elf64_Ehdr*)elf->e_ehdr)->e_shnum = scn->s_index + 1;
> 	elf->e_ehdr_flags |= ELF_F_DIRTY;
> 	return scn;
>     }
> #endif /* __LIBELF64 */
>     else if (valid_class(elf->e_class)) {
> 	seterr(ERROR_UNIMPLEMENTED);
>     }
>     else {
> 	seterr(ERROR_UNKNOWN_CLASS);
>     }
newscn.c
next.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: next.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: next.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
next.c
nextscn.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: nextscn.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: nextscn.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
nextscn.c
nlist.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2002 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
25a22
> #include <fcntl.h>
28c25
< static const char rcsid[] = "@(#) $Id: nlist.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: nlist.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
31,44d27
< #if HAVE_FCNTL_H
< #include <fcntl.h>
< #endif /* HAVE_FCNTL_H */
< 
< #ifndef O_RDONLY
< #define O_RDONLY	0
< #endif /* O_RDONLY */
< 
< #ifndef O_BINARY
< #define O_BINARY	0
< #endif /* O_BINARY */
< 
< #define FILE_OPEN_MODE	(O_RDONLY | O_BINARY)
< 
237c220
< 	if ((fd = open(filename, FILE_OPEN_MODE)) != -1) {
---
> 	if ((fd = open(filename, O_RDONLY)) != -1) {
nlist.c
opt.delscn.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2001 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: opt.delscn.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: opt.delscn.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
52,62d47
< #if __LIBELF_SYMBOL_VERSIONS
< #if __LIBELF_SUN_SYMBOL_VERSIONS
< 	    case SHT_SUNW_verdef:
< 	    case SHT_SUNW_verneed:
< 	    case SHT_SUNW_versym:
< #else /* __LIBELF_SUN_SYMBOL_VERSIONS */
< 	    case SHT_GNU_verdef:
< 	    case SHT_GNU_verneed:
< 	    case SHT_GNU_versym:
< #endif /* __LIBELF_SUN_SYMBOL_VERSIONS */
< #endif /* __LIBELF_SYMBOL_VERSIONS */
90,100d74
< #if __LIBELF_SYMBOL_VERSIONS
< #if __LIBELF_SUN_SYMBOL_VERSIONS
< 	    case SHT_SUNW_verdef:
< 	    case SHT_SUNW_verneed:
< 	    case SHT_SUNW_versym:
< #else /* __LIBELF_SUN_SYMBOL_VERSIONS */
< 	    case SHT_GNU_verdef:
< 	    case SHT_GNU_verneed:
< 	    case SHT_GNU_versym:
< #endif /* __LIBELF_SUN_SYMBOL_VERSIONS */
< #endif /* __LIBELF_SYMBOL_VERSIONS */
158,159d131
< 	elf_assert(sd->sd_magic == DATA_MAGIC);
< 	elf_assert(sd->sd_scn == scn);
169,170d140
< 	elf_assert(sd->sd_magic == DATA_MAGIC);
< 	elf_assert(sd->sd_scn == scn);
opt.delscn.c
rand.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: rand.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: rand.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
rand.c
rawdata.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2000 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: rawdata.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: rawdata.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
52,53d47
< 	elf_assert(sd->sd_magic == DATA_MAGIC);
< 	elf_assert(sd->sd_scn == scn);
68d61
< 	sd->sd_scn = scn;
rawdata.c
rawfile.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: rawfile.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: rawfile.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
rawfile.c
strptr.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2000, 2003 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: strptr.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: strptr.c,v 1.1 2005/07/27 02:27:46 kevinlo Exp $";
32d27
<     Elf_Data *data;
34,35c29
<     size_t n;
<     char *s;
---
>     Elf_Data *sd;
44c38
<     if (scn->s_index == SHN_UNDEF) {
---
>     if (scn->s_type != SHT_STRTAB) {
48,107c42,48
<     /*
<      * checking the section header is more appropriate
<      */
<     if (elf->e_class == ELFCLASS32) {
< 	if (scn->s_shdr32.sh_type != SHT_STRTAB) {
< 	    seterr(ERROR_NOSTRTAB);
< 	    return NULL;
< 	}
<     }
< #if __LIBELF64
<     else if (elf->e_class == ELFCLASS64) {
< 	if (scn->s_shdr64.sh_type != SHT_STRTAB) {
< 	    seterr(ERROR_NOSTRTAB);
< 	    return NULL;
< 	}
<     }
< #endif /* __LIBELF64 */
<     else if (valid_class(elf->e_class)) {
< 	seterr(ERROR_UNIMPLEMENTED);
< 	return NULL;
<     }
<     else {
< 	seterr(ERROR_UNKNOWN_CLASS);
< 	return NULL;
<     }
<     /*
<      * Find matching buffer
<      */
<     n = 0;
<     data = NULL;
<     if (elf->e_elf_flags & ELF_F_LAYOUT) {
< 	/*
< 	 * Programmer is responsible for d_off
< 	 * Note: buffers may be in any order!
< 	 */
< 	while ((data = elf_getdata(scn, data))) {
< 	    n = data->d_off;
< 	    if (offset >= n && offset - n < data->d_size) {
< 		/*
< 		 * Found it
< 		 */
< 		break;
< 	    }
< 	}
<     }
<     else {
< 	/*
< 	 * Calculate offsets myself
< 	 */
< 	while ((data = elf_getdata(scn, data))) {
< 	    if (data->d_align > 1) {
< 		n += data->d_align - 1;
< 		n -= n % data->d_align;
< 	    }
< 	    if (offset < n) {
< 		/*
< 		 * Invalid offset: points into a hole
< 		 */
< 		seterr(ERROR_BADSTROFF);
< 		return NULL;
---
>     if (offset >= 0 && offset < scn->s_size) {
> 	sd = NULL;
> 	while ((sd = elf_getdata(scn, sd))) {
> 	    if (sd->d_buf
> 	     && offset >= (size_t)sd->d_off
> 	     && offset < (size_t)sd->d_off + sd->d_size) {
> 		return (char*)sd->d_buf + (offset - sd->d_off);
109,139d49
< 	    if (offset - n < data->d_size) {
< 		/*
< 		 * Found it
< 		 */
< 		break;
< 	    }
< 	    n += data->d_size;
< 	}
<     }
<     if (data == NULL) {
< 	/*
< 	 * Not found
< 	 */
< 	seterr(ERROR_BADSTROFF);
< 	return NULL;
<     }
<     if (data->d_buf == NULL) {
< 	/*
< 	 * Buffer is NULL (usually the programmers' fault)
< 	 */
< 	seterr(ERROR_NULLBUF);
< 	return NULL;
<     }
<     offset -= n;
<     s = (char*)data->d_buf;
<     for (n = offset; n < data->d_size; n++) {
< 	if (s[n] == '\0') {
< 	    /*
< 	     * Return properly NUL terminated string
< 	     */
< 	    return s + offset;
142,146c52
<     /*
<      * String is not NUL terminated
<      * Return error to avoid SEGV in application
<      */
<     seterr(ERROR_UNTERM);
---
>     seterr(ERROR_BADSTROFF);
strptr.c
swap64.c
swap64.c
update.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2003 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
27c23
< static const char rcsid[] = "@(#) $Id: update.c 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: update.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
48d43
<     Elf_Data *data;
53a49
>     size_t msize;
55,68c51
<     if (!(sd = scn->s_data_1)) {
< 	/* no data in section */
< 	*algn = scn_align;
< 	return (off_t)len;
<     }
<     /* load data from file, if any */
<     if (!(data = elf_getdata(scn, NULL))) {
< 	return (off_t)-1;
<     }
<     elf_assert(data == &sd->sd_data);
<     for (; sd; sd = sd->sd_link) {
< 	elf_assert(sd->sd_magic == DATA_MAGIC);
< 	elf_assert(sd->sd_scn == scn);
< 
---
>     for (sd = scn->s_data_1; sd; sd = sd->sd_link) {
73,90c56,63
< 	fsize = sd->sd_data.d_size;
< 	if (fsize && type != SHT_NOBITS && valid_type(sd->sd_data.d_type)) {
< 	    if (elf->e_class == ELFCLASS32) {
< 		fsize = _elf32_xltsize(&sd->sd_data, v, ELFDATA2LSB, 1);
< 	    }
< #if __LIBELF64
< 	    else if (elf->e_class == ELFCLASS64) {
< 		fsize = _elf64_xltsize(&sd->sd_data, v, ELFDATA2LSB, 1);
< 	    }
< #endif /* __LIBELF64 */
< 	    else {
< 		elf_assert(valid_class(elf->e_class));
< 		seterr(ERROR_UNIMPLEMENTED);
< 		return (off_t)-1;
< 	    }
< 	    if (fsize == (size_t)-1) {
< 		return (off_t)-1;
< 	    }
---
> 	if (type != SHT_NOBITS && valid_type(sd->sd_data.d_type)) {
> 	    msize = _msize(elf->e_class, sd->sd_data.d_version, sd->sd_data.d_type);
> 	    fsize = _fsize(elf->e_class, v, sd->sd_data.d_type);
> 	    elf_assert(fsize && msize);
> 	    fsize *= sd->sd_data.d_size / msize;
> 	}
> 	else {
> 	    fsize = sd->sd_data.d_size;
111c84,85
<     Elf_Type type;
---
>     if (valid_scntype(stype)) {
> 	Elf_Type type = _elf_scn_types[stype];
113,119c87
<     switch ((type = _elf_scn_type(stype))) {
< 	case ELF_T_BYTE:
< 	    return 0;
< 	case ELF_T_VDEF:
< 	case ELF_T_VNEED:
< 	    return 0;	/* What else can I do?  Thank you, Sun! */
< 	default:
---
> 	if (valid_type(type)) {
120a89
> 	}
121a91
>     return 0;
131d100
<     size_t align_addr;
157,159d125
<     align_addr = _fsize(ELFCLASS32, version, ELF_T_ADDR);
<     elf_assert(align_addr);
< 
164c130
< 	    align(off, align_addr);
---
> 	    align(off, _ELF32_ALIGN_PHDR);
188c154
< 	*flag |= scn->s_scn_flags;
---
> 	*flag |= scn->s_scn_flags | scn->s_shdr_flags;
197d162
< 	    *flag |= scn->s_shdr_flags;
201d165
< 	    *flag |= scn->s_shdr_flags;
210,217c174,176
< 	/*
< 	 * Never override the program's choice.
< 	 */
< 	if (shdr->sh_entsize == 0) {
< 	    entsize = scn_entsize(elf, version, shdr->sh_type);
< 	    if (entsize > 1) {
< 		rewrite(shdr->sh_entsize, entsize, scn->s_shdr_flags);
< 	    }
---
> 	entsize = scn_entsize(elf, version, shdr->sh_type);
> 	if (entsize > 1) {
> 	    rewrite(shdr->sh_entsize, entsize, scn->s_shdr_flags);
233a193,195
> 	else if (shdr->sh_type != SHT_NOBITS) {
> 	    off = max(off, shdr->sh_offset + shdr->sh_size);
> 	}
235,263c197
< 	    Elf_Scn *scn2;
< 	    size_t end1, end2;
< 
< 	    end1 = shdr->sh_offset;
< 	    if (shdr->sh_type != SHT_NOBITS) {
< 		end1 += shdr->sh_size;
< 	    }
< 	    if (shdr->sh_offset < off) {
< 		/*
< 		 * check for overlapping sections
< 		 */
< 		for (scn2 = elf->e_scn_1; scn2; scn2 = scn2->s_link) {
< 		    if (scn2 == scn) {
< 			break;
< 		    }
< 		    end2 = scn2->s_shdr32.sh_offset;
< 		    if (scn2->s_shdr32.sh_type != SHT_NOBITS) {
< 			end2 += scn2->s_shdr32.sh_size;
< 		    }
< 		    if (end1 > scn2->s_shdr32.sh_offset
< 		     && end2 > shdr->sh_offset) {
< 			seterr(ERROR_SCN_OVERLAP);
< 			return -1;
< 		    }
< 		}
< 	    }
< 	    if (off < end1) {
< 		off = end1;
< 	    }
---
> 	    off = max(off, shdr->sh_offset);
265d198
< 	*flag |= scn->s_shdr_flags;
272c205
< 	    align(off, align_addr);
---
> 	    align(off, _ELF32_ALIGN_SHDR);
286,294d218
<     if (shnum >= SHN_LORESERVE) {
< 	Elf_Scn *scn = elf->e_scn_1;
< 	Elf32_Shdr *shdr = &scn->s_shdr32;
< 
< 	elf_assert(scn->s_index == 0);
< 	rewrite(shdr->sh_size, shnum, scn->s_shdr_flags);
< 	*flag |= scn->s_shdr_flags;
< 	shnum = 0;
<     }
321d244
<     size_t align_addr;
347,349d269
<     align_addr = _fsize(ELFCLASS64, version, ELF_T_ADDR);
<     elf_assert(align_addr);
< 
354c274
< 	    align(off, align_addr);
---
> 	    align(off, _ELF64_ALIGN_PHDR);
378c298
< 	*flag |= scn->s_scn_flags;
---
> 	*flag |= scn->s_scn_flags | scn->s_shdr_flags;
387d306
< 	    *flag |= scn->s_shdr_flags;
391d309
< 	    *flag |= scn->s_shdr_flags;
400,407c318,320
< 	/*
< 	 * Never override the program's choice.
< 	 */
< 	if (shdr->sh_entsize == 0) {
< 	    entsize = scn_entsize(elf, version, shdr->sh_type);
< 	    if (entsize > 1) {
< 		rewrite(shdr->sh_entsize, entsize, scn->s_shdr_flags);
< 	    }
---
> 	entsize = scn_entsize(elf, version, shdr->sh_type);
> 	if (entsize > 1) {
> 	    rewrite(shdr->sh_entsize, entsize, scn->s_shdr_flags);
423a337,339
> 	else if (shdr->sh_type != SHT_NOBITS) {
> 	    off = max(off, shdr->sh_offset + shdr->sh_size);
> 	}
425,453c341
< 	    Elf_Scn *scn2;
< 	    size_t end1, end2;
< 
< 	    end1 = shdr->sh_offset;
< 	    if (shdr->sh_type != SHT_NOBITS) {
< 		end1 += shdr->sh_size;
< 	    }
< 	    if (shdr->sh_offset < off) {
< 		/*
< 		 * check for overlapping sections
< 		 */
< 		for (scn2 = elf->e_scn_1; scn2; scn2 = scn2->s_link) {
< 		    if (scn2 == scn) {
< 			break;
< 		    }
< 		    end2 = scn2->s_shdr64.sh_offset;
< 		    if (scn2->s_shdr64.sh_type != SHT_NOBITS) {
< 			end2 += scn2->s_shdr64.sh_size;
< 		    }
< 		    if (end1 > scn2->s_shdr64.sh_offset
< 		     && end2 > shdr->sh_offset) {
< 			seterr(ERROR_SCN_OVERLAP);
< 			return -1;
< 		    }
< 		}
< 	    }
< 	    if (off < end1) {
< 		off = end1;
< 	    }
---
> 	    off = max(off, shdr->sh_offset);
455d342
< 	*flag |= scn->s_shdr_flags;
462c349
< 	    align(off, align_addr);
---
> 	    align(off, _ELF64_ALIGN_SHDR);
476,484d362
<     if (shnum >= SHN_LORESERVE) {
< 	Elf_Scn *scn = elf->e_scn_1;
< 	Elf64_Shdr *shdr = &scn->s_shdr64;
< 
< 	elf_assert(scn->s_index == 0);
< 	rewrite(shdr->sh_size, shnum, scn->s_shdr_flags);
< 	*flag |= scn->s_shdr_flags;
< 	shnum = 0;
<     }
562,575c440,447
< 	elf_assert(scn->s_magic == SCN_MAGIC);
< 	elf_assert(scn->s_elf == elf);
< 	if ((sd = scn->s_data_1)) {
< 	    elf_assert(sd->sd_magic == DATA_MAGIC);
< 	    elf_assert(sd->sd_scn == scn);
< 	    if (sd->sd_memdata && !sd->sd_free_data) {
< 		elf_assert(ptrinside(sd->sd_memdata, elf->e_data, elf->e_dsize));
< 		if (sd->sd_data.d_buf == sd->sd_memdata) {
< 		    newptr(sd->sd_memdata, elf->e_data, data);
< 		    sd->sd_data.d_buf = sd->sd_memdata;
< 		}
< 		else {
< 		    newptr(sd->sd_memdata, elf->e_data, data);
< 		}
---
> 	if ((sd = scn->s_data_1) && sd->sd_memdata && !sd->sd_free_data) {
> 	    elf_assert(ptrinside(sd->sd_memdata, elf->e_data, elf->e_dsize));
> 	    if (sd->sd_data.d_buf == sd->sd_memdata) {
> 		newptr(sd->sd_memdata, elf->e_data, data);
> 		sd->sd_data.d_buf = sd->sd_memdata;
> 	    }
> 	    else {
> 		newptr(sd->sd_memdata, elf->e_data, data);
578,587c450,456
< 	if ((sd = scn->s_rawdata)) {
< 	    elf_assert(sd->sd_magic == DATA_MAGIC);
< 	    elf_assert(sd->sd_scn == scn);
< 	    if (sd->sd_memdata && sd->sd_free_data) {
< 		size_t off, len;
< 
< 		if (elf->e_class == ELFCLASS32) {
< 		    off = scn->s_shdr32.sh_offset;
< 		    len = scn->s_shdr32.sh_size;
< 		}
---
> 	if ((sd = scn->s_rawdata) && sd->sd_memdata && sd->sd_free_data) {
> 	    size_t off, len;
> 
> 	    if (elf->e_class == ELFCLASS32) {
> 		off = scn->s_shdr32.sh_offset;
> 		len = scn->s_shdr32.sh_size;
> 	    }
589,592c458,461
< 		else if (elf->e_class == ELFCLASS64) {
< 		    off = scn->s_shdr64.sh_offset;
< 		    len = scn->s_shdr64.sh_size;
< 		}
---
> 	    else if (elf->e_class == ELFCLASS64) {
> 		off = scn->s_shdr64.sh_offset;
> 		len = scn->s_shdr64.sh_size;
> 	    }
594,606c463,473
< 		else {
< 		    seterr(ERROR_UNIMPLEMENTED);
< 		    return -1;
< 		}
< 		if (!(rawdata = (char*)realloc(sd->sd_memdata, len))) {
< 		    seterr(ERROR_IO_2BIG);
< 		    return -1;
< 		}
< 		memcpy(rawdata, outbuf + off, len);
< 		if (sd->sd_data.d_buf == sd->sd_memdata) {
< 		    sd->sd_data.d_buf = rawdata;
< 		}
< 		sd->sd_memdata = rawdata;
---
> 	    else {
> 		seterr(ERROR_UNIMPLEMENTED);
> 		return -1;
> 	    }
> 	    if (!(rawdata = (char*)realloc(sd->sd_memdata, len))) {
> 		seterr(ERROR_IO_2BIG);
> 		return -1;
> 	    }
> 	    memcpy(rawdata, outbuf + off, len);
> 	    if (sd->sd_data.d_buf == sd->sd_memdata) {
> 		sd->sd_data.d_buf = rawdata;
607a475
> 	    sd->sd_memdata = rawdata;
625a494,495
>     size_t fsize;
>     size_t msize;
657,659d526
< 	elf_assert(scn->s_magic == SCN_MAGIC);
< 	elf_assert(scn->s_elf == elf);
< 
678d544
< 	/* XXX: this is probably no longer necessary */
683,684d548
< 	    elf_assert(sd->sd_magic == DATA_MAGIC);
< 	    elf_assert(sd->sd_scn == scn);
697,701c561,566
< 		size_t tmp;
< 
< 		tmp = _elf32_xltsize(&src, dst.d_version, ELFDATA2LSB, 1);
< 		if (tmp == (size_t)-1) {
< 		    return -1;
---
> 		msize = _msize(ELFCLASS32, src.d_version, src.d_type);
> 		elf_assert(msize);
> 		fsize = _fsize(ELFCLASS32, dst.d_version, src.d_type);
> 		elf_assert(fsize);
> 		if (msize != fsize) {
> 		    dst.d_size = (src.d_size / msize) * fsize;
703d567
< 		dst.d_size = tmp;
752a617,618
>     size_t fsize;
>     size_t msize;
784,786d649
< 	elf_assert(scn->s_magic == SCN_MAGIC);
< 	elf_assert(scn->s_elf == elf);
< 
805d667
< 	/* XXX: this is probably no longer necessary */
810,811d671
< 	    elf_assert(sd->sd_magic == DATA_MAGIC);
< 	    elf_assert(sd->sd_scn == scn);
824,828c684,689
< 		size_t tmp;
< 
< 		tmp = _elf64_xltsize(&src, dst.d_version, ELFDATA2LSB, 1);
< 		if (tmp == (size_t)-1) {
< 		    return -1;
---
> 		msize = _msize(ELFCLASS64, src.d_version, src.d_type);
> 		elf_assert(msize);
> 		fsize = _fsize(ELFCLASS64, dst.d_version, src.d_type);
> 		elf_assert(fsize);
> 		if (msize != fsize) {
> 		    dst.d_size = (src.d_size / msize) * fsize;
830d690
< 		dst.d_size = tmp;
872c732
< _elf_output(Elf *elf, int fd, size_t len, off_t (*_elf_write)(Elf*, char*, size_t)) {
---
> _elf_output(Elf *elf, size_t len, off_t (*_elf_write)(Elf*, char*, size_t)) {
878c738
<     ftruncate(fd, 0);
---
>     ftruncate(elf->e_fd, 0);
885c745
<     if (ftruncate(fd, len)) {
---
>     if (ftruncate(elf->e_fd, len)) {
889c749
< 	if (lseek(fd, (off_t)len - 1, SEEK_SET) != (off_t)len - 1) {
---
> 	if (lseek(elf->e_fd, (off_t)len - 1, 0) != (off_t)len - 1) {
893c753
< 	if (write(fd, "", 1) != 1) {
---
> 	if (write(elf->e_fd, "", 1) != 1) {
898c758,759
<     buf = (void*)mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
---
>     buf = (void*)mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED,
> 		      elf->e_fd, 0);
900c761
< 	if ((char)_elf_fill && !(elf->e_elf_flags & ELF_F_LAYOUT)) {
---
> 	if ((char)_elf_fill) {
915c776
< 	if (lseek(fd, (off_t)0, SEEK_SET)) {
---
> 	if (lseek(elf->e_fd, (off_t)0, 0)) {
919c780
< 	else if (write(fd, buf, len) != len) {
---
> 	else if (write(elf->e_fd, buf, len) != len) {
961c822
< 	    len = _elf_output(elf, elf->e_fd, (size_t)len, _elf32_write);
---
> 	    len = _elf_output(elf, (size_t)len, _elf32_write);
969c830
< 	    len = _elf_output(elf, elf->e_fd, (size_t)len, _elf64_write);
---
> 	    len = _elf_output(elf, len, _elf64_write);
update.c
verdef_32_tof.c
verdef_32_tof.c
verdef_32_tom.c
verdef_32_tom.c
verdef_64_tof.c
verdef_64_tof.c
verdef_64_tom.c
verdef_64_tom.c
version.c
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
27c23
< static const char rcsid[] = "@(#) $Id: version.c 1.5 05/12/05 09:00:50-08:00 bos@eng-24.pathscale.com $";
---
> static const char rcsid[] = "@(#) $Id: version.c,v 1.1 2005/07/27 02:27:47 kevinlo Exp $";
version.c
x.movscn.c
x.movscn.c
x.remscn.c
x.remscn.c
byteswap.h
2,7c2,3
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
< byteswap.h - functions and macros for byte swapping.
< Copyright (C) 1995 - 2001 Michael Riepe <michael@stud.uni-hannover.de>
---
> byteswap.h - C preprocessor macros for byte swapping.
> Copyright (C) 1995, 1996 Michael Riepe <michael@stud.uni-hannover.de>
24c20
< /* @(#) $Id: byteswap.h 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: byteswap.h,v 1.1 2005/07/27 02:27:47 kevinlo Exp $ */
29,95c25,26
< #define lu(from,i,s)	(((__libelf_u32_t)((unsigned char*)(from))[i])<<(s))
< #define li(from,i,s)	(((__libelf_i32_t)((  signed char*)(from))[i])<<(s))
< 
< #define __load_u16L(from)	((__libelf_u32_t) \
<     (lu(from,1,8) | lu(from,0,0)))
< #define __load_u16M(from)	((__libelf_u32_t) \
<     (lu(from,0,8) | lu(from,1,0)))
< #define __load_i16L(from)	((__libelf_i32_t) \
<     (li(from,1,8) | lu(from,0,0)))
< #define __load_i16M(from)	((__libelf_i32_t) \
<     (li(from,0,8) | lu(from,1,0)))
< 
< #define __load_u32L(from)	((__libelf_u32_t) \
<     (lu(from,3,24) | lu(from,2,16) | lu(from,1,8) | lu(from,0,0)))
< #define __load_u32M(from)	((__libelf_u32_t) \
<     (lu(from,0,24) | lu(from,1,16) | lu(from,2,8) | lu(from,3,0)))
< #define __load_i32L(from)	((__libelf_i32_t) \
<     (li(from,3,24) | lu(from,2,16) | lu(from,1,8) | lu(from,0,0)))
< #define __load_i32M(from)	((__libelf_i32_t) \
<     (li(from,0,24) | lu(from,1,16) | lu(from,2,8) | lu(from,3,0)))
< 
< #define su(to,i,v,s)	(((char*)(to))[i]=((__libelf_u32_t)(v)>>(s)))
< #define si(to,i,v,s)	(((char*)(to))[i]=((__libelf_i32_t)(v)>>(s)))
< 
< #define __store_u16L(to,v)	\
<     (su(to,1,v,8), su(to,0,v,0))
< #define __store_u16M(to,v)	\
<     (su(to,0,v,8), su(to,1,v,0))
< #define __store_i16L(to,v)	\
<     (si(to,1,v,8), si(to,0,v,0))
< #define __store_i16M(to,v)	\
<     (si(to,0,v,8), si(to,1,v,0))
< 
< #define __store_u32L(to,v)	\
<     (su(to,3,v,24), su(to,2,v,16), su(to,1,v,8), su(to,0,v,0))
< #define __store_u32M(to,v)	\
<     (su(to,0,v,24), su(to,1,v,16), su(to,2,v,8), su(to,3,v,0))
< #define __store_i32L(to,v)	\
<     (si(to,3,v,24), si(to,2,v,16), si(to,1,v,8), si(to,0,v,0))
< #define __store_i32M(to,v)	\
<     (si(to,0,v,24), si(to,1,v,16), si(to,2,v,8), si(to,3,v,0))
< 
< #if __LIBELF64
< 
< /*
<  * conversion functions from swap64.c
<  */
< extern __libelf_u64_t _elf_load_u64L(const unsigned char *from);
< extern __libelf_u64_t _elf_load_u64M(const unsigned char *from);
< extern __libelf_i64_t _elf_load_i64L(const unsigned char *from);
< extern __libelf_i64_t _elf_load_i64M(const unsigned char *from);
< extern void _elf_store_u64L(unsigned char *to, __libelf_u64_t v);
< extern void _elf_store_u64M(unsigned char *to, __libelf_u64_t v);
< extern void _elf_store_i64L(unsigned char *to, __libelf_u64_t v);
< extern void _elf_store_i64M(unsigned char *to, __libelf_u64_t v);
< 
< /*
<  * aliases for existing conversion code
<  */
< #define __load_u64L	_elf_load_u64L
< #define __load_u64M	_elf_load_u64M
< #define __load_i64L	_elf_load_i64L
< #define __load_i64M	_elf_load_i64M
< #define __store_u64L	_elf_store_u64L
< #define __store_u64M	_elf_store_u64M
< #define __store_i64L	_elf_store_i64L
< #define __store_i64M	_elf_store_i64M
---
> #define lu(from,i,s)		(((long)((unsigned char*)(from))[i])<<(s))
> #define li(from,i,s)		(((long)((signed char*)(from))[i])<<(s))
97c28,73
< #endif /* __LIBELF64 */
---
> #define __load_u16L(from)	((unsigned long)(lu(from,1,8)|lu(from,0,0)))
> #define __load_u16M(from)	((unsigned long)(lu(from,0,8)|lu(from,1,0)))
> #define __load_i16L(from)	((long)(li(from,1,8)|lu(from,0,0)))
> #define __load_i16M(from)	((long)(li(from,0,8)|lu(from,1,0)))
> 
> #define __load_u32L(from)	((unsigned long)(lu(from,3,24)|	\
> 						 lu(from,2,16)|	\
> 						 lu(from,1,8)|	\
> 						 lu(from,0,0)))
> #define __load_u32M(from)	((unsigned long)(lu(from,0,24)|	\
> 						 lu(from,1,16)|	\
> 						 lu(from,2,8)|	\
> 						 lu(from,3,0)))
> #define __load_i32L(from)	((long)(li(from,3,24)|	\
> 					lu(from,2,16)|	\
> 					lu(from,1,8)|	\
> 					lu(from,0,0)))
> #define __load_i32M(from)	((long)(li(from,0,24)|	\
> 					lu(from,1,16)|	\
> 					lu(from,2,8)|	\
> 					lu(from,3,0)))
> 
> #define su(to,i,v,s)		(((char*)(to))[i]=((unsigned long)(v)>>(s)))
> #define si(to,i,v,s)		(((char*)(to))[i]=((long)(v)>>(s)))
> 
> #define __store_u16L(to,v)	(su(to,1,v,8),su(to,0,v,0))
> #define __store_u16M(to,v)	(su(to,0,v,8),su(to,1,v,0))
> #define __store_i16L(to,v)	(si(to,1,v,8),si(to,0,v,0))
> #define __store_i16M(to,v)	(si(to,0,v,8),si(to,1,v,0))
> 
> #define __store_u32L(to,v)	(su(to,3,v,24),	\
> 				 su(to,2,v,16),	\
> 				 su(to,1,v,8),	\
> 				 su(to,0,v,0))
> #define __store_u32M(to,v)	(su(to,0,v,24),	\
> 				 su(to,1,v,16),	\
> 				 su(to,2,v,8),	\
> 				 su(to,3,v,0))
> #define __store_i32L(to,v)	(si(to,3,v,24),	\
> 				 si(to,2,v,16),	\
> 				 si(to,1,v,8),	\
> 				 si(to,0,v,0))
> #define __store_i32M(to,v)	(si(to,0,v,24),	\
> 				 si(to,1,v,16),	\
> 				 si(to,2,v,8),	\
> 				 si(to,3,v,0))
byteswap.h
elf_repl.h
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2002 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
24c20
< /* @(#) $Id: elf_repl.h 1.5 05/12/05 09:00:47-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: elf_repl.h,v 1.1 2005/07/27 02:27:47 kevinlo Exp $ */
33c29
< #ifdef __cplusplus
---
> #ifdef	__cplusplus
53d48
< 
58d52
< typedef __libelf_u32_t		Elf64_Word;
59a54
> typedef __libelf_u32_t		Elf64_Word;
66d60
< #define ELF64_FSZ_WORD		4
67a62
> #define ELF64_FSZ_WORD		4
69,75d63
< 
< /*
<  * Blame Sun for this...
<  */
< typedef __libelf_u64_t		Elf64_Lword;
< typedef __libelf_u64_t		Elf32_Lword;
< 
120c108
<  * e_ident
---
>  * e-ident
129,131c117
< #define EI_OSABI	7
< #define EI_ABIVERSION	8
< #define EI_PAD		9
---
> #define EI_PAD		7
140,142d125
< /*
<  * e_ident[EI_CLASS]
<  */
148,150d130
< /*
<  * e_ident[EI_DATA]
<  */
157,178d136
<  * e_ident[EI_OSABI]
<  */
< #define ELFOSABI_NONE		0	/* No extensions or unspecified */
< #define ELFOSABI_SYSV		ELFOSABI_NONE
< #define ELFOSABI_HPUX		1	/* Hewlett-Packard HP-UX */
< #define ELFOSABI_NETBSD		2	/* NetBSD */
< #define ELFOSABI_LINUX		3	/* Linux */
< #define ELFOSABI_SOLARIS	6	/* Sun Solaris */
< #define ELFOSABI_AIX		7	/* AIX */
< #define ELFOSABI_IRIX		8	/* IRIX */
< #define ELFOSABI_FREEBSD	9	/* FreeBSD */
< #define ELFOSABI_TRU64		10	/* Compaq TRU64 UNIX */
< #define ELFOSABI_MODESTO	11	/* Novell Modesto */
< #define ELFOSABI_OPENBSD	12	/* Open BSD */
< #define ELFOSABI_OPENVMS	13	/* Open VMS */
< #define ELFOSABI_NSK		14	/* Hewlett-Packard Non-Stop Kernel */
< /* these are probably obsolete: */
< #define ELFOSABI_ARM		97	/* ARM */
< #define ELFOSABI_STANDALONE	255	/* standalone (embedded) application */
< 
< 
< /*
187,188d144
< #define ET_LOOS		0xfe00
< #define ET_HIOS		0xfeff
195,277c151,160
< #define EM_NONE		0	/* No machine */
< #define EM_M32		1	/* AT&T WE 32100 */
< #define EM_SPARC	2	/* SPARC */
< #define EM_386		3	/* Intel 80386 */
< #define EM_68K		4	/* Motorola 68000 */
< #define EM_88K		5	/* Motorola 88000 */
< #define EM_486		6	/* Intel i486 (DO NOT USE THIS ONE) */
< #define EM_860		7	/* Intel 80860 */
< #define EM_MIPS		8	/* MIPS I Architecture */
< #define EM_S370		9	/* IBM System/370 Processor */
< #define EM_MIPS_RS3_LE	10	/* MIPS RS3000 Little-endian */
< #define EM_SPARC64	11	/* SPARC 64-bit */
< #define EM_PARISC	15	/* Hewlett-Packard PA-RISC */
< #define EM_VPP500	17	/* Fujitsu VPP500 */
< #define EM_SPARC32PLUS	18	/* Enhanced instruction set SPARC */
< #define EM_960		19	/* Intel 80960 */
< #define EM_PPC		20	/* PowerPC */
< #define EM_PPC64	21	/* 64-bit PowerPC */
< #define EM_S390		22	/* IBM System/390 Processor */
< #define EM_V800		36	/* NEC V800 */
< #define EM_FR20		37	/* Fujitsu FR20 */
< #define EM_RH32		38	/* TRW RH-32 */
< #define EM_RCE		39	/* Motorola RCE */
< #define EM_ARM		40	/* Advanced RISC Machines ARM */
< #define EM_ALPHA	41	/* Digital Alpha */
< #define EM_SH		42	/* Hitachi SH */
< #define EM_SPARCV9	43	/* SPARC Version 9 */
< #define EM_TRICORE	44	/* Siemens TriCore embedded processor */
< #define EM_ARC		45	/* Argonaut RISC Core, Argonaut Technologies Inc. */
< #define EM_H8_300	46	/* Hitachi H8/300 */
< #define EM_H8_300H	47	/* Hitachi H8/300H */
< #define EM_H8S		48	/* Hitachi H8S */
< #define EM_H8_500	49	/* Hitachi H8/500 */
< #define EM_IA_64	50	/* Intel IA-64 processor architecture */
< #define EM_MIPS_X	51	/* Stanford MIPS-X */
< #define EM_COLDFIRE	52	/* Motorola ColdFire */
< #define EM_68HC12	53	/* Motorola M68HC12 */
< #define EM_MMA		54	/* Fujitsu MMA Multimedia Accelerator */
< #define EM_PCP		55	/* Siemens PCP */
< #define EM_NCPU		56	/* Sony nCPU embedded RISC processor */
< #define EM_NDR1		57	/* Denso NDR1 microprocessor */
< #define EM_STARCORE	58	/* Motorola Star*Core processor */
< #define EM_ME16		59	/* Toyota ME16 processor */
< #define EM_ST100	60	/* STMicroelectronics ST100 processor */
< #define EM_TINYJ	61	/* Advanced Logic Corp. TinyJ embedded processor family */
< #define EM_X86_64	62	/* AMD x86-64 architecture */
< #define EM_PDSP		63	/* Sony DSP Processor */
< #define EM_FX66		66	/* Siemens FX66 microcontroller */
< #define EM_ST9PLUS	67	/* STMicroelectronics ST9+ 8/16 bit microcontroller */
< #define EM_ST7		68	/* STMicroelectronics ST7 8-bit microcontroller */
< #define EM_68HC16	69	/* Motorola MC68HC16 Microcontroller */
< #define EM_68HC11	70	/* Motorola MC68HC11 Microcontroller */
< #define EM_68HC08	71	/* Motorola MC68HC08 Microcontroller */
< #define EM_68HC05	72	/* Motorola MC68HC05 Microcontroller */
< #define EM_SVX		73	/* Silicon Graphics SVx */
< #define EM_ST19		74	/* STMicroelectronics ST19 8-bit microcontroller */
< #define EM_VAX		75	/* Digital VAX */
< #define EM_CRIS		76	/* Axis Communications 32-bit embedded processor */
< #define EM_JAVELIN	77	/* Infineon Technologies 32-bit embedded processor */
< #define EM_FIREPATH	78	/* Element 14 64-bit DSP Processor */
< #define EM_ZSP		79	/* LSI Logic 16-bit DSP Processor */
< #define EM_MMIX		80	/* Donald Knuth's educational 64-bit processor */
< #define EM_HUANY	81	/* Harvard University machine-independent object files */
< #define EM_PRISM	82	/* SiTera Prism */
< #define EM_AVR		83	/* Atmel AVR 8-bit microcontroller */
< #define EM_FR30		84	/* Fujitsu FR30 */
< #define EM_D10V		85	/* Mitsubishi D10V */
< #define EM_D30V		86	/* Mitsubishi D30V */
< #define EM_V850		87	/* NEC v850 */
< #define EM_M32R		88	/* Mitsubishi M32R */
< #define EM_MN10300	89	/* Matsushita MN10300 */
< #define EM_MN10200	90	/* Matsushita MN10200 */
< #define EM_PJ		91	/* picoJava */
< #define EM_OPENRISC	92	/* OpenRISC 32-bit embedded processor */
< #define EM_ARC_A5	93	/* ARC Cores Tangent-A5 */
< #define EM_XTENSA	94	/* Tensilica Xtensa Architecture */
< #define EM_VIDEOCORE	95	/* Alphamosaic VideoCore processor */
< #define EM_TMM_GPP	96	/* Thompson Multimedia General Purpose Processor */
< #define EM_NS32K	97	/* National Semiconductor 32000 series */
< #define EM_TPC		98	/* Tenor Network TPC processor */
< #define EM_SNP1K	99	/* Trebia SNP 1000 processor */
< #define EM_ST200	100	/* STMicroelectronics (www.st.com) ST200 microcontroller */
< #define EM_NUM		101
---
> #define EM_NONE		0
> #define EM_M32		1		/* AT&T WE 32100 */
> #define EM_SPARC	2		/* SPARC */
> #define EM_386		3		/* Intel i386 */
> #define EM_68K		4		/* Motorola 68000 */
> #define EM_88K		5		/* Motorola 88000 */
> #define EM_486		6		/* Intel i486 (do not use this one) */
> #define EM_860		7		/* Intel i860 */
> #define EM_MIPS		8		/* MIPS R3000 */
> #define EM_NUM		9
324,325d206
< #define SHN_LOOS	0xff20
< #define SHN_HIOS	0xff3f
328d208
< #define SHN_XINDEX	0xffff
334,374c214,230
< #define SHT_NULL		0
< #define SHT_PROGBITS		1
< #define SHT_SYMTAB		2
< #define SHT_STRTAB		3
< #define SHT_RELA		4
< #define SHT_HASH		5
< #define SHT_DYNAMIC		6
< #define SHT_NOTE		7
< #define SHT_NOBITS		8
< #define SHT_REL			9
< #define SHT_SHLIB		10
< #define SHT_DYNSYM		11
< #define SHT_INIT_ARRAY		14
< #define SHT_FINI_ARRAY		15
< #define SHT_PREINIT_ARRAY	16
< #define SHT_GROUP		17
< #define SHT_SYMTAB_SHNDX	18
< #define SHT_NUM			19
< #define SHT_LOOS		0x60000000
< #define SHT_HIOS		0x6fffffff
< #define SHT_LOPROC		0x70000000
< #define SHT_HIPROC		0x7fffffff
< #define SHT_LOUSER		0x80000000
< #define SHT_HIUSER		0xffffffff
< 
< /*
<  * Solaris extensions
<  */
< #define SHT_SUNW_move		0x6ffffffa
< #define SHT_SUNW_COMDAT		0x6ffffffb
< #define SHT_SUNW_syminfo	0x6ffffffc
< #define SHT_SUNW_verdef		0x6ffffffd
< #define SHT_SUNW_verneed	0x6ffffffe
< #define SHT_SUNW_versym		0x6fffffff
< 
< /*
<  * GNU extensions
<  */
< #define SHT_GNU_verdef		0x6ffffffd
< #define SHT_GNU_verneed		0x6ffffffe
< #define SHT_GNU_versym		0x6fffffff
---
> #define SHT_NULL	0
> #define SHT_PROGBITS	1
> #define SHT_SYMTAB	2
> #define SHT_STRTAB	3
> #define SHT_RELA	4
> #define SHT_HASH	5
> #define SHT_DYNAMIC	6
> #define SHT_NOTE	7
> #define SHT_NOBITS	8
> #define SHT_REL		9
> #define SHT_SHLIB	10
> #define SHT_DYNSYM	11
> #define SHT_NUM		12
> #define SHT_LOPROC	0x70000000
> #define SHT_HIPROC	0x7fffffff
> #define SHT_LOUSER	0x80000000
> #define SHT_HIUSER	0xffffffff
379,397c235,238
< #define SHF_WRITE		0x1
< #define SHF_ALLOC		0x2
< #define SHF_EXECINSTR		0x4
< #define SHF_MERGE		0x10
< #define SHF_STRINGS		0x20
< #define SHF_INFO_LINK		0x40
< #define SHF_LINK_ORDER		0x80
< #define SHF_OS_NONCONFORMING	0x100
< #define SHF_GROUP		0x200
< #define SHF_TLS			0x400
< #define SHF_MASKOS		0x0ff00000
< #define SHF_MASKPROC		0xf0000000
< 
< /*
<  * Section group flags
<  */
< #define GRP_COMDAT	0x1
< #define GRP_MASKOS	0x0ff00000
< #define GRP_MASKPROC	0xf0000000
---
> #define SHF_WRITE	0x1
> #define SHF_ALLOC	0x2
> #define SHF_EXECINSTR	0x4
> #define SHF_MASKPROC	0xf0000000
434,439d274
< #if __LIBELF64
< #define ELF64_ST_BIND(i)	((i)>>4)
< #define ELF64_ST_TYPE(i)	((i)&0xf)
< #define ELF64_ST_INFO(b,t)	(((b)<<4)+((t)&0xf))
< #endif /* __LIBELF64 */
< 
447,448d281
< #define STB_LOOS	10
< #define STB_HIOS	12
460,464c293
< #define STT_COMMON	5
< #define STT_TLS		6
< #define STT_NUM		7
< #define STT_LOOS	10
< #define STT_HIOS	12
---
> #define STT_NUM		5
469,484d297
<  * Macros for manipulating st_other
<  */
< #define ELF32_ST_VISIBILITY(o)	((o)&0x3)
< #if __LIBELF64
< #define ELF64_ST_VISIBILITY(o)	((o)&0x3)
< #endif /* __LIBELF64 */
< 
< /*
<  * Symbol visibility
<  */
< #define STV_DEFAULT	0
< #define STV_INTERNAL	1
< #define STV_HIDDEN	2
< #define STV_PROTECTED	3
< 
< /*
518,523d330
< #if __LIBELF64
< #define ELF64_R_SYM(i)		((Elf64_Xword)(i)>>32)
< #define ELF64_R_TYPE(i)		((i)&0xffffffffL)
< #define ELF64_R_INFO(s,t)	(((Elf64_Xword)(s)<<32)+((t)&0xffffffffL))
< #endif /* __LIBELF64 */
< 
533,535c340
< #if __LIBELF64
< /* Solaris and GNU use this layout.  Be compatible. */
< /* XXX: Latest ELF specs say it's 64-bit?! */
---
> #if __LIBELF64 && 0	/* I don't know if this is correct */
587,590c392
< #define PT_TLS		7
< #define PT_NUM		8
< #define PT_LOOS		0x60000000
< #define PT_HIOS		0x6fffffff
---
> #define PT_NUM		7
597,598d398
< #define PF_X		0x1
< #define PF_W		0x2
600c400,401
< #define PF_MASKOS	0x0ff00000
---
> #define PF_W		0x2
> #define PF_X		0x1
627,915c428,454
< 					/* d_un   exec	 shared */
< #define DT_NULL			0	/* ign.   mand.	 mand. */
< #define DT_NEEDED		1	/* d_val  opt.	 opt.  */
< #define DT_PLTRELSZ		2	/* d_val  opt.	 opt.  */
< #define DT_PLTGOT		3	/* d_ptr  opt.	 opt.  */
< #define DT_HASH			4	/* d_ptr  mand.	 mand. */
< #define DT_STRTAB		5	/* d_ptr  mand.	 mand. */
< #define DT_SYMTAB		6	/* d_ptr  mand.	 mand. */
< #define DT_RELA			7	/* d_ptr  mand.	 opt.  */
< #define DT_RELASZ		8	/* d_val  mand.	 opt.  */
< #define DT_RELAENT		9	/* d_val  mand.	 opt.  */
< #define DT_STRSZ		10	/* d_val  mand.	 mand. */
< #define DT_SYMENT		11	/* d_val  mand.	 mand. */
< #define DT_INIT			12	/* d_ptr  opt.	 opt.  */
< #define DT_FINI			13	/* d_ptr  opt.	 opt.  */
< #define DT_SONAME		14	/* d_val  ign.	 opt.  */
< #define DT_RPATH		15	/* d_val  opt.	 ign.  */
< #define DT_SYMBOLIC		16	/* ign.   ign.	 opt.  */
< #define DT_REL			17	/* d_ptr  mand.	 opt.  */
< #define DT_RELSZ		18	/* d_val  mand.	 opt.  */
< #define DT_RELENT		19	/* d_val  mand.	 opt.  */
< #define DT_PLTREL		20	/* d_val  opt.	 opt.  */
< #define DT_DEBUG		21	/* d_ptr  opt.	 ign.  */
< #define DT_TEXTREL		22	/* ign.   opt.	 opt.  */
< #define DT_JMPREL		23	/* d_ptr  opt.	 opt.  */
< #define DT_BIND_NOW		24	/* ign.   opt.	 opt.  */
< #define DT_INIT_ARRAY		25	/* d_ptr  opt.	 opt.  */
< #define DT_FINI_ARRAY		26	/* d_ptr  opt.	 opt.  */
< #define DT_INIT_ARRAYSZ		27	/* d_val  opt.	 opt.  */
< #define DT_FINI_ARRAYSZ		28	/* d_val  opt.	 opt.  */
< #define DT_RUNPATH		29	/* d_val  opt.	 opt.  */
< #define DT_FLAGS		30	/* d_val  opt.	 opt.  */
< #define DT_ENCODING		32	/* odd/even encoding rule starts here */
< #define DT_PREINIT_ARRAY	32	/* d_ptr  opt.	 ign.  */
< #define DT_PREINIT_ARRAYSZ	33	/* d_val  opt.	 ign.  */
< #define DT_NUM			34
< #define DT_LOOS			0x6000000D
< #define DT_HIOS			0x6ffff000
< #define DT_LOPROC		0x70000000
< #define DT_HIPROC		0x7fffffff
< 
< /*
<  * DT_FLAGS values
<  */
< #define DF_ORIGIN	0x1
< #define DF_SYMBOLIC	0x2
< #define DF_TEXTREL	0x4
< #define DF_BIND_NOW	0x8
< #define DF_STATIC_TLS	0x10
< 
< /*
<  * Solaris extensions
<  */
< #define DT_VALRNGLO	0x6ffffd00
< #define DT_CHECKSUM	0x6ffffdf8
< #define DT_PLTPADSZ	0x6ffffdf9
< #define DT_MOVEENT	0x6ffffdfa
< #define DT_MOVESZ	0x6ffffdfb
< #define DT_FEATURE_1	0x6ffffdfc
< #define DT_POSFLAG_1	0x6ffffdfd
< #define DT_SYMINSZ	0x6ffffdfe
< #define DT_SYMINENT	0x6ffffdff
< #define DT_VALRNGHI	0x6ffffdff
< 
< #define DT_ADDRRNGLO	0x6ffffe00
< #define DT_CONFIG	0x6ffffefa
< #define DT_DEPAUDIT	0x6ffffefb
< #define DT_AUDIT	0x6ffffefc
< #define DT_PLTPAD	0x6ffffefd
< #define DT_MOVETAB	0x6ffffefe
< #define DT_SYMINFO	0x6ffffeff
< #define DT_ADDRRNGHI	0x6ffffeff
< 
< #define DT_RELACOUNT	0x6ffffff9
< #define DT_RELCOUNT	0x6ffffffa
< #define DT_FLAGS_1	0x6ffffffb
< #define DT_VERDEF	0x6ffffffc
< #define DT_VERDEFNUM	0x6ffffffd
< #define DT_VERNEED	0x6ffffffe
< #define DT_VERNEEDNUM	0x6fffffff
< 
< #define DT_AUXILIARY	0x7ffffffd
< #define DT_USED		0x7ffffffe
< #define DT_FILTER	0x7fffffff
< 
< /*
<  * GNU extensions
<  */
< #define DT_VERSYM	0x6ffffff0
< 
< /*
<  * DT_FEATURE_1 values
<  */
< #define DTF_1_PARINIT	0x1
< #define DTF_1_CONFEXP	0x2
< 
< /*
<  * DT_POSFLAG_1 values
<  */
< #define DF_P1_LAZYLOAD	0x1
< #define DF_P1_GROUPPERM	0x2
< 
< /*
<  * DT_FLAGS_1 values
<  */
< #define DF_1_NOW	0x00000001
< #define DF_1_GLOBAL	0x00000002
< #define DF_1_GROUP	0x00000004
< #define DF_1_NODELETE	0x00000008
< #define DF_1_LOADFLTR	0x00000010
< #define DF_1_INITFIRST	0x00000020
< #define DF_1_NOOPEN	0x00000040
< #define DF_1_ORIGIN	0x00000080
< #define DF_1_DIRECT	0x00000100
< #define DF_1_TRANS	0x00000200
< #define DF_1_INTERPOSE	0x00000400
< #define DF_1_NODEFLIB	0x00000800
< #define DF_1_NODUMP	0x00001000
< #define DF_1_CONFALT	0x00002000
< #define DF_1_ENDFILTEE	0x00004000
< #define DF_1_DISPRELDNE	0x00008000
< #define DF_1_DISPRELPND	0x00010000
< 
< /*
<  * Syminfo structure
<  */
< typedef struct {
<     Elf32_Half		si_boundto;
<     Elf32_Half		si_flags;
< } Elf32_Syminfo;
< 
< #if __LIBELF64
< typedef struct {
<     Elf64_Half		si_boundto;
<     Elf64_Half		si_flags;
< } Elf64_Syminfo;
< #endif /* __LIBELF64 */
< 
< /*
<  * Syminfo version (stored in unused first entry)
<  */
< #define SYMINFO_NONE	0
< #define SYMINFO_CURRENT	1
< #define SYMINFO_NUM	2
< 
< /*
<  * si_boundto special values
<  */
< #define SYMINFO_BT_LOWRESERVE	0xff00
< #define SYMINFO_BT_PARENT	0xfffe	/* bound to parent */
< #define SYMINFO_BT_SELF		0xffff	/* bound to self */
< 
< /*
<  * si_flags
<  */
< #define SYMINFO_FLG_DIRECT	0x01	/* bound to an object */
< #define SYMINFO_FLG_PASSTHRU	0x02	/* pass-thru symbol */
< #define SYMINFO_FLG_COPY	0x04	/* result of a copy relocation */
< #define SYMINFO_FLG_LAZYLOAD	0x08	/* bound to lazy-loaded object */
< 
< /*
<  * Version definitions
<  */
< typedef struct {
<     Elf32_Half		vd_version;
<     Elf32_Half		vd_flags;
<     Elf32_Half		vd_ndx;
<     Elf32_Half		vd_cnt;
<     Elf32_Word		vd_hash;
<     Elf32_Word		vd_aux;
<     Elf32_Word		vd_next;
< } Elf32_Verdef;
< 
< typedef struct {
<     Elf32_Word		vda_name;
<     Elf32_Word		vda_next;
< } Elf32_Verdaux;
< 
< typedef struct {
<     Elf32_Half		vn_version;
<     Elf32_Half		vn_cnt;
<     Elf32_Word		vn_file;
<     Elf32_Word		vn_aux;
<     Elf32_Word		vn_next;
< } Elf32_Verneed;
< 
< typedef struct {
<     Elf32_Word		vna_hash;
<     Elf32_Half		vna_flags;
<     Elf32_Half		vna_other;
<     Elf32_Word		vna_name;
<     Elf32_Word		vna_next;
< } Elf32_Vernaux;
< 
< typedef Elf32_Half	Elf32_Versym;
< 
< #if __LIBELF64
< 
< typedef struct {
<     Elf64_Half		vd_version;
<     Elf64_Half		vd_flags;
<     Elf64_Half		vd_ndx;
<     Elf64_Half		vd_cnt;
<     Elf64_Word		vd_hash;
<     Elf64_Word		vd_aux;
<     Elf64_Word		vd_next;
< } Elf64_Verdef;
< 
< typedef struct {
<     Elf64_Word		vda_name;
<     Elf64_Word		vda_next;
< } Elf64_Verdaux;
< 
< typedef struct {
<     Elf64_Half		vn_version;
<     Elf64_Half		vn_cnt;
<     Elf64_Word		vn_file;
<     Elf64_Word		vn_aux;
<     Elf64_Word		vn_next;
< } Elf64_Verneed;
< 
< typedef struct {
<     Elf64_Word		vna_hash;
<     Elf64_Half		vna_flags;
<     Elf64_Half		vna_other;
<     Elf64_Word		vna_name;
<     Elf64_Word		vna_next;
< } Elf64_Vernaux;
< 
< typedef Elf64_Half	Elf64_Versym;
< 
< #endif /* __LIBELF64 */
< 
< /*
<  * vd_version
<  */
< #define VER_DEF_NONE	0
< #define VER_DEF_CURRENT	1
< #define VER_DEF_NUM	2
< 
< /*
<  * vn_version
<  */
< #define VER_NEED_NONE		0
< #define VER_NEED_CURRENT	1
< #define VER_NEED_NUM		2
< 
< /*
<  * vd_flags / vna_flags
<  */
< #define VER_FLG_BASE	0x1	/* vd_flags only */
< #define VER_FLG_WEAK	0x2
< 
< /*
<  * Elf*_Versym special values
<  */
< #define VER_NDX_LOCAL	0
< #define VER_NDX_GLOBAL	1
< 
< /*
<  * Move section
<  */
< #if __LIBELF64
< 
< typedef struct {
<     Elf32_Lword		m_value;
<     Elf32_Word		m_info;
<     Elf32_Word		m_poffset;
<     Elf32_Half		m_repeat;
<     Elf32_Half		m_stride;
< } Elf32_Move;
< 
< typedef struct {
<     Elf64_Lword		m_value;
<     Elf64_Xword		m_info;
<     Elf64_Xword		m_poffset;
<     Elf64_Half		m_repeat;
<     Elf64_Half		m_stride;
< } Elf64_Move;
< 
< #define ELF32_M_SYM(info)	((info)>>8)
< #define ELF32_M_SIZE(info)	((unsigned char)(info))
< #define ELF32_M_INFO(sym, sz)	(((sym)<<8)+(unsigned char)(sz))
< 
< #define ELF64_M_SYM(info)	((Elf64_Xword)(info)>>8)
< #define ELF64_M_SIZE(info)	((unsigned char)(info))
< #define ELF64_M_INFO(sym, sz)	(((Elf64_Xword)(sym)<<8)+(unsigned char)(sz))
< 
< #endif /* __LIBELF64 */
---
> #define DT_NULL		0
> #define DT_NEEDED	1
> #define DT_PLTRELSZ	2
> #define DT_PLTGOT	3
> #define DT_HASH		4
> #define DT_STRTAB	5
> #define DT_SYMTAB	6
> #define DT_RELA		7
> #define DT_RELASZ	8
> #define DT_RELAENT	9
> #define DT_STRSZ	10
> #define DT_SYMENT	11
> #define DT_INIT		12
> #define DT_FINI		13
> #define DT_SONAME	14
> #define DT_RPATH	15
> #define DT_SYMBOLIC	16
> #define DT_REL		17
> #define DT_RELSZ	18
> #define DT_RELENT	19
> #define DT_PLTREL	20
> #define DT_DEBUG	21
> #define DT_TEXTREL	22
> #define DT_JMPREL	23
> #define DT_NUM		24
> #define DT_LOPROC	0x70000000
> #define DT_HIPROC	0x7fffffff
917c456
< #ifdef __cplusplus
---
> #ifdef	__cplusplus
elf_repl.h
errors.h
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2003 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
24c20
< /* @(#) $Id: errors.h 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: errors.h,v 1.1 2005/07/27 02:27:47 kevinlo Exp $ */
75a72
> __err__(ERROR_SCN2SMALL,	_("Format error: section size too small for data"))
78,85d74
< __err__(ERROR_VERDEF_FORMAT,	_("Format error: bad parameter in Verdef record"))
< __err__(ERROR_VERDEF_VERSION,	_("Format error: unknown Verdef version"))
< __err__(ERROR_VERNEED_FORMAT,	_("Format error: bad parameter in Verneed record"))
< __err__(ERROR_VERNEED_VERSION,	_("Format error: unknown Verneed version"))
< __err__(ERROR_EHDR_SHNUM,	_("Format error: bad e_shnum value"))
< __err__(ERROR_UNTERM,		_("Format error: unterminated string in string table"))
< __err__(ERROR_SCN2SMALL,	_("Layout error: section size too small for data"))
< __err__(ERROR_SCN_OVERLAP,	_("Layout error: overlapping sections"))
95,102d83
< __err__(ERROR_MEM_TEMPORARY,    _("Memory error: temporary buffer"))
< __err__(ERROR_BADVALUE,		_("GElf error: value out of range"))
< __err__(ERROR_BADINDEX,		_("GElf error: index out of range"))
< __err__(ERROR_BADTYPE,		_("GElf error: type mismatch"))
< __err__(ERROR_MEM_SYM,		_("GElf error: not enough memory for GElf_Sym"))
< __err__(ERROR_MEM_DYN,		_("GElf error: not enough memory for GElf_Dyn"))
< __err__(ERROR_MEM_RELA,		_("GElf error: not enough memory for GElf_Rela"))
< __err__(ERROR_MEM_REL,		_("GElf error: not enough memory for GElf_Rel"))
errors.h
ext_types.h
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
24c20
< /* @(#) $Id: ext_types.h 1.5 05/12/05 09:00:48-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: ext_types.h,v 1.1 2005/07/27 02:27:47 kevinlo Exp $ */
36,40c32,36
< typedef unsigned char __ext_Elf32_Addr  [ELF32_FSZ_ADDR];
< typedef unsigned char __ext_Elf32_Half  [ELF32_FSZ_HALF];
< typedef unsigned char __ext_Elf32_Off   [ELF32_FSZ_OFF];
< typedef unsigned char __ext_Elf32_Sword [ELF32_FSZ_SWORD];
< typedef unsigned char __ext_Elf32_Word  [ELF32_FSZ_WORD];
---
> typedef unsigned char __ext_Elf32_Addr	[ELF32_FSZ_ADDR];
> typedef unsigned char __ext_Elf32_Half	[ELF32_FSZ_HALF];
> typedef unsigned char __ext_Elf32_Off	[ELF32_FSZ_OFF];
> typedef unsigned char __ext_Elf32_Sword	[ELF32_FSZ_SWORD];
> typedef unsigned char __ext_Elf32_Word	[ELF32_FSZ_WORD];
43,48c39,41
< 
< typedef unsigned char __ext_Elf32_Lword [8];
< 
< typedef unsigned char __ext_Elf64_Addr  [ELF64_FSZ_ADDR];
< typedef unsigned char __ext_Elf64_Half  [ELF64_FSZ_HALF];
< typedef unsigned char __ext_Elf64_Off   [ELF64_FSZ_OFF];
---
> typedef unsigned char __ext_Elf64_Addr	[ELF64_FSZ_ADDR];
> typedef unsigned char __ext_Elf64_Half	[ELF64_FSZ_HALF];
> typedef unsigned char __ext_Elf64_Off	[ELF64_FSZ_OFF];
50d42
< typedef unsigned char __ext_Elf64_Word  [ELF64_FSZ_WORD];
51a44
> typedef unsigned char __ext_Elf64_Word	[ELF64_FSZ_WORD];
53,55d45
< 
< typedef unsigned char __ext_Elf64_Lword [8];
< 
242,334c232
< /*
<  * Version definitions
<  */
< typedef struct {
<     __ext_Elf32_Half	vd_version;
<     __ext_Elf32_Half	vd_flags;
<     __ext_Elf32_Half	vd_ndx;
<     __ext_Elf32_Half	vd_cnt;
<     __ext_Elf32_Word	vd_hash;
<     __ext_Elf32_Word	vd_aux;
<     __ext_Elf32_Word	vd_next;
< } __ext_Elf32_Verdef;
< 
< typedef struct {
<     __ext_Elf32_Word	vda_name;
<     __ext_Elf32_Word	vda_next;
< } __ext_Elf32_Verdaux;
< 
< typedef struct {
<     __ext_Elf32_Half	vn_version;
<     __ext_Elf32_Half	vn_cnt;
<     __ext_Elf32_Word	vn_file;
<     __ext_Elf32_Word	vn_aux;
<     __ext_Elf32_Word	vn_next;
< } __ext_Elf32_Verneed;
< 
< typedef struct {
<     __ext_Elf32_Word	vna_hash;
<     __ext_Elf32_Half	vna_flags;
<     __ext_Elf32_Half	vna_other;
<     __ext_Elf32_Word	vna_name;
<     __ext_Elf32_Word	vna_next;
< } __ext_Elf32_Vernaux;
< 
< #if __LIBELF64
< 
< typedef struct {
<     __ext_Elf64_Half	vd_version;
<     __ext_Elf64_Half	vd_flags;
<     __ext_Elf64_Half	vd_ndx;
<     __ext_Elf64_Half	vd_cnt;
<     __ext_Elf64_Word	vd_hash;
<     __ext_Elf64_Word	vd_aux;
<     __ext_Elf64_Word	vd_next;
< } __ext_Elf64_Verdef;
< 
< typedef struct {
<     __ext_Elf64_Word	vda_name;
<     __ext_Elf64_Word	vda_next;
< } __ext_Elf64_Verdaux;
< 
< typedef struct {
<     __ext_Elf64_Half	vn_version;
<     __ext_Elf64_Half	vn_cnt;
<     __ext_Elf64_Word	vn_file;
<     __ext_Elf64_Word	vn_aux;
<     __ext_Elf64_Word	vn_next;
< } __ext_Elf64_Verneed;
< 
< typedef struct {
<     __ext_Elf64_Word	vna_hash;
<     __ext_Elf64_Half	vna_flags;
<     __ext_Elf64_Half	vna_other;
<     __ext_Elf64_Word	vna_name;
<     __ext_Elf64_Word	vna_next;
< } __ext_Elf64_Vernaux;
< 
< #endif /* __LIBELF64 */
< 
< /*
<  * Move section
<  */
< #if __LIBELF64
< 
< typedef struct {
<     __ext_Elf32_Lword	m_value;
<     __ext_Elf32_Word	m_info;
<     __ext_Elf32_Word	m_poffset;
<     __ext_Elf32_Half	m_repeat;
<     __ext_Elf32_Half	m_stride;
< } __ext_Elf32_Move;
< 
< typedef struct {
<     __ext_Elf64_Lword	m_value;
<     __ext_Elf64_Xword	m_info;
<     __ext_Elf64_Xword	m_poffset;
<     __ext_Elf64_Half	m_repeat;
<     __ext_Elf64_Half	m_stride;
< } __ext_Elf64_Move;
< 
< #endif /* __LIBELF64 */
< 
< #ifdef __cplusplus
---
> #ifdef	__cplusplus
ext_types.h
gelf.h
gelf.h
libelf.h
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2003 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
24c20
< /* @(#) $Id: libelf.h 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: libelf.h,v 1.1 2005/07/27 02:27:47 kevinlo Exp $ */
67,68c63,64
< #define ELF_F_DIRTY	0x1
< #define ELF_F_LAYOUT	0x4
---
> #define	ELF_F_DIRTY	0x1
> #define	ELF_F_LAYOUT	0x4
107,112d102
<     /*
<      * Symbol versioning.  Sun broke binary compatibility (again!),
<      * but I won't.
<      */
<     ELF_T_VDEF,
<     ELF_T_VNEED,
193c183
< extern unsigned long elf_hash __P((const unsigned char *__name));
---
> extern unsigned long elf_hash __P((const char *__name));
213,217d202
< /*
<  * Additional functions found on Solaris
<  */
< extern long elf32_checksum __P((Elf *__elf));
< 
234,239d218
< 
< /*
<  * Additional functions found on Solaris
<  */
< extern long elf64_checksum __P((Elf *__elf));
< 
243,260c222,224
<  * Experimental extensions:
<  *
<  * elfx_movscn() moves section `__scn' directly after section `__after'.
<  * elfx_remscn() removes section `__scn'.  Both functions update
<  * the section indices; elfx_remscn() also adjusts the ELF header's
<  * e_shnum member.  The application is responsible for updating other
<  * data (in particular, e_shstrndx and the section headers' sh_link and
<  * sh_info members).
<  *
<  * elfx_movscn() returns the new index of the moved section.
<  * elfx_remscn() returns the original index of the removed section.
<  * A return value of zero indicates an error.
<  */
< extern size_t elfx_movscn __P((Elf *__elf, Elf_Scn *__scn, Elf_Scn *__after));
< extern size_t elfx_remscn __P((Elf *__elf, Elf_Scn *__scn));
< 
< /*
<  * elf_delscn() is obsolete.  Please use elfx_remscn() instead.
---
>  * More function declarations
>  * These functions are NOT available
>  * in the SYSV version of libelf!
libelf.h
nlist.h
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
24c20
< /* @(#) $Id: nlist.h 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: nlist.h,v 1.1 2005/07/27 02:27:46 kevinlo Exp $ */
nlist.h
private.h
2,5d1
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
< /*
7c3
< Copyright (C) 1995 - 2003 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1995 - 1998 Michael Riepe <michael@stud.uni-hannover.de>
24c20
< /* @(#) $Id: private.h 1.5 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: private.h,v 1.1 2005/07/27 02:27:46 kevinlo Exp $ */
41,42c37,38
< extern void *malloc(), *realloc();
< extern void free(), bcopy(), abort();
---
> extern char *malloc(), *realloc();
> extern void free(), bcopy();
50c46
< extern int read(), write(), close();
---
> extern int read(), write();
52,54d47
< #if HAVE_FTRUNCATE
< extern int ftruncate();
< #endif /* HAVE_FTRUNCATE */
57,66d49
< #ifndef SEEK_SET
< #define SEEK_SET	0
< #endif /* SEEK_SET */
< #ifndef SEEK_CUR
< #define SEEK_CUR	1
< #endif /* SEEK_CUR */
< #ifndef SEEK_END
< #define SEEK_END	2
< #endif /* SEEK_END */
< 
86c69
< #if __LIBELF_NEED_LINK_H
---
> #if NEED_LINK_H
88c71
< #endif /* __LIBELF_NEED_LINK_H */
---
> #endif /* NEED_LINK_H */
96,99d78
< #if __LIBELF64
< #include <gelf.h>
< #endif /* __LIBELF64 */
< 
255d233
<     Elf_Scn*	sd_scn;			/* pointer to section */
277d254
<     /* sd_scn */	NULL,\
299,324c276
< extern char *_elf_getphdr __P((Elf*, unsigned));
< extern Elf_Data *_elf_xlatetom __P((const Elf*, Elf_Data*, const Elf_Data*));
< extern Elf_Type _elf_scn_type __P((unsigned));
< extern size_t _elf32_xltsize __P((const Elf_Data *__src, unsigned __dv, unsigned __encode, int __tof));
< extern size_t _elf64_xltsize __P((const Elf_Data *__src, unsigned __dv, unsigned __encode, int __tof));
< extern int _elf_update_shnum(Elf *__elf, size_t __shnum);
< 
< /*
<  * Special translators
<  */
< extern size_t _elf_verdef_32L11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verdef_32L11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verdef_32M11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verdef_32M11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verdef_64L11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verdef_64L11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verdef_64M11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verdef_64M11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_32L11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_32L11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_32M11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_32M11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_64L11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_64L11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_64M11_tof __P((unsigned char *dst, const unsigned char *src, size_t n));
< extern size_t _elf_verneed_64M11_tom __P((unsigned char *dst, const unsigned char *src, size_t n));
---
> extern Elf_Data *_elf_xlatetom(const Elf*, Elf_Data*, const Elf_Data*);
330a283
> extern const Elf_Type _elf_scn_types[SHT_NUM];
347a301
> #define valid_scntype(s)	((s) >= SHT_NULL && (s) < SHT_NUM)
383c337
<  * More missing pieces, in no particular order
---
>  * Alignment
385,387c339,342
< #ifndef SHT_SYMTAB_SHNDX
< #define SHT_SYMTAB_SHNDX	18
< #endif
---
> #define _ELF32_ALIGN_PHDR	4
> #define _ELF32_ALIGN_SHDR	4
> #define _ELF64_ALIGN_PHDR	8
> #define _ELF64_ALIGN_SHDR	8
393c348
< extern void __elf_assert __P((const char*, unsigned, const char*));
---
> # include <stdio.h>
395c350
< #  define elf_assert(x)	do{if(!(x))__elf_assert(__FILE__,__LINE__,#x);}while(0)
---
> #  define elf_assert(x)	((void)((x)||__elf_assert(__FILE__,__LINE__,#x)))
397c352
< #  define elf_assert(x)	do{if(!(x))__elf_assert(__FILE__,__LINE__,"x");}while(0)
---
> #  define elf_assert(x)	((void)((x)||__elf_assert(__FILE__,__LINE__,"x")))
398a354,355
> # define __elf_assert(f,l,x)	(fprintf(stderr,\
> 	"%s:%u: libelf assertion failure: %s\n",(f),(l),(x)),abort(),0)
400c357
< # define elf_assert(x)	do{}while(0)
---
> # define elf_assert(x)	((void)0)
private.h
sys_elf.h
1,4d0
< /*
<  * Copyright 2005, 2006 PathScale, Inc.  All Rights Reserved.
<  */
< 
8c4
< Copyright (C) 1998 - 2001 Michael Riepe <michael@stud.uni-hannover.de>
---
> Copyright (C) 1998 Michael Riepe <michael@stud.uni-hannover.de>
25c21
< /* @(#) $Id: sys_elf.h 1.7 05/12/05 09:00:49-08:00 bos@eng-24.pathscale.com $ */
---
> /* @(#) $Id: sys_elf.h,v 1.1 2005/07/27 02:27:47 kevinlo Exp $ */
34,36d29
< /* Define if Elf32_Dyn is declared in <link.h> */
< /* #undef __LIBELF_NEED_LINK_H */
< 
46,48d38
< /* Define if you want symbol versioning (and your system supports it) */
< #define __LIBELF_SYMBOL_VERSIONS 1
< 
56c46
< #define __libelf_i32_t int
---
> #define __libelf_i32_t long
59c49
< #define __libelf_u32_t unsigned int
---
> #define __libelf_u32_t unsigned long
81c71
<  * On some systems, <elf.h> is severely broken.  Try to fix it.
---
>  * Workaround for broken <elf.h> on Linux...
83,121c73
< #ifdef __LIBELF_HEADER_ELF_H
< 
< # ifndef ELF32_FSZ_ADDR
< #  define ELF32_FSZ_ADDR	4
< #  define ELF32_FSZ_HALF	2
< #  define ELF32_FSZ_OFF		4
< #  define ELF32_FSZ_SWORD	4
< #  define ELF32_FSZ_WORD	4
< # endif /* ELF32_FSZ_ADDR */
< 
< # ifndef STN_UNDEF
< #  define STN_UNDEF	0
< # endif /* STN_UNDEF */
< 
< # if __LIBELF64
< 
< #  ifndef ELF64_FSZ_ADDR
< #   define ELF64_FSZ_ADDR	8
< #   define ELF64_FSZ_HALF	2
< #   define ELF64_FSZ_OFF	8
< #   define ELF64_FSZ_SWORD	4
< #   define ELF64_FSZ_WORD	4
< #   define ELF64_FSZ_SXWORD	8
< #   define ELF64_FSZ_XWORD	8
< #  endif /* ELF64_FSZ_ADDR */
< 
< #  ifndef ELF64_ST_BIND
< #   define ELF64_ST_BIND(i)	((i)>>4)
< #   define ELF64_ST_TYPE(i)	((i)&0xf)
< #   define ELF64_ST_INFO(b,t)	(((b)<<4)+((t)&0xf))
< #  endif /* ELF64_ST_BIND */
< 
< #  ifndef ELF64_R_SYM
< #   define ELF64_R_SYM(i)	((Elf64_Xword)(i)>>32)
< #   define ELF64_R_TYPE(i)	((i)&0xffffffffL)
< #   define ELF64_R_INFO(s,t)	(((Elf64_Xword)(s)<<32)+((t)&0xffffffffL))
< #  endif /* ELF64_R_SYM */
< 
< #  if __LIBELF64_LINUX
---
> #if __LIBELF64 && __LIBELF64_LINUX
126d77
< typedef __libelf_u32_t	Elf64_Word;
127a79
> typedef __libelf_u32_t	Elf64_Word;
129,132c81
< #  endif /* __LIBELF64_LINUX */
< 
< # endif /* __LIBELF64 */
< #endif /* __LIBELF_HEADER_ELF_H */
---
> #endif /* __LIBELF64 && __LIBELF64_LINUX */
sys_elf.h
verdef.h
verdef.h
verneed.h
verneed.h
