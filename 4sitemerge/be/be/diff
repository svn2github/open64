cleanup.cxx
40,43c40,43
<  * $Revision: 1.2 $
<  * $Date: 02/11/07 23:41:17-00:00 $
<  * $Author: fchow@keyresearch.com $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.cleanup.cxx $
---
>  * $Revision$
>  * $Date$
>  * $Author$
>  * $Source$
74d73
< #ifdef BUILD_PROMPF
76d74
< #endif
95d92
< #ifdef BUILD_PROMPF
98d94
< #endif
cleanup.cxx
dra_clone.cxx
dra_clone.cxx
dra_ec.cxx
90,94d89
< #ifdef TARG_IA64
<   OPC_F10F10LDID, /* MTYPE_F10 */
< #else
<   OPC_UNKNOWN,    /* MTYPE_F10 */
< #endif
103,109c98
<   OPC_UNKNOWN,     /* MTYPE_V */
<   OPC_UNKNOWN,    /* MTYPE_BS */
<   OPC_UNKNOWN,    /* MTYPE_A4 */
<   OPC_UNKNOWN,    /* MTYPE_A8 */
< #ifdef TARG_IA64
<   OPC_C10C10LDID, /* MTYPE_C10 */
< #endif
---
>   OPC_UNKNOWN     /* MTYPE_V */
dra_ec.cxx
dra_file_util.cxx
53,55d52
< #ifdef __MINGW32__
< #include <windows.h>
< #else
57d53
< #endif /* __MINGW32__ */
82,84d77
< #ifdef __MINGW32__
< HANDLE DRA_file_mmap_handle = NULL;
< #endif /* __MINGW32__ */
147,161d139
< #ifdef __MINGW32__
<   DRA_file_mmap = NULL;
<   DRA_file_mmap_handle =
< 	CreateFileMapping((HANDLE) _get_osfhandle(DRA_file_desc), NULL,
< 			  PAGE_READWRITE, 0, stat_buf.st_size, DRA_file_name);
<   if (DRA_file_mmap_handle)
< 	DRA_file_mmap = (char *) MapViewOfFileEx(DRA_file_mmap_handle,
< 						 FILE_MAP_COPY,
< 						 0, 0, stat_buf.st_size, 0);
<   if (DRA_file_mmap == NULL) {
< 	close(DRA_file_desc);
< 	ErrMsg(EC_DRA_rii_file_io, DRA_file_name, GetLastError());
< 	return;
<   }
< #else
174d151
< #endif /* __MINGW32__ */
263,266d239
< #ifdef __MINGW32__
<   (void) UnmapViewOfFile(DRA_file_mmap);
<   (void) CloseHandle(DRA_file_mmap_handle);
< #else
268d240
< #endif /* __MINGW32__ */
dra_file_util.cxx
dra_mangle.cxx
76c76
< #if defined(__linux__) || defined(BUILD_OS_DARWIN) || !defined(SHARED_BUILD)
---
> #if defined(__linux__) || defined(BUILD_OS_DARWIN)
dra_mangle.cxx
driver.cxx
1a2,9
>  * Copyright 2007, 2008 PathScale, LLC.  All Rights Reserved.
>  */
> 
> /*
>  *  Copyright (C) 2006. QLogic Corporation. All Rights Reserved.
>  */
> 
> /*
44c52
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.driver.cxx $
---
>  * $Source: be/be/SCCS/s.driver.cxx $
62d69
< #ifndef __MINGW32__
64d70
< #endif
67,69d72
< #if !defined(SHARED_BUILD)
< #define load_so(a,b,c)
< #else
71d73
< #endif
73d74
< #include "err_host.tab"		    /* load all the error messages */
75d75
< #include "erauxdesc.h"		    /* for BE error messages */
90a91
> #include "config_cache.h"           /* for Mhd and Mhd_Options */
100d100
< #ifndef BUILD_SKIP_LNO
103,104d102
< #endif
< #ifndef BUILD_SKIP_WHIRL2C
106,107d103
< #endif
< #ifndef BUILD_SKIP_WHIRL2F
109,110d104
< #endif
< #ifndef BUILD_SKIP_PURPLE
112,113d105
< #endif
< #ifndef BUILD_SKIP_PROMPF
115d106
< #endif
149,155c140,141
< #include "be_memop_annot.h"
< #ifdef TARG_SL
< #include <dlfcn.h>
< #include "topcode.h"
< #include "ti_si.h"
< #include "isr.h"
< #endif
---
> 
> extern ERROR_DESC EDESC_BE[], EDESC_CG[];
161a148
> extern void CYG_Instrument_Driver(WN *);
168,173d154
< #if !defined(BUILD_FAST_BIN)
< extern void (*CG_Process_Command_Line_p) (INT, char **, INT, char **);
< #define CG_Process_Command_Line (*CG_Process_Command_Line_p)
< 
< extern void (*CG_Init_p) ();
< #define CG_Init (*CG_Init_p)
175,193d155
< extern void (*CG_Fini_p) ();
< #define CG_Fini (*CG_Fini_p)
< 
< extern void (*CG_PU_Initialize_p) (WN*);
< #define CG_PU_Initialize (*CG_PU_Initialize_p)
< 
< extern void (*CG_PU_Finalize_p) ();
< #define CG_PU_Finalize (*CG_PU_Finalize_p)
< 
< extern WN* (*CG_Generate_Code_p) (WN*, ALIAS_MANAGER*, DST_IDX, BOOL);
< #define CG_Generate_Code (*CG_Generate_Code_p)
< 
< extern void (*EH_Generate_Range_List_p) (WN *);
< #define EH_Generate_Range_List (*EH_Generate_Range_List_p)
< 
< // used to dump information of EH related INITO
< extern void (*EH_Dump_INITOs_p) (WN *, FILE *);
< #define EH_Dump_INITOs (*EH_Dump_INITOs_p)
< #else
201d162
< #endif
216,247d176
< #ifdef TARG_SL
< extern INT *SI_resource_count_p;
< #define SI_resource_count (*SI_resource_count_p)
< extern SI_RESOURCE* (*SI_resources_p)[];
< #define SI_resources (*SI_resources_p)
< extern SI* (*SI_top_si_p)[];
< #define SI_top_si (*SI_top_si_p)
< extern SI_RRW *SI_RRW_initializer_p;
< #define SI_RRW_initializer (*SI_RRW_initializer_p)
< extern SI_RRW *SI_RRW_overuse_mask_p;
< #define SI_RRW_overuse_mask (*SI_RRW_overuse_mask_p)
< extern INT *SI_issue_slot_count_p;
< #define SI_issue_slot_count (*SI_issue_slot_count_p)
< extern SI_ISSUE_SLOT *(*SI_issue_slots_p)[];
< #define SI_issue_slots (*SI_issue_slots_p)
< extern INT *SI_ID_count_p;
< #define SI_ID_count (*SI_ID_count_p)
< extern SI *(*SI_ID_si_p)[];
< #define SI_ID_si (*SI_ID_si_p)
< #else
< 
< #pragma weak CG_Process_Command_Line
< #pragma weak CG_Init
< #pragma weak CG_Fini
< #pragma weak CG_PU_Finalize
< #pragma weak CG_PU_Initialize
< #pragma weak CG_Generate_Code
< #pragma weak EH_Generate_Range_List
< 
< 
< #endif // __linux__
< 
251,278d179
< #if !defined(BUILD_FAST_BIN)
< extern void (*wopt_main_p) (INT argc, char **argv, INT, char **);
< #define wopt_main (*wopt_main_p)
< 
< extern void (*Wopt_Init_p) ();
< #define Wopt_Init (*Wopt_Init_p)
< 
< extern void (*Wopt_Fini_p) ();
< #define Wopt_Fini (*Wopt_Fini_p)
< 
< extern WN* (*Perform_Preopt_Optimization_p) (WN *, WN *);
< #define Perform_Preopt_Optimization (*Perform_Preopt_Optimization_p)
< 
< extern WN* (*Perform_Global_Optimization_p) (WN *, WN *, ALIAS_MANAGER *);
< #define Perform_Global_Optimization (*Perform_Global_Optimization_p)
< 
< extern WN* (*Pre_Optimizer_p) (INT32, WN*, DU_MANAGER*, ALIAS_MANAGER*);
< #define Pre_Optimizer (*Pre_Optimizer_p)
< 
< extern DU_MANAGER* (*Create_Du_Manager_p) (MEM_POOL *);
< #define Create_Du_Manager (*Create_Du_Manager_p)
< 
< extern void (*Delete_Du_Manager_p) (DU_MANAGER *, MEM_POOL *);
< #define Delete_Du_Manager (*Delete_Du_Manager_p)
< 
< extern BOOL (*Verify_alias_p) (ALIAS_MANAGER *, WN *);
< #define Verify_alias (*Verify_alias_p)
< #else
288c189
< #endif // BUILD_FAST_BIN
---
> 
450,456d350
< #ifdef TARG_IA64
<       load_so ("orc_ict.so", CG_Path, Show_Progress);
<       load_so ("orc_intel.so", CG_Path, Show_Progress);
< #endif
< #if !defined(BUILD_FAST_BIN)
<       load_so ("cg.so", CG_Path, Show_Progress);
< #endif
462,464d355
< #if !defined(BUILD_FAST_BIN)
<       load_so ("wopt.so", WOPT_Path, Show_Progress);
< #endif
1174c1065,1067
<     if (!Run_wopt) {
---
>     if (!Run_wopt ||
>         // OSP 421, MLDID/MSTID is not lowered.
>         Query_Skiplist (WOPT_Skip_List, Current_PU_Count()) ) {
1184,1185c1077,1078
< 	if (Only_Unsigned_64_Bit_Ops &&
< 	    (!Run_wopt || Query_Skiplist (WOPT_Skip_List, Current_PU_Count()))) 	  U64_lower_wn(rwn, FALSE);
---
> 	if (Only_Unsigned_64_Bit_Ops && ! Run_wopt)
> 	  U64_lower_wn(rwn, FALSE);
1193,1200d1085
< #ifdef TARG_NVISA
<         // we want up-to-date addr_saved info
<         // in case original addr_saved got optimized away,
<         // in which case cg can avoid using local memory.
<         Set_BE_ST_pu_needs_addr_flag_adjust(Get_Current_PU_ST());
<         PU_adjust_addr_flags(Get_Current_PU_ST(), rwn);
< #endif
< 
1305,1314d1189
< #ifdef TARG_IA64
<     // Note a special case of try label when
<     // INITV_kind(INITO_val(ino_idx)) == INITVKIND_LABEL,
<     // Shouldn't set the flag ST_IS_NOT_USED
<     // Just reserve the value which gfecc pass through
<     if (INITV_kind(INITO_val(ino_idx)) != INITVKIND_LABEL){                
<       ST *st = INITO_st(ino_idx);
<       Clear_ST_is_not_used(st);
<     }
< #else
1317d1191
< #endif
1347,1350d1220
<   // But as a special case when INITV_kind(INITO_val(ino)) == INITVKIND_LABEL
<   // gfecc have set the flag ST_IS_NOT_USED, so though we needn't remarked 
<   // it to ST_IS_NOT_USED again, but it's OK as long as don't set this flag 
<   // when Update_EHRegion_Inito_Used.
1361d1230
<   // Not all the INITO sts referenced in WHIRL will be used.
1437,1439d1305
<     // annotation map should be constructed before LNO
<     WN_MEMOP_ANNOT_MGR_Constructor mem_annot_mgr;
< 
1513d1378
< #if defined(TARG_IA64)
1517,1527d1381
<     // trace the info of updated EH INITO      
<     if (Get_Trace (TP_EH, 0x0004)) {
<       fprintf (TFile, "=======================================================================\n");
<       fprintf (TFile, "\t  Used EH INITO info for PU: %s \t\n", 
< 		      ST_name (current_pu->proc_sym));
<       fprintf (TFile, "\t  (After Update_EHRegion_Inito) \t\n");
<       fprintf (TFile, "=======================================================================\n");
<       EH_Dump_INITOs (pu, TFile);
<     }
< #endif
< 
1555,1593c1409,1410
< } /* Backend_Processing */
< 
< #if defined(TARG_SL)
< BOOL Walk_And_Insert_Init_Buf(WN* wn, WN* block)
< {  
<   OPERATOR opr=WN_operator(wn);
<   if( opr == OPR_PRAGMA && WN_pragma( wn ) == WN_PRAGMA_PREAMBLE_END ) {
<     TY_IDX ty;
<     ST *st;
< 
<     ty = Make_Function_Type( MTYPE_To_TY( MTYPE_V ) );
<     
<     if(Sl2_Ibuf_Name==NULL)		
<       st = Gen_Intrinsic_Function( ty, "cmp_init_sl_buf" );
<     else
<       st = Gen_Intrinsic_Function( ty, Sl2_Ibuf_Name );
< 	
<     Clear_PU_no_side_effects( Pu_Table[ST_pu( st )] );
<     Clear_PU_is_pure( Pu_Table[ST_pu( st )] );
<     Set_PU_no_delete( Pu_Table[ST_pu( st )] );
< 
<     WN *call_initbuf = WN_Call( MTYPE_V, MTYPE_V, 0, st );
<     WN_Set_Call_Default_Flags(call_initbuf );		
<     WN_INSERT_BlockBefore(block, wn, call_initbuf);
<     return TRUE;
<   }
<   else if(opr==OPR_BLOCK) {
<     for ( WN* stmt = WN_first( wn ); stmt; stmt = WN_next( wn) )
<       if(Walk_And_Insert_Init_Buf( stmt, wn ))
<         return TRUE;
<   }
<   else {
<     for ( INT32 i = 0; i < WN_kid_count( wn ); i++ )
<       if(Walk_And_Insert_Init_Buf( WN_kid( wn, i ), wn ))
<         return TRUE;
<   }
<   return FALSE;
< 
< }
---
> #ifdef KEY // bug 9651
>     WN_Reset_Num_Delete_Cleanup_Fns();
1594a1412
> } /* Backend_Processing */
1651c1469
< 	BZERO (Feedback_Enabled, (PROFILE_PHASE_LAST-1) * sizeof(BOOL));
---
> 	bzero (Feedback_Enabled, (PROFILE_PHASE_LAST-1) * sizeof(BOOL));
1671c1489
<           BZERO(Feedback_Enabled, (PROFILE_PHASE_LAST-1) * sizeof(BOOL));
---
>           bzero(Feedback_Enabled, (PROFILE_PHASE_LAST-1) * sizeof(BOOL));
1774,1789d1591
< #if defined (TARG_SL)
<   if(Sl2_Inibuf) {
<     if( strcmp( Cur_PU_Name, "MAIN__" ) == 0 ||
< 	  strcmp( Cur_PU_Name, "main" ) == 0 ) {
<       WN* body=WN_func_body(pu);
<       WN* stmt=NULL;
<       for (stmt = WN_first( body ); stmt; stmt = WN_next( stmt ) ) {
<         if(Walk_And_Insert_Init_Buf( stmt, body ))	  
<           break;
<       }
< 
<       FmtAssert(stmt!=NULL, ("Insert_Init_Buf failed\n")); 
<     }
<   }
< #endif
< 
1803a1606,1615
> #ifdef KEY
>   /* Insert __cyg_profile_func_enter/exit instrumentation (Bug 570) */
>   if ( OPT_Cyg_Instrument > 0 && ! Run_ipl &&
>        ( ! PU_no_instrument(Get_Current_PU()) ||
> 	 PU_has_inlines(Get_Current_PU()) ) ) {
>     Set_Error_Phase ( "CYG Instrumenting" );
>     CYG_Instrument_Driver( pu );
>   }
> #endif
> 
1963d1774
< #if 0 // turn off for now - sc 2/23/08
1971d1781
< #endif
2067,2097d1876
< #ifdef TARG_SL
< // load target.so and initialize weak variable in target.so
< void init_ti_target(void *handle) {
<   char soname[12];
<   if (Is_Target_Sl1_pcore()) {
<     strcpy(soname, "sl1_pcore.so");
<   } else if (Is_Target_Sl2_pcore()) {
<     strcpy(soname, "sl2_pcore.so");
<   } else if (Is_Target_Sl1_dsp()) {
<     strcpy(soname, "sl1_dsp.so");
<   }else if (Target == TARGET_UNDEF) {
<     Is_True(0, ("undefined target"));
<   }
<   handle = dlopen(soname, RTLD_LAZY);
<   if (!handle) {
<     fprintf (stderr, "Error loading %s: %s\n", soname, dlerror());
<     exit (RC_SYSTEM_ERROR);
<   }
<   SI_resource_count_p = (INT *)dlsym(handle, "SI_resource_count");
<   SI_resources_p = (SI_RESOURCE *(*)[])dlsym(handle, "SI_resources");
<   SI_top_si_p = (SI *(*)[])dlsym(handle, "SI_top_si");
<   SI_RRW_initializer_p = (SI_RRW *)dlsym(handle, "SI_RRW_initializer");
<   SI_RRW_overuse_mask_p = (SI_RRW *)dlsym(handle, "SI_RRW_overuse_mask");
<   SI_issue_slot_count_p = (INT *)dlsym(handle, "SI_issue_slot_count");
<   SI_issue_slots_p = (SI_ISSUE_SLOT *(*)[])dlsym(handle, "SI_issue_slots");
<   SI_ID_count_p = (INT *)dlsym(handle, "SI_ID_count");
<   SI_ID_si_p = (SI *(*)[])dlsym(handle, "SI_ID_si");
<   return;
< }
< #endif
< 
2102d1880
< 
2108,2114c1886
< #ifdef TARG_SL
<   void *handle;
< #endif  
< #ifdef __MINGW32__
<   setvbuf(stdout, (char *)NULL, _IOLBF, 0);
<   setvbuf(stderr, (char *)NULL, _IOLBF, 0);
< #else
---
>   
2117d1888
< #endif
2122,2124d1892
< #if !defined(SHARED_BUILD)
<   Set_Error_Tables ( Phases, host_errlist );
< #endif
2142a1911,1912
> 
> #ifndef KEY
2146a1917
> #endif
2149,2151c1920
< #ifdef TARG_SL
<   init_ti_target(handle);
< #endif
---
>     
2180,2190c1949
< 
<   INT pu_num;
<   pu_tree = Read_Global_Info (&pu_num);
< 
< #if defined(TARG_SL)
<   if (Run_ipisr) {
<     isr_cg = CXX_NEW_ARRAY(ISR_NODE, pu_num, &MEM_src_nz_pool);
<     Read_isr_cg(isr_cg, pu_num);
<   }
< #endif
< 
---
>   pu_tree = Read_Global_Info (NULL);
2289,2290d2047
< 
<   if (!Run_ipisr) {
2296,2306d2052
<   } else {
<     INT i = 0;
<     for (PU_Info *current_pu = pu_tree;
<          current_pu != NULL;
<          current_pu = PU_Info_next(current_pu), i++) 
<     {
<        Merge_Parents_Regset(isr_cg[i]); 
<        Preorder_Process_PUs(current_pu);
<     }
<   }
< 
2313a2060,2070
> #ifdef KEY
>   //Bug 10252: move list options to here (the end of BE), so that
>   // it can show appropriate target-dependent options
>   if ( List_Enabled ) {
>     Mhd_Options.Merge_Options(Mhd);
>     Prepare_Listing_File ();
>     List_Compile_Options ( Lst_File, "", FALSE, List_All_Options, FALSE );
>   }
> #endif
> 
> 
2374a2132
> 
2376a2135
> 
driver.cxx
driver_util.cxx
45,47c45,47
<  * $Date: 06/02/28 20:37:41-08:00 $
<  * $Author: fchow@fluorspar.internal.keyresearch.com $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.driver_util.cxx $
---
>  * $Date: 04/12/21 14:57:03-08:00 $
>  * $Author: bos@eng-25.internal.keyresearch.com $
>  * $Source: /home/bos/bk/kpro64-pending/be/be/SCCS/s.driver_util.cxx $
79,80d78
< BOOL warnings_are_errors = FALSE;
< 
206,222d203
< #ifdef TARG_IA64         
< 	    case 'I':       /* CG-specific */
< 	                    /* -IPFEC: IPFEC related options */
< 	        add_phase_args (PHASE_CG, argv[i]);
< 	        break;  
< 
< 	    case 'C':       /* CG-specific */
< 	                    /* -CYCLE: Cycle Counting related options */
< 	        add_phase_args (PHASE_CG, argv[i]);
< 	        Create_Cycle_Output = TRUE; 
< 	        break;  
< 
< 	    case 'V':       /* CG-specific */
< 	                    /* -VT: Visualization Tool related options */
< 	        add_phase_args (PHASE_CG, argv[i]);
< 	        break;          
< #endif              
262,266d242
< #if defined(TARG_NVISA)
< 		    case 'c':	    /* whirl2c output file */
< 			Whirl2C_File_Name = cp + 2;
< 			break;
< #endif
312,314d287
< #ifdef TARG_IA64
< 		if (Debug_Level > 0 && !opt_set)
< #else
316d288
< #endif
378,383d349
< 
< 	    case 'i':
< 		if (strcmp (cp, "pisr") == 0) {
< 		    Run_ipisr = TRUE;
< 		    break;
< 		}
410,414d375
< 	    case 'W':		    /* Suppress warnings */
< 		if (strcmp(cp, "error") == 0) {
< 		    warnings_are_errors = TRUE;
< 		}
< 		break;
518,528c479
<     /* In kernel building, we may generate several object files from 
<      * single .c file, the good way to name the related files should be
<      * according to the object file in the original user command. But the
<      * original object file is not transferred to the 'be', so I can use
<      * Irb_File_Name instead, which comes from the original object file
<      */
<     char *fname;
<     if( Irb_File_Name )
<       fname = Last_Pathname_Component ( Irb_File_Name );
<     else
<       fname = Last_Pathname_Component ( Src_File_Name );
---
>     char *fname = Last_Pathname_Component ( Src_File_Name );
driver_util.cxx
fill_align.cxx
fill_align.cxx
goto_conv.cxx
2c2
<  * Copyright 2007 PathScale, LLC.  All Rights Reserved.
---
>  * Copyright 2007, 2008 PathScale, LLC.  All Rights Reserved.
719a720,721
>   // Early goto-conversion is now OFF by default for fortran, so the above
>   // should always return true by default (bug 14188).
goto_conv.cxx
isr.cxx
isr.cxx
iter.cxx
40,43c40,43
<  * $Revision: 1.2 $
<  * $Date: 02/11/07 23:41:18-00:00 $
<  * $Author: fchow@keyresearch.com $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.iter.cxx $
---
>  * $Revision$
>  * $Date$
>  * $Author$
>  * $Source$
57c57
< static char *rcs_id = iter_C"$Revision: 1.2 $";
---
> static char *rcs_id = iter_C"$Revision$";
iter.cxx
mem_ctr.cxx
mem_ctr.cxx
omp_lower.cxx
42,45c42,45
<  * $Revision: 1.25 $
<  * $Date: 05/12/22 15:18:19-08:00 $
<  * $Author: gautam@jacinth.keyresearch $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.omp_lower.cxx $
---
>  * $Revision: 1.23 $
>  * $Date: 05/05/04 09:52:08-07:00 $
>  * $Author: gautam@eng-27.pathscale.com $
>  * $Source: ../../be/be/SCCS/s.omp_lower.cxx $
98,99d97
< #if !defined(BUILD_OS_DARWIN) || !defined(BUILD_SKIP_PROMPF)
< #pragma weak Anl_File_Path
100a99,100
> #if ! defined(BUILD_OS_DARWIN)
> #pragma weak Anl_File_Path
222,226d221
< #ifdef TARG_SL2 //fork_joint
< static WN *Is_SL2_Section_Begin(WN *wn);
< static void Convert_SL2_Section_To_Pdo(WN *sections, WN *pragma);
< #endif 
< 
234d228
< #ifndef BUILD_SKIP_PROMPF
240d233
< #endif
250d242
< #ifndef BUILD_SKIP_PROMPF
258d249
< #endif
318,326d308
< #if defined(TARG_SL2)
<   if(Cur_PU_Feedback)
< 	Cur_PU_Feedback->Verify("sl2 psection conversion");
< #endif
< 
< #if defined(TARG_SL) && defined(TARG_SL2)
<   if(Cur_PU_Feedback)
<     Cur_PU_Feedback->Verify("sl2 psection conversion");
< #endif
1034,1041d1015
< 
< #ifdef TARG_SL2 //fork_joint
<    WN* sl2_section = Is_SL2_Section_Begin(wn);
<    if(sl2_section) {
<        Convert_SL2_Section_To_Pdo(wn, sl2_section);
<    } 
< #endif 
<   
1531,1728d1504
< 
< 
< #ifdef TARG_SL2 //fork_joint
< static void Convert_SL2_Section_To_Pdo(WN *sections, WN *pragma)
< {
<   MEM_POOL_Popper popper(&Omp_Local_Pool);
< 
<   WN_pragma_arg1(pragma) = 0;
<   WN_pragma_arg2(pragma) = 1;
< 
< // add one exit for enclosing region 
<   Is_True(WN_opcode(sections) == OPC_REGION,  ("expected a region node")); 
< 
<   // delete the end sections if it exists
<   WN *end_sec = WN_last(WN_region_body(sections));
<   if (end_sec && WN_opcode(end_sec) == OPC_PRAGMA &&
<       ((WN_PRAGMA_ID)WN_pragma(end_sec) == WN_PRAGMA_PSECTION_END)) {
<     WN_Delete(WN_EXTRACT_FromBlock(WN_region_body(sections),end_sec));
<   }
<  
<   // Walk the code, replacing each section with a label
<   // recall that the first section might be implicit
<   // store the labels in a stack
<   STACK_OF_WN *sec_stack = CXX_NEW(STACK_OF_WN(&Omp_Local_Pool),
< 					&Omp_Local_Pool);
<   WN *tmp = WN_first(WN_region_body(sections));
<   WN* parent = WN_region_body(sections);
<   // now find the other sections
<   BOOL first_region = TRUE;
<   while (tmp) {
<     WN *next = WN_next(tmp);
<     if(WN_opcode(tmp) == OPC_REGION && WN_first(WN_region_pragmas(tmp)) && 
< 	  (WN_pragma(WN_first(WN_region_pragmas(tmp))) == WN_PRAGMA_BARRIER)) 
<     {
< 
<        //added by xma, not to create c2_joint in fe, but in vho to enable annotation for parallel program
<        WN_INSERT_BlockAfter(WN_region_body(tmp), WN_last(WN_region_body(tmp)),
<                             WN_Create_Intrinsic (OPR_INTRINSIC_CALL, MTYPE_V, MTYPE_V,
< 				      INTRN_C2_JOINT, 0, 0));
< 
<       WN_DELETE_FromBlock(WN_region_pragmas(tmp),  WN_first(WN_region_pragmas(tmp)));
< 
<       if( first_region )
<         first_region = FALSE;
<       else {
<         if(Cur_PU_Feedback) {
<           Cur_PU_Feedback->Annot(tmp, FB_EDGE_CALL_OUTGOING, FB_FREQ_ZERO);
<           Cur_PU_Feedback->FB_reset_in_out_same_node(tmp);
<         } 
<       }
<     }
< 
< 
<     if (WN_opcode(tmp) == OPC_PRAGMA &&
<         ((WN_PRAGMA_ID)WN_pragma(tmp) == WN_PRAGMA_SL2_SECTION)) {
<       WN *label = New_Label();
<       WN_INSERT_BlockBefore(WN_region_body(sections),tmp,label);
<       Set_Parent(label,WN_region_body(sections));
<       sec_stack->Push(label);
<       if (next) {
<         WN_Set_Linenum(label,WN_Get_Linenum(next));
<         WN* next_rgn=next;
<         while(next_rgn!=NULL && WN_operator(next_rgn)!=OPR_REGION) {
<           next_rgn=WN_next(next_rgn);
<         }
<         FmtAssert(next_rgn!=NULL, ("Convert_SL2_Section_To_Pdo: cannot find next region"));
<         if(Cur_PU_Feedback) {
<            FB_FREQ fb_into_region = Cur_PU_Feedback->Query(next_rgn, FB_EDGE_CALL_INCOMING);
<            FB_Info_Invoke fb_label(fb_into_region);
<            Cur_PU_Feedback->Annot_invoke(label, fb_label);
<         }
<       }
<       WN_DELETE_FromBlock(WN_region_body(sections),tmp);
<     }
<     tmp = next;
<   }
< 
< 
<  WN_OFFSET index_offset = Create_Preg(MTYPE_I4,"sl2_section");
< 
<   WN *comp_goto_block = WN_CreateBlock();
< 
<   WN *cgoto = WN_CreateCompgoto(sec_stack->Elements(),
< 				WN_LdidPreg ( MTYPE_I4,index_offset),
< 				comp_goto_block,NULL,0);
< 
< /* need distinguish is major fork or minor fork */ 
<   if((WN_PRAGMA_ID) WN_pragma(pragma) == WN_PRAGMA_SL2_MINOR_PSECTION_BEGIN) 
< // minor thread
<   {
<     WN_Set_is_compgoto_for_minor(cgoto);	
<   }
<   else if((WN_PRAGMA_ID) WN_pragma(pragma) == WN_PRAGMA_SL2_MAJOR_PSECTION_BEGIN ) //main thread
<   {
<       WN_Set_is_compgoto_para(cgoto); 
<   }	  
< 
<   WN_Set_Linenum(cgoto,WN_Get_Linenum(sections));
< 
< 
< 
<   INT i;
<   for (i=0; i<sec_stack->Elements(); i++) {
<     WN *label_goto = 
<     WN_CreateGoto((ST*) NULL,WN_label_number(sec_stack->Bottom_nth(i)));
<     WN_Set_Linenum(label_goto,WN_Get_Linenum(sections));
<     WN* label=sec_stack->Bottom_nth(i);
<     WN_CopyMap(label_goto, WN_MAP_FEEDBACK, label);
<     WN_INSERT_BlockBefore(comp_goto_block,NULL,label_goto);
<   }
< 
<   if(Cur_PU_Feedback) {
<     INT32 cgoto_size = sec_stack->Elements();
<     FB_Info_Switch fb_info_sw(cgoto_size + 1 );
<     fb_info_sw[ FB_EDGE_SWITCH_INDEX( FB_EDGE_SWITCH_DEFAULT ) ]= FB_FREQ_UNKNOWN;
<     for(i=0;i<cgoto_size;i++)  {
<       WN* label=sec_stack->Bottom_nth(i);
<       FB_Info_Invoke fb_info_iv = Cur_PU_Feedback->Query_invoke( label );
<       fb_info_sw[ FB_EDGE_SWITCH_INDEX( FB_EDGE_SWITCH( i ) ) ] =  fb_info_iv.freq_invoke;
<     }
<     Cur_PU_Feedback->Annot_switch(cgoto, fb_info_sw);
<   }
< 
<   WN* tmp_block = WN_CreateBlock();
<   WN_Set_Linenum(tmp_block, WN_Get_Linenum(sections));
<   WN_INSERT_BlockAfter(tmp_block, NULL, cgoto);
< 
<   // Move all the code after the compgoto
<   WN *region_body = WN_region_body(sections);
<   while (WN_last(region_body)) {
<     WN *wn = WN_EXTRACT_FromBlock(region_body,WN_last(region_body));
<     WN_INSERT_BlockAfter(tmp_block, cgoto, wn);
<     Set_Parent(wn, tmp_block);
<   }
< 
<   // Create a new label at the end of the do loop
<   // Put a jump to this label at the end of every section
<   WN *exit_label = New_Label();
<   for (i=1; i<sec_stack->Elements(); i++) {
<     WN *exit_goto = WN_CreateGoto((ST*) NULL,WN_label_number(exit_label));
<     WN_Set_Linenum(exit_goto,WN_Get_Linenum(sec_stack->Bottom_nth(i-1)));
<     if(Cur_PU_Feedback) {
<       WN* prev_label=sec_stack->Bottom_nth(i-1);		
<       WN* exit_rgn=WN_next(prev_label);
<       while(exit_rgn!=NULL && WN_operator(exit_rgn)!=OPR_REGION) {
<          exit_rgn=WN_next(exit_rgn);
<       }	  
<       FmtAssert(exit_rgn!=NULL, ("Convert_SL2_Section_To_Pdo: cannot find next region"));
<       if(Cur_PU_Feedback) {
<            FB_FREQ fb_out_region = Cur_PU_Feedback->Query(exit_rgn, FB_EDGE_CALL_OUTGOING);
<            FB_Info_Invoke fb_goto(fb_out_region);
<            Cur_PU_Feedback->Annot_invoke(exit_goto, fb_goto);
<       }
<     }
<     WN_INSERT_BlockBefore(tmp_block,
< 	sec_stack->Bottom_nth(i),exit_goto);
<     Set_Parent(exit_goto, tmp_block);
<   }
< 
<   if(Cur_PU_Feedback) 
<     Cur_PU_Feedback->Annot(exit_label, FB_EDGE_INCOMING, 
<         Cur_PU_Feedback->Query(sections, FB_EDGE_CALL_OUTGOING));
< 
<   WN_INSERT_BlockBefore(tmp_block, NULL,exit_label);
< //  Set_Parent(exit_label, tmp_block);
< //  WN_Set_Linenum(exit_label,WN_Get_Linenum(sections));
<   // Insert the do
<   WN_INSERT_BlockAfter(WN_region_body(sections), NULL, tmp_block);
<   Parentize(WN_region_body(sections));
< /* add barrier. */ 
< }
< 
< 
< static WN *Is_SL2_Section_Begin(WN *wn)
< {
<   if (WN_opcode(wn) != OPC_REGION) {
<     return FALSE;
<   }
<   WN *pragmas = WN_region_pragmas(wn);
<   if (pragmas) {
<     WN *pragma = WN_first(pragmas);
<     while (pragma) {
<       if (WN_opcode(pragma) == OPC_PRAGMA) {
<         if ((WN_PRAGMA_ID)WN_pragma(pragma)==WN_PRAGMA_SL2_MAJOR_PSECTION_BEGIN
< 		|| (WN_PRAGMA_ID) WN_pragma(pragma) == WN_PRAGMA_SL2_MINOR_PSECTION_BEGIN) {
< 	  return pragma;
<         } 
<       }
<       pragma = WN_next(pragma);
<     }
<   }
<   return NULL;
< }
< #endif //fork_joint
< 
< 
< 
< 
1803,1807d1578
< #ifdef TARG_IA64
<     case MTYPE_F10: 
<       sprintf(name,"%s","__OMP_CRITICAL_ATOMIC_F10");
<       break;
< #endif
1817,1821d1587
< #ifdef TARG_IA64
<     case MTYPE_C10:
<       sprintf(name,"%s","__OMP_CRITICAL_ATOMIC_C10");
<       break;
< #endif
2642,2648d2407
< #ifdef TARG_IA64
<     case MTYPE_F10:
< 	alclass = ALCLASS_CRITICAL;	/* XXX - ALCLASS_SWAP? */
< 	break;
< 
<     case MTYPE_C10:
< #endif
3241,3248c3000,3002
<  * and variables in them can't appear in any scope clauses; (2) FIRSTPRIVATE,
<  * LASTPRIVATE and REDUCTION variables in a worksharing construct lexically 
<  * enclosed by a parallel region must have shared scope in the parallel 
<  * region.
<  *
<  * For a PRIVATE variable in a worksharing construct lexically enclosed by
<  * a parall region, if it's not shared in that parallel region, just ignore
<  * the inner PRIVATE clause. (Reprivatization is legal)
---
>  * and variables in them can't appear in any scope clauses; (2) privatized
>  * and REDUCTION variables in a worksharing construct lexically enclosed
>  * by a parallel region must have shared scope in the parallel region.
3814d3567
< #ifndef BUILD_SKIP_PROMPF
3822d3574
< #endif
omp_lower.cxx
rewrite_pragmas.cxx
rewrite_pragmas.cxx
wb_anl.cxx
43d42
< #include <sys/types.h>
48c47
< #endif
---
> #endif /* defined(BUILD_OS_DARWIN) */
wb_anl.cxx
wb_lwr.cxx
43a44,46
> #if defined(BUILD_OS_DARWIN)
> #include "darwin_elf.h"
> #else /* defined(BUILD_OS_DARWIN) */
44a48
> #endif /* defined(BUILD_OS_DARWIN) */
wb_lwr.cxx
wb_omp.cxx
wb_omp.cxx
dra_ec.h
dra_ec.h
dra_export.h
dra_export.h
dra_internal.h
dra_internal.h
driver_util.h
40,43c40,43
<  * $Revision: 1.2 $
<  * $Date: 02/11/07 23:41:18-00:00 $
<  * $Author: fchow@keyresearch.com $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.driver_util.h $
---
>  * $Revision$
>  * $Date$
>  * $Author$
>  * $Source$
73,74d72
< extern BOOL warnings_are_errors;
< 
driver_util.h
goto_conv.h
goto_conv.h
isr.h
isr.h
iter.h
40,43c40,43
<  * $Revision: 1.2 $
<  * $Date: 02/11/07 23:41:18-00:00 $
<  * $Author: fchow@keyresearch.com $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.iter.h $
---
>  * $Revision$
>  * $Date$
>  * $Author$
>  * $Source$
58c58
< static char *be_utilrcs_id = "$Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.iter.h $ $Revision: 1.2 $";
---
> static char *be_utilrcs_id = "$Source$ $Revision$";
iter.h
mem_ctr.h
mem_ctr.h
omp_lower.h
38,41c38,41
<  * $Revision: 1.2 $
<  * $Date: 02/11/07 23:41:18-00:00 $
<  * $Author: fchow@keyresearch.com $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.omp_lower.h $
---
>  * $Revision$
>  * $Date$
>  * $Author$
>  * $Source$
omp_lower.h
pragma_weak.h
39,42c39,42
<  * $Revision: 1.2 $
<  * $Date: 02/11/07 23:41:18-00:00 $
<  * $Author: fchow@keyresearch.com $
<  * $Source: /scratch/mee/2.4-65/kpro64-pending/be/be/SCCS/s.pragma_weak.h $
---
>  * $Revision$
>  * $Date$
>  * $Author$
>  * $Source$
55d54
< #ifdef SHARED_BUILD
63d61
< #endif
pragma_weak.h
wb_anl.h
wb_anl.h
wb_lwr.h
wb_lwr.h
wb_omp.h
wb_omp.h
